<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="color-scheme" content="light dark">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Neovim help pages, always up-to-date">
<title>Neovim: lsp.txt</title>
<link rel="shortcut icon" href="s/h3E0J2MHNKfIuCqP/favicon-neovim.ico">
<!-- favicon taken from https://neovim.io/favicon.ico, which is licensed under CC-BY-3.0: https://creativecommons.org/licenses/by/3.0/ -->

<link rel="stylesheet" href="s/MsMIu46igYudff1x/tom-select.min.css">
<script defer src="s/RLcAbtLBYX-q5me0/tom-select.base.min.js"></script>

<link rel="stylesheet" href="s/QRMkrs52-wJfIQ-w/vimhelp.css">
<noscript><link rel="stylesheet" href="s/eRFCn9A-K4lmzV_A/noscript.css"></noscript>
<script defer src="s/KpwrKyx19dtnhPoe/vimhelp.js"></script>
</head>
<body>




<div class="bar">
  <div class="ql">Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
</div>
  <div class="tag srch need-js">
    <select id="vh-select-tag"></select>
    <div class="placeholder">Go to keyword<span class="not-mobile">&nbsp;(shortcut: <kbd>k</kbd>)</span></div>
  </div>
  <form class="site srch" action="https://duckduckgo.com" method="get" target="_blank" rel="noopener noreferrer">
    <input type="hidden" name="sites" value="neo.vimhelp.org">
    <input type="search" name="q" id="vh-srch-input" placeholder="Site search">
    <div class="placeholder need-js">Site search<span class="not-mobile">&nbsp;(shortcut: <kbd>s</kbd>)</span></div>
  </form>
  <div id="theme-switcher" class="need-js">
  <button id="theme-current" title="Switch theme">Theme</button>
  <div id="theme-dropdown"><ul>
    <li><button id="theme-native" title="Switch to native theme">Native</button></li>
    <li><button id="theme-light" title="Switch to light theme">Light</button></li>
    <li><button id="theme-dark" title="Switch to dark theme">Dark</button></li>
  </ul></div>
</div>

</div>

<main>
<div id="vh-sidebar">
<ul><li><a href="lsp.txt.html#">↑Top↑</a></li>
<li><a href="lsp.txt.html#lsp-core">Lua module: vim.lsp</a></li>
<li><a href="lsp.txt.html#lsp-client">Lua module: vim.lsp.client</a></li>
<li><a href="lsp.txt.html#lsp-buf">Lua module: vim.lsp.buf</a></li>
<li><a href="lsp.txt.html#lsp-diagnostic">Lua module: vim.lsp.diagnostic</a></li>
<li><a href="lsp.txt.html#lsp-codelens">Lua module: vim.lsp.codelens</a></li>
<li><a href="lsp.txt.html#lsp-completion">Lua module: vim.lsp.completion</a></li>
<li><a href="lsp.txt.html#lsp-inlay_hint">Lua module: vim.lsp.inlay_hint</a></li>
<li><a href="lsp.txt.html#lsp-semantic_tokens">Lua module: vim.lsp.semantic_tokens</a></li>
<li><a href="lsp.txt.html#lsp-util">Lua module: vim.lsp.util</a></li>
<li><a href="lsp.txt.html#lsp-log">Lua module: vim.lsp.log</a></li>
<li><a href="lsp.txt.html#lsp-rpc">Lua module: vim.lsp.rpc</a></li>
<li><a href="lsp.txt.html#lsp-protocol">Lua module: vim.lsp.protocol</a></li>
</ul>
</div>
<div id="vh-content">
<pre>
<span id="lsp.txt" class="t">lsp.txt</span>   <a href="lsp.txt.html#LSP" class="d">LSP</a>


                            <span class="i">NVIM REFERENCE MANUAL</span>


<a href="lsp.txt.html#LSP" class="d">LSP</a> client/framework                                     <span id="lsp" class="t">lsp</span> <span id="LSP" class="t">LSP</span>

Nvim supports the Language Server Protocol (LSP), which means <a href="motion.txt.html#it" class="d">it</a> acts <a href="motion.txt.html#as" class="d">as</a>
<a href="insert.txt.html#a" class="d">a</a> client to <a href="lsp.txt.html#LSP" class="d">LSP</a> servers and includes <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> framework <span class="e">vim.lsp</span> <a href="luaref.txt.html#for" class="d">for</a> building
enhanced <a href="lsp.txt.html#LSP" class="d">LSP</a> tools.

    <a class="u" href="https://microsoft.github.io/language-server-protocol/">https://microsoft.github.io/language-server-protocol/</a>

<a href="lsp.txt.html#LSP" class="d">LSP</a> facilitates features like go-to-definition, find references, hover,
completion, rename, format, refactor, etc., using semantic whole-project
analysis (unlike <a href="tagsrch.txt.html#ctags" class="l">ctags</a>).

                                      Type <a href="various.txt.html#gO" class="l">gO</a> to see the table of contents.

<span class="h">==============================================================================</span>
<span class="c">QUICKSTART</span>                                              <span id="lsp-quickstart" class="t">lsp-quickstart</span>

Nvim provides an <a href="lsp.txt.html#LSP" class="d">LSP</a> client, but the servers are provided by third parties.
Follow these steps to get <a href="lsp.txt.html#LSP" class="d">LSP</a> features:

1. Install language servers using your package manager or by following the
   upstream installation instructions. You can find language servers here:
   <a class="u" href="https://microsoft.github.io/language-server-protocol/implementors/servers/">https://microsoft.github.io/language-server-protocol/implementors/servers/</a>

2. Use <a href="lsp.txt.html#vim.lsp.config%28%29" class="l">vim.lsp.config()</a> to define <a href="insert.txt.html#a" class="d">a</a> configuration <a href="luaref.txt.html#for" class="d">for</a> an <a href="lsp.txt.html#LSP" class="d">LSP</a> client
   (see <a class="u" href="https://github.com/neovim/nvim-lspconfig">https://github.com/neovim/nvim-lspconfig</a> <a href="luaref.txt.html#for" class="d">for</a> examples).
   Example: 
<span class="e">     vim.lsp.config['luals'] = {</span>
<span class="e">       -- Command and arguments to start the server.</span>
<span class="e">       cmd = { 'lua-language-server' },</span>
<span class="e"></span>
<span class="e">       -- Filetypes to automatically attach to.</span>
<span class="e">       filetypes = { 'lua' },</span>
<span class="e"></span>
<span class="e">       -- Sets the "root directory" to the parent directory of the file in the</span>
<span class="e">       -- current buffer that contains either a ".luarc.json" or a</span>
<span class="e">       -- ".luarc.jsonc" file. Files that share a root directory will reuse</span>
<span class="e">       -- the connection to the same LSP server.</span>
<span class="e">       -- Nested lists indicate equal priority, see |vim.lsp.Config|.</span>
<span class="e">       root_markers = { { '.luarc.json', '.luarc.jsonc' }, '.git' },</span>
<span class="e"></span>
<span class="e">       -- Specific settings to send to the server. The schema for this is</span>
<span class="e">       -- defined by the server. For example the schema for lua-language-server</span>
<span class="e">       -- can be found here https://raw.githubusercontent.com/LuaLS/vscode-lua/master/setting/schema.json</span>
<span class="e">       settings = {</span>
<span class="e">         Lua = {</span>
<span class="e">           runtime = {</span>
<span class="e">             version = 'LuaJIT',</span>
<span class="e">           }</span>
<span class="e">         }</span>
<span class="e">       }</span>
<span class="e">     }</span>
<span class="e"></span>
3. Use <a href="lsp.txt.html#vim.lsp.enable%28%29" class="l">vim.lsp.enable()</a> to enable <a href="insert.txt.html#a" class="d">a</a> configuration.
   Example: 
<span class="e">     vim.lsp.enable('luals')</span>

4. Open <a href="insert.txt.html#a" class="d">a</a> code file matching one of the <span class="e">filetypes</span> specified in the config.
   <span class="n">Note:</span> Depending on the <a href="lsp.txt.html#LSP" class="d">LSP</a> server, you may need to ensure your project has
   <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#lsp-root_markers" class="l">lsp-root_markers</a> file so the workspace can be recognized.

5. Check that <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="motion.txt.html#is" class="d">is</a> active <a href="motion.txt.html#%28" class="d">(</a>"attached"<a href="motion.txt.html#%29" class="d">)</a> <a href="luaref.txt.html#for" class="d">for</a> the buffer: 
<span class="e">    :checkhealth vim.lsp</span>

6. (Optional) Configure keymaps and autocommands to use <a href="lsp.txt.html#LSP" class="d">LSP</a> features.
   <a href="lsp.txt.html#lsp-attach" class="l">lsp-attach</a>

<span class="h">==============================================================================</span>
<span class="c">DEFAULTS</span>                                                <span id="lsp-defaults" class="t">lsp-defaults</span>

When the Nvim <a href="lsp.txt.html#LSP" class="d">LSP</a> client starts <a href="motion.txt.html#it" class="d">it</a> enables diagnostics <a href="diagnostic.txt.html#vim.diagnostic" class="l">vim.diagnostic</a> (see
<a href="diagnostic.txt.html#vim.diagnostic.config%28%29" class="l">vim.diagnostic.config()</a> to customize). It also sets <a href="various.txt.html#various" class="d">various</a> default options,
listed below, if (1) the language server supports the functionality and (2)
the <a href="options.txt.html#options" class="d">options</a> are empty or were set by the builtin runtime (ftplugin) files. The
<a href="options.txt.html#options" class="d">options</a> are not restored when the <a href="lsp.txt.html#LSP" class="d">LSP</a> client <a href="motion.txt.html#is" class="d">is</a> stopped or detached.

<span class="c">GLOBAL DEFAULTS</span><span id="_global-defaults"></span>
                                          <span id="grr" class="t">grr</span> <span id="gra" class="t">gra</span> <span id="grn" class="t">grn</span> <span id="gri" class="t">gri</span> <span id="grt" class="t">grt</span> <span id="i_CTRL-S" class="t">i_CTRL-S</span>
These GLOBAL keymaps are created unconditionally when Nvim starts:
<a href="motion.txt.html#-" class="d">-</a> "<a href="lsp.txt.html#grn" class="d">grn</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> mode to <a href="lsp.txt.html#vim.lsp.buf.rename%28%29" class="l">vim.lsp.buf.rename()</a>
<a href="motion.txt.html#-" class="d">-</a> "<a href="lsp.txt.html#gra" class="d">gra</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> and <a href="visual.txt.html#Visual" class="d">Visual</a> mode to <a href="lsp.txt.html#vim.lsp.buf.code_action%28%29" class="l">vim.lsp.buf.code_action()</a>
<a href="motion.txt.html#-" class="d">-</a> "<a href="lsp.txt.html#grr" class="d">grr</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> mode to <a href="lsp.txt.html#vim.lsp.buf.references%28%29" class="l">vim.lsp.buf.references()</a>
<a href="motion.txt.html#-" class="d">-</a> "<a href="lsp.txt.html#gri" class="d">gri</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> mode to <a href="lsp.txt.html#vim.lsp.buf.implementation%28%29" class="l">vim.lsp.buf.implementation()</a>
<a href="motion.txt.html#-" class="d">-</a> "<a href="lsp.txt.html#grt" class="d">grt</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> mode to <a href="lsp.txt.html#vim.lsp.buf.type_definition%28%29" class="l">vim.lsp.buf.type_definition()</a>
<a href="motion.txt.html#-" class="d">-</a> "<a href="various.txt.html#gO" class="d">gO</a>" <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="intro.txt.html#Normal" class="d">Normal</a> mode to <a href="lsp.txt.html#vim.lsp.buf.document_symbol%28%29" class="l">vim.lsp.buf.document_symbol()</a>
<a href="motion.txt.html#-" class="d">-</a> <span class="k">CTRL-S</span> <a href="motion.txt.html#is" class="d">is</a> mapped in <a href="insert.txt.html#Insert" class="d">Insert</a> mode to <a href="lsp.txt.html#vim.lsp.buf.signature_help%28%29" class="l">vim.lsp.buf.signature_help()</a>

<span class="c">BUFFER-LOCAL DEFAULTS</span><span id="_bufferlocal-defaults"></span>
<a href="motion.txt.html#-" class="d">-</a> <a href="options.txt.html#%27omnifunc%27" class="o">'omnifunc'</a> <a href="motion.txt.html#is" class="d">is</a> set to <a href="lsp.txt.html#vim.lsp.omnifunc%28%29" class="l">vim.lsp.omnifunc()</a><a href="motion.txt.html#%2C" class="d">,</a> use <a href="insert.txt.html#i_CTRL-X_CTRL-O" class="l">i_CTRL-X_CTRL-O</a> to trigger
  completion.
<a href="motion.txt.html#-" class="d">-</a> <a href="options.txt.html#%27tagfunc%27" class="o">'tagfunc'</a> <a href="motion.txt.html#is" class="d">is</a> set to <a href="lsp.txt.html#vim.lsp.tagfunc%28%29" class="l">vim.lsp.tagfunc()</a><a href="repeat.txt.html#." class="d">.</a> This enables features like
  go-to-definition, <a href="tagsrch.txt.html#%3Atjump" class="l">:tjump</a><a href="motion.txt.html#%2C" class="d">,</a> and keymaps like <a href="tagsrch.txt.html#CTRL-%5D" class="l">CTRL-]</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="windows.txt.html#CTRL-W_%5D" class="l">CTRL-W_]</a><a href="motion.txt.html#%2C" class="d">,</a>
  <a href="windows.txt.html#CTRL-W_%7D" class="l">CTRL-W_}</a> to utilize the language server.
<a href="motion.txt.html#-" class="d">-</a> <a href="options.txt.html#%27formatexpr%27" class="o">'formatexpr'</a> <a href="motion.txt.html#is" class="d">is</a> set to <a href="lsp.txt.html#vim.lsp.formatexpr%28%29" class="l">vim.lsp.formatexpr()</a><a href="motion.txt.html#%2C" class="d">,</a> so you can format lines via
  <a href="change.txt.html#gq" class="l">gq</a> if the language server supports it.
  <a href="motion.txt.html#-" class="d">-</a> To opt out of this use <a href="change.txt.html#gw" class="l">gw</a> instead of gq, or clear <a href="options.txt.html#%27formatexpr%27" class="o">'formatexpr'</a> on <a href="lsp.txt.html#LspAttach" class="l">LspAttach</a><a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> <a href="various.txt.html#K" class="l">K</a> <a href="motion.txt.html#is" class="d">is</a> mapped to <a href="lsp.txt.html#vim.lsp.buf.hover%28%29" class="l">vim.lsp.buf.hover()</a> unless <a href="options.txt.html#%27keywordprg%27" class="l">'keywordprg'</a> <a href="motion.txt.html#is" class="d">is</a> customized or
  <a href="insert.txt.html#a" class="d">a</a> custom keymap <a href="luaref.txt.html#for" class="d">for</a> <span class="e">K</span> exists.

<span class="c">DISABLING DEFAULTS</span>                                      <span id="lsp-defaults-disable" class="t">lsp-defaults-disable</span>
You can remove GLOBAL keymaps <a href="motion.txt.html#at" class="d">at</a> any time using <a href="lua.txt.html#vim.keymap.del%28%29" class="l">vim.keymap.del()</a> or
<a href="map.txt.html#%3Aunmap" class="l">:unmap</a><a href="repeat.txt.html#." class="d">.</a> See also <a href="change.txt.html#gr-default" class="l">gr-default</a><a href="repeat.txt.html#." class="d">.</a>

To remove or override BUFFER-LOCAL defaults, define <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#LspAttach" class="l">LspAttach</a> handler: 
<span class="e"></span>
<span class="e">    vim.api.nvim_create_autocmd('LspAttach', {</span>
<span class="e">      callback = function(args)</span>
<span class="e">        -- Unset 'formatexpr'</span>
<span class="e">        vim.bo[args.buf].formatexpr = nil</span>
<span class="e">        -- Unset 'omnifunc'</span>
<span class="e">        vim.bo[args.buf].omnifunc = nil</span>
<span class="e">        -- Unmap K</span>
<span class="e">        vim.keymap.del('n', 'K', { buffer = args.buf })</span>
<span class="e">      end,</span>
<span class="e">    })</span>

<span class="h">==============================================================================</span>
<span class="c">CONFIG</span>                                                  <span id="lsp-config" class="t">lsp-config</span>

You can configure <a href="lsp.txt.html#LSP" class="d">LSP</a> behavior statically via vim.lsp.config(), and
dynamically via <a href="lsp.txt.html#lsp-attach" class="l">lsp-attach</a> or <a href="lsp.txt.html#Client%3Aon_attach%28%29" class="l">Client:on_attach()</a><a href="repeat.txt.html#." class="d">.</a>

Use <a href="lsp.txt.html#vim.lsp.config%28%29" class="l">vim.lsp.config()</a> to define, and selectively enable, <a href="lsp.txt.html#LSP" class="d">LSP</a> configurations.
This <a href="motion.txt.html#is" class="d">is</a> basically <a href="insert.txt.html#a" class="d">a</a> wrapper around <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a> which allows you to share
and <a href="diff.txt.html#merge" class="d">merge</a> configs (which may be provided by Nvim or third-party plugins).

When an <a href="lsp.txt.html#LSP" class="d">LSP</a> client starts, <a href="motion.txt.html#it" class="d">it</a> resolves its configuration by merging from the
following (in increasing priority):

1. Configuration defined <a href="luaref.txt.html#for" class="d">for</a> the <span class="e">'*'</span> name.
2. Configuration from the result of merging all tables returned by
   <span class="e">lsp/&lt;config&gt;.lua</span> files in <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="starting.txt.html#config" class="d">config</a> named <span class="e">&lt;config&gt;</span>.
3. Configurations defined anywhere else.

<span class="n">Note:</span> The <a href="diff.txt.html#merge" class="d">merge</a> semantics of configurations follow the behaviour of
<a href="lua.txt.html#vim.tbl_deep_extend%28%29" class="l">vim.tbl_deep_extend()</a><a href="repeat.txt.html#." class="d">.</a>

Example: given the following configs... 
<span class="e">  -- Defined in init.lua</span>
<span class="e">  vim.lsp.config('*', {</span>
<span class="e">    capabilities = {</span>
<span class="e">      textDocument = {</span>
<span class="e">        semanticTokens = {</span>
<span class="e">          multilineTokenSupport = true,</span>
<span class="e">        }</span>
<span class="e">      }</span>
<span class="e">    },</span>
<span class="e">    root_markers = { '.git' },</span>
<span class="e">  })</span>
<span class="e"></span>
<span class="e">  -- Defined in &lt;rtp&gt;/lsp/clangd.lua</span>
<span class="e">  return {</span>
<span class="e">    cmd = { 'clangd' },</span>
<span class="e">    root_markers = { '.clangd', 'compile_commands.json' },</span>
<span class="e">    filetypes = { 'c', 'cpp' },</span>
<span class="e">  }</span>
<span class="e"></span>
<span class="e">  -- Defined in init.lua</span>
<span class="e">  vim.lsp.config('clangd', {</span>
<span class="e">    filetypes = { 'c' },</span>
<span class="e">  })</span>

...the merged result is: 
<span class="e">  {</span>
<span class="e">    -- From the clangd configuration in &lt;rtp&gt;/lsp/clangd.lua</span>
<span class="e">    cmd = { 'clangd' },</span>
<span class="e"></span>
<span class="e">    -- From the clangd configuration in &lt;rtp&gt;/lsp/clangd.lua</span>
<span class="e">    -- Overrides the "*" configuration in init.lua</span>
<span class="e">    root_markers = { '.clangd', 'compile_commands.json' },</span>
<span class="e"></span>
<span class="e">    -- From the clangd configuration in init.lua</span>
<span class="e">    -- Overrides the clangd configuration in &lt;rtp&gt;/lsp/clangd.lua</span>
<span class="e">    filetypes = { 'c' },</span>
<span class="e"></span>
<span class="e">    -- From the "*" configuration in init.lua</span>
<span class="e">    capabilities = {</span>
<span class="e">      textDocument = {</span>
<span class="e">        semanticTokens = {</span>
<span class="e">          multilineTokenSupport = true,</span>
<span class="e">        }</span>
<span class="e">      }</span>
<span class="e">    }</span>
<span class="e">  }</span>

                                                        <span id="lsp-attach" class="t">lsp-attach</span>
To use <a href="lsp.txt.html#LSP" class="d">LSP</a> features beyond those provided by Nvim (see <a href="lsp.txt.html#lsp-buf" class="l">lsp-buf</a>), you can set
keymaps and <a href="options.txt.html#options" class="d">options</a> on <a href="lsp.txt.html#Client%3Aon_attach%28%29" class="l">Client:on_attach()</a> or <a href="lsp.txt.html#LspAttach" class="l">LspAttach</a><a href="repeat.txt.html#." class="d">.</a> Not all language
servers provide the same capabilities; check <span class="e">supports_method()</span> in your
<a href="lsp.txt.html#LspAttach" class="d">LspAttach</a> handler.
                                                        <span id="lsp-lint" class="t">lsp-lint</span> <span id="lsp-format" class="t">lsp-format</span>
Example: Enable auto-completion and auto-formatting <a href="motion.txt.html#%28" class="d">(</a>"linting"): 
<span class="e"></span>
<span class="e">    vim.api.nvim_create_autocmd('LspAttach', {</span>
<span class="e">      group = vim.api.nvim_create_augroup('my.lsp', {}),</span>
<span class="e">      callback = function(args)</span>
<span class="e">        local client = assert(vim.lsp.get_client_by_id(args.data.client_id))</span>
<span class="e">        if client:supports_method('textDocument/implementation') then</span>
<span class="e">          -- Create a keymap for vim.lsp.buf.implementation ...</span>
<span class="e">        end</span>
<span class="e"></span>
<span class="e">        -- Enable auto-completion. Note: Use CTRL-Y to select an item. |complete_CTRL-Y|</span>
<span class="e">        if client:supports_method('textDocument/completion') then</span>
<span class="e">          -- Optional: trigger autocompletion on EVERY keypress. May be slow!</span>
<span class="e">          -- local chars = {}; for i = 32, 126 do table.insert(chars, string.char(i)) end</span>
<span class="e">          -- client.server_capabilities.completionProvider.triggerCharacters = chars</span>
<span class="e"></span>
<span class="e">          vim.lsp.completion.enable(true, client.id, args.buf, {autotrigger = true})</span>
<span class="e">        end</span>
<span class="e"></span>
<span class="e">        -- Auto-format ("lint") on save.</span>
<span class="e">        -- Usually not needed if server supports "textDocument/willSaveWaitUntil".</span>
<span class="e">        if not client:supports_method('textDocument/willSaveWaitUntil')</span>
<span class="e">            and client:supports_method('textDocument/formatting') then</span>
<span class="e">          vim.api.nvim_create_autocmd('BufWritePre', {</span>
<span class="e">            group = vim.api.nvim_create_augroup('my.lsp', {clear=false}),</span>
<span class="e">            buffer = args.buf,</span>
<span class="e">            callback = function()</span>
<span class="e">              vim.lsp.buf.format({ bufnr = args.buf, id = client.id, timeout_ms = 1000 })</span>
<span class="e">            end,</span>
<span class="e">          })</span>
<span class="e">        end</span>
<span class="e">      end,</span>
<span class="e">    })</span>

To see the capabilities <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> given server, try this in <a href="insert.txt.html#a" class="d">a</a> LSP-enabled buffer: 
<span class="e"></span>
<span class="e">    :lua =vim.lsp.get_clients()[1].server_capabilities</span>
<span class="e"></span>
<span class="h">================================================================================</span>
<span class="c">FAQ</span>                                                     <span id="lsp-faq" class="t">lsp-faq</span>

<a href="motion.txt.html#-" class="d">-</a> Q: How to force-reload LSP?
<a href="motion.txt.html#-" class="d">-</a> A: Stop all clients, then <a href="editing.txt.html#reload" class="d">reload</a> the buffer. 
<span class="e">     :lua vim.lsp.stop_client(vim.lsp.get_clients())</span>
<span class="e">     :edit</span>
<span class="e"></span>
<a href="motion.txt.html#-" class="d">-</a> Q: Why isn't completion working?
<a href="motion.txt.html#-" class="d">-</a> A: In the buffer where you want to use LSP, check that <a href="options.txt.html#%27omnifunc%27" class="o">'omnifunc'</a> <a href="motion.txt.html#is" class="d">is</a> set to
     "v:lua.vim.lsp.omnifunc"<a href="cmdline.txt.html#%3A" class="d">:</a> `:verbose set omnifunc?`
     <a href="motion.txt.html#-" class="d">-</a> Some other <a href="usr_05.txt.html#plugin" class="d">plugin</a> may be overriding the option. To avoid that you could
       set the option in an <a href="options.txt.html#after-directory" class="l">after-directory</a> ftplugin, e.g.
       "after/ftplugin/python.vim"<a href="repeat.txt.html#." class="d">.</a>

<a href="motion.txt.html#-" class="d">-</a> Q: How <a href="diff.txt.html#do" class="d">do</a> <a href="insert.txt.html#I" class="d">I</a> run <a href="insert.txt.html#a" class="d">a</a> request synchronously (e.g. <a href="luaref.txt.html#for" class="d">for</a> <a href="change.txt.html#formatting" class="d">formatting</a> on file save)?
<a href="motion.txt.html#-" class="d">-</a> A: Check if the function has an <span class="e">async</span> parameter and set the value to
  false. E.g. code formatting: 
<span class="e"></span>
<span class="e">     " Auto-format *.rs (rust) files prior to saving them</span>
<span class="e">     " (async = false is the default for format)</span>
<span class="e">     autocmd BufWritePre *.rs lua vim.lsp.buf.format({ async = false })</span>


<a href="motion.txt.html#-" class="d">-</a> Q: How to avoid my own lsp/ folder being overridden?
<a href="motion.txt.html#-" class="d">-</a> A: Place your configs under "after/lsp/"<a href="repeat.txt.html#." class="d">.</a> Files in "after/lsp/" are loaded
     after those in "nvim/lsp/"<a href="motion.txt.html#%2C" class="d">,</a> so your settings will take precedence over
     the <a href="vim_diff.txt.html#defaults" class="d">defaults</a> provided by nvim-lspconfig. See also: <a href="options.txt.html#after-directory" class="l">after-directory</a>

                                                        <span id="lsp-vs-treesitter" class="t">lsp-vs-treesitter</span>
<a href="motion.txt.html#-" class="d">-</a> Q: How <a href="diff.txt.html#do" class="d">do</a> LSP, Treesitter and Ctags compare?
<a href="motion.txt.html#-" class="d">-</a> A: <a href="lsp.txt.html#LSP" class="d">LSP</a> requires <a href="insert.txt.html#a" class="d">a</a> client and language server. The language server uses
     semantic analysis to understand code <a href="motion.txt.html#at" class="d">at</a> <a href="insert.txt.html#a" class="d">a</a> project level. This provides
     language servers with the ability to rename across files, find
     <a href="intro.txt.html#definitions" class="d">definitions</a> in external libraries and more.

     <a href="treesitter.txt.html#treesitter" class="l">treesitter</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> language parsing library that provides excellent tools
     <a href="luaref.txt.html#for" class="d">for</a> incrementally parsing text and handling errors. This makes <a href="motion.txt.html#it" class="d">it</a> <a href="insert.txt.html#a" class="d">a</a> great
     fit <a href="luaref.txt.html#for" class="d">for</a> editors to understand the contents of the current file <a href="luaref.txt.html#for" class="d">for</a> things
     like <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighting, simple goto-definitions, scope analysis and
     more.

     <a href="insert.txt.html#A" class="d">A</a> <a href="tagsrch.txt.html#ctags" class="l">ctags</a>-like program can generate <a href="insert.txt.html#a" class="d">a</a> <a href="tagsrch.txt.html#tags" class="l">tags</a> file that allows Nvim to
     jump to definitions, provide simple completions via <a href="insert.txt.html#i_CTRL-X_CTRL-%5D" class="l">i_CTRL-X_CTRL-]</a>
     command. It <a href="motion.txt.html#is" class="d">is</a> not <a href="motion.txt.html#as" class="d">as</a> featureful and doesn't have semantic understanding,
     but <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> fast, lightweight and useful <a href="luaref.txt.html#for" class="d">for</a> navigating polyglot projects.

<span class="h">================================================================================</span>
<span class="c">LSP API</span>                                                 <span id="lsp-api" class="t">lsp-api</span>

The <a href="lsp.txt.html#lsp-core" class="l">lsp-core</a> <a href="api.txt.html#API" class="d">API</a> provides core <a href="vimeval.txt.html#functions" class="d">functions</a> <a href="luaref.txt.html#for" class="d">for</a> creating and managing clients.
The <a href="lsp.txt.html#lsp-buf" class="l">lsp-buf</a> <a href="vimeval.txt.html#functions" class="d">functions</a> perform operations <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> clients attached to the
current buffer.

                                                                  <span id="lsp-method" class="t">lsp-method</span>
Requests and notifications defined by the <a href="lsp.txt.html#LSP" class="d">LSP</a> specification are referred to <a href="motion.txt.html#as" class="d">as</a>
"<a href="lsp.txt.html#LSP" class="d">LSP</a> methods"<a href="repeat.txt.html#." class="d">.</a> These are handled by <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> functions.

The <a href="lsp.txt.html#vim.lsp.handlers" class="l">vim.lsp.handlers</a> global table defines default handlers (only <a href="luaref.txt.html#for" class="d">for</a>
server-to-client requests/notifications, not client-to-server). <span class="n">Note:</span> depends
on server support; they won't run if your server doesn't <a href="support.txt.html#support" class="d">support</a> them.

You can <a href="vimeval.txt.html#list" class="d">list</a> them with: 
<span class="e"></span>
<span class="e">    :lua vim.print(vim.tbl_keys(vim.lsp.handlers))</span>

They are also listed below.

<a href="motion.txt.html#-" class="d">-</a> <span class="e">'callHierarchy/incomingCalls'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'callHierarchy/outgoingCalls'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'client/registerCapability'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'client/unregisterCapability'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'signature_help'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/codeLens'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/completion'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/diagnostic'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/documentHighlight'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/documentSymbol'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/formatting'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/hover'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/inlayHint'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/publishDiagnostics'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/rangeFormatting'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/rename'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'textDocument/signatureHelp'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'typeHierarchy/subtypes'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'typeHierarchy/supertypes'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'window/logMessage'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'window/showDocument'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'window/showMessage'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'window/showMessageRequest'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'window/workDoneProgress/create'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/applyEdit'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/configuration'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/executeCommand'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/inlayHint/refresh'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/semanticTokens/refresh'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/symbol'</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">'workspace/workspaceFolders'</span>

                                                                 <span id="lsp-handler" class="t">lsp-handler</span>
<a href="lsp.txt.html#LSP" class="d">LSP</a> handlers are <a href="vimeval.txt.html#functions" class="d">functions</a> that handle <a href="lsp.txt.html#lsp-response" class="l">lsp-response</a><a href="change.txt.html#s" class="d">s</a> to requests made by Nvim
to the server. (Notifications, <a href="motion.txt.html#as" class="d">as</a> opposed to requests, are fire-and-forget:
there <a href="motion.txt.html#is" class="d">is</a> no response, so they can't be handled. <a href="lsp.txt.html#lsp-notification" class="l">lsp-notification</a><a href="motion.txt.html#%29" class="d">)</a>

Each response handler has this signature: 
<span class="e"></span>
<span class="e">    function(err, result, ctx)</span>

<span class="h">    Parameters: </span>
      • <span class="s">{err}</span>     (`table|nil`) Error info dict, or <span class="e">nil</span> if the request
                  completed.
      • <span class="s">{result}</span>  (`Result<span class="l">Params</span>nil`) <span class="e">result</span> key of the <a href="lsp.txt.html#lsp-response" class="l">lsp-response</a> or
                  <span class="e">nil</span> if the request failed.
      • <span class="s">{ctx}</span>     (`table`) Table of calling state associated with the
                  handler, with these keys:
                  • <span class="s">{method}</span>     (`string`) <a href="lsp.txt.html#lsp-method" class="l">lsp-method</a> name.
                  • <span class="s">{client_id}</span>  (`number`) <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a> identifier.
                  • <span class="s">{bufnr}</span>      (`Buffer`) Buffer handle.
                  • <span class="s">{params}</span>     (`table|nil`) Request parameters table.
                  • <span class="s">{version}</span>    (`number`) Document version <a href="motion.txt.html#at" class="d">at</a> time of
                                 request. Handlers can compare this to the
                                 current document version to check if the
                                 response <a href="motion.txt.html#is" class="d">is</a> "stale"<a href="repeat.txt.html#." class="d">.</a> See also <a href="vimeval.txt.html#b%3Achangedtick" class="l">b:changedtick</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Returns: </span>
        Two values `result, err` where <span class="e">err</span> <a href="motion.txt.html#is" class="d">is</a> shaped like an <a href="api.txt.html#RPC" class="d">RPC</a> error: 
<span class="e">            { code, message, data? }</span>
        You can use <a href="lsp.txt.html#vim.lsp.rpc.rpc_response_error%28%29" class="l">vim.lsp.rpc.rpc_response_error()</a> to create this object.

                                                      <span id="lsp-handler-resolution" class="t">lsp-handler-resolution</span>
Handlers can be set by (in increasing priority):

                                                            <span id="vim.lsp.handlers" class="t">vim.lsp.handlers</span>
<a href="motion.txt.html#-" class="d">-</a> Directly calling <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> via <a href="lsp.txt.html#Client%3Arequest%28%29" class="l">Client:request()</a><a href="repeat.txt.html#." class="d">.</a> This <a href="motion.txt.html#is" class="d">is</a> the only way
  to "override" the default client-to-server request handling (by
  side-stepping <span class="e">vim.lsp.buf</span> and related interfaces). 
<span class="e">    local client = assert(vim.lsp.get_clients()[1])</span>
<span class="e">    client:request('textDocument/definition')</span>
<span class="e"></span>
<a href="motion.txt.html#-" class="d">-</a> Setting <a href="insert.txt.html#a" class="d">a</a> field in <span class="e">vim.lsp.handlers</span>. This global table contains the
  default mappings of <a href="lsp.txt.html#lsp-method" class="l">lsp-method</a> names to handlers. (Note: only <a href="luaref.txt.html#for" class="d">for</a>
  server-to-client requests/notifications, not client-to-server.)
  Example: 
<span class="e">    vim.lsp.handlers['textDocument/publishDiagnostics'] = my_custom_diagnostics_handler</span>
<span class="e"></span>
<a href="motion.txt.html#-" class="d">-</a> Passing <a href="insert.txt.html#a" class="d">a</a> <span class="s">{handlers}</span> parameter to <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a><a href="repeat.txt.html#." class="d">.</a> This sets the default
  <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific server. (Note: only <a href="luaref.txt.html#for" class="d">for</a> server-to-client
  requests/notifications, not client-to-server.)
  Example: 
<span class="e">    vim.lsp.start {</span>
<span class="e">      ..., -- Other configuration omitted.</span>
<span class="e">      handlers = {</span>
<span class="e">        ['textDocument/publishDiagnostics'] = my_custom_diagnostics_handler</span>
<span class="e">      },</span>
<span class="e">    }</span>
<span class="e"></span>
<a href="motion.txt.html#-" class="d">-</a> Passing <a href="insert.txt.html#a" class="d">a</a> <span class="s">{handler}</span> parameter to <a href="lsp.txt.html#vim.lsp.buf_request_all%28%29" class="l">vim.lsp.buf_request_all()</a><a href="repeat.txt.html#." class="d">.</a> This sets the
  <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> ONLY <a href="luaref.txt.html#for" class="d">for</a> the given request(s).
  Example: 
<span class="e">    vim.lsp.buf_request_all(</span>
<span class="e">      0,</span>
<span class="e">      'textDocument/publishDiagnostics',</span>
<span class="e">      my_request_params,</span>
<span class="e">      my_handler</span>
<span class="e">    )</span>


                                                            <span id="vim.lsp.log_levels" class="t">vim.lsp.log_levels</span>
Log levels are defined in <a href="lua.txt.html#vim.log.levels" class="l">vim.log.levels</a>


<span class="c">VIM.LSP.PROTOCOL</span>                                              <span id="vim.lsp.protocol" class="t">vim.lsp.protocol</span>

Module <span class="e">vim.lsp.protocol</span> defines constants dictated by the <a href="lsp.txt.html#LSP" class="d">LSP</a> specification,
and helper <a href="vimeval.txt.html#functions" class="d">functions</a> <a href="luaref.txt.html#for" class="d">for</a> creating protocol-related objects.
<a class="u" href="https://github.com/microsoft/language-server-protocol/raw/gh-pages/_specifications/specification-3-14.md">https://github.com/microsoft/language-server-protocol/raw/gh-pages/_specifications/specification-3-14.md</a>

For example <span class="e">vim.lsp.protocol.ErrorCodes</span> allows reverse lookup by number or
name: 
<span class="e"></span>
<span class="e">    vim.lsp.protocol.TextDocumentSyncKind.Full == 1</span>
<span class="e">    vim.lsp.protocol.TextDocumentSyncKind[1] == "Full"</span>


                                                                <span id="lsp-response" class="t">lsp-response</span>
<a href="lsp.txt.html#LSP" class="d">LSP</a> response shape:
<a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage</a>

                                                                <span id="lsp-notification" class="t">lsp-notification</span>
<a href="lsp.txt.html#LSP" class="d">LSP</a> notification shape:
<a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage</a>

<span class="h">================================================================================</span>
<span class="c">LSP HIGHLIGHT</span>                                                    <span id="lsp-highlight" class="t">lsp-highlight</span>

Reference Highlights:

Highlight groups that are meant to be used by <a href="lsp.txt.html#vim.lsp.buf.document_highlight%28%29" class="l">vim.lsp.buf.document_highlight()</a><a href="repeat.txt.html#." class="d">.</a>

You can see more about the differences in types here:
<a class="u" href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight">https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight</a>

                                                         <span id="hl-LspReferenceText" class="t">hl-LspReferenceText</span>
LspReferenceText          used <a href="luaref.txt.html#for" class="d">for</a> highlighting "text" references
                                                         <span id="hl-LspReferenceRead" class="t">hl-LspReferenceRead</span>
LspReferenceRead          used <a href="luaref.txt.html#for" class="d">for</a> highlighting "read" references
                                                        <span id="hl-LspReferenceWrite" class="t">hl-LspReferenceWrite</span>
LspReferenceWrite         used <a href="luaref.txt.html#for" class="d">for</a> highlighting "write" references
                                                       <span id="hl-LspReferenceTarget" class="t">hl-LspReferenceTarget</span>
LspReferenceTarget        used <a href="luaref.txt.html#for" class="d">for</a> highlighting <a href="intro.txt.html#reference" class="d">reference</a> targets (e.g. in <a href="insert.txt.html#a" class="d">a</a>
                          hover range)
                                                             <span id="hl-LspInlayHint" class="t">hl-LspInlayHint</span>
LspInlayHint              used <a href="luaref.txt.html#for" class="d">for</a> highlighting inlay hints


                                                      <span id="lsp-highlight-codelens" class="t">lsp-highlight-codelens</span>

Highlight groups related to <a href="lsp.txt.html#lsp-codelens" class="l">lsp-codelens</a> functionality.

                                                              <span id="hl-LspCodeLens" class="t">hl-LspCodeLens</span>
LspCodeLens
    Used to color the virtual text of the codelens. See
    <a href="api.txt.html#nvim_buf_set_extmark%28%29" class="l">nvim_buf_set_extmark()</a><a href="repeat.txt.html#." class="d">.</a>

LspCodeLensSeparator                                 <span id="hl-LspCodeLensSeparator" class="t">hl-LspCodeLensSeparator</span>
    Used to color the separator between two or more code lenses.

                                                     <span id="lsp-highlight-signature" class="t">lsp-highlight-signature</span>

Highlight groups related to <a href="deprecated.txt.html#vim.lsp.handlers.signature_help%28%29" class="l">vim.lsp.handlers.signature_help()</a><a href="repeat.txt.html#." class="d">.</a>

                                              <span id="hl-LspSignatureActiveParameter" class="t">hl-LspSignatureActiveParameter</span>
LspSignatureActiveParameter
    Used to highlight the active parameter in the signature help. See
    <a href="deprecated.txt.html#vim.lsp.handlers.signature_help%28%29" class="l">vim.lsp.handlers.signature_help()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">------------------------------------------------------------------------------</span>
<span class="c">LSP SEMANTIC HIGHLIGHTS</span>                               <span id="lsp-semantic-highlight" class="t">lsp-semantic-highlight</span>

When available, the <a href="lsp.txt.html#LSP" class="d">LSP</a> client highlights code using <a href="lsp.txt.html#lsp-semantic_tokens" class="l">lsp-semantic_tokens</a><a href="motion.txt.html#%2C" class="d">,</a>
which are another way that <a href="lsp.txt.html#LSP" class="d">LSP</a> servers can provide information about source
code.  <span class="n">Note</span> that this <a href="motion.txt.html#is" class="d">is</a> in addition to <a href="treesitter.txt.html#treesitter" class="d">treesitter</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighting;
semantic highlighting does not replace <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighting.

The server will typically provide one token per identifier in the source code.
The token will have <a href="insert.txt.html#a" class="d">a</a> <span class="e">type</span> such <a href="motion.txt.html#as" class="d">as</a> "function" or "variable"<a href="motion.txt.html#%2C" class="d">,</a> and <a href="motion.txt.html#0" class="d">0</a> or more
<span class="e">modifier</span>s such <a href="motion.txt.html#as" class="d">as</a> "readonly" or "deprecated." The standard types and
modifiers are described here:
<a class="u" href="https://microsoft.github.io/language-server-protocol/specification/#textDocument_semanticTokens">https://microsoft.github.io/language-server-protocol/specification/#textDocument_semanticTokens</a>
<a href="lsp.txt.html#LSP" class="d">LSP</a> servers may also use off-spec types and modifiers.

The <a href="lsp.txt.html#LSP" class="d">LSP</a> client adds one or more highlights <a href="luaref.txt.html#for" class="d">for</a> each token. The highlight
groups are derived from the token's type and modifiers:
  • <span class="e">@lsp.type.&lt;type&gt;.&lt;ft&gt;</span> <a href="luaref.txt.html#for" class="d">for</a> the type
  • <span class="e">@lsp.mod.&lt;mod&gt;.&lt;ft&gt;</span> <a href="luaref.txt.html#for" class="d">for</a> each modifier
  • <span class="e">@lsp.typemod.&lt;type&gt;.&lt;mod&gt;.&lt;ft&gt;</span> <a href="luaref.txt.html#for" class="d">for</a> each modifier
Use <a href="lua.txt.html#%3AInspect" class="l">:Inspect</a> to view the highlights <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific token. Use <a href="syntax.txt.html#%3Ahi" class="l">:hi</a> or
<a href="api.txt.html#nvim_set_hl%28%29" class="l">nvim_set_hl()</a> to change the appearance of semantic highlights: 
<span class="e"></span>
<span class="e">    hi @lsp.type.function guifg=Yellow        " function names are yellow</span>
<span class="e">    hi @lsp.type.variable.lua guifg=Green     " variables in lua are green</span>
<span class="e">    hi @lsp.mod.deprecated gui=strikethrough  " deprecated is crossed out</span>
<span class="e">    hi @lsp.typemod.function.async guifg=Blue " async functions are blue</span>

The value <a href="lua.txt.html#vim.hl.priorities" class="l">vim.hl.priorities</a><span class="e">.semantic_tokens</span> <a href="motion.txt.html#is" class="d">is</a> the priority of the
<span class="e">@lsp.type.*</span> highlights. The <span class="e">@lsp.mod.*</span> and <span class="e">@lsp.typemod.*</span> highlights
have priorities one and two higher, respectively.

You can disable semantic highlights by clearing the highlight groups: 
<span class="e"></span>
<span class="e">    -- Hide semantic highlights for functions</span>
<span class="e">    vim.api.nvim_set_hl(0, '@lsp.type.function', {})</span>
<span class="e"></span>
<span class="e">    -- Hide all semantic highlights</span>
<span class="e">    for _, group in ipairs(vim.fn.getcompletion("@lsp", "highlight")) do</span>
<span class="e">      vim.api.nvim_set_hl(0, group, {})</span>
<span class="e">    end</span>

You probably want these inside <a href="insert.txt.html#a" class="d">a</a> <a href="autocmd.txt.html#ColorScheme" class="l">ColorScheme</a> autocommand.

Use <a href="lsp.txt.html#LspTokenUpdate" class="l">LspTokenUpdate</a> and <a href="lsp.txt.html#vim.lsp.semantic_tokens.highlight_token%28%29" class="l">vim.lsp.semantic_tokens.highlight_token()</a> <a href="luaref.txt.html#for" class="d">for</a> more
complex highlighting.

The following <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of standard captures used in queries <a href="luaref.txt.html#for" class="d">for</a> Nvim,
highlighted according to the current colorscheme (use <a href="lua.txt.html#%3AInspect" class="l">:Inspect</a> on one to see
the exact definition):

@lsp.type.class          Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> class type
@lsp.type.comment        Tokens that represent <a href="insert.txt.html#a" class="d">a</a> comment
@lsp.type.decorator      Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> decorators and annotations
@lsp.type.enum           Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> an enumeration type
@lsp.type.enumMember     Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> an enumeration property, constant, or member
@lsp.type.event          Identifiers that declare an event property
@lsp.type.function       Identifiers that declare <a href="insert.txt.html#a" class="d">a</a> function
@lsp.type.interface      Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> an interface type
@lsp.type.keyword        Tokens that represent <a href="insert.txt.html#a" class="d">a</a> language keyword
@lsp.type.macro          Identifiers that declare <a href="insert.txt.html#a" class="d">a</a> <a href="repeat.txt.html#macro" class="d">macro</a>
@lsp.type.method         Identifiers that declare <a href="insert.txt.html#a" class="d">a</a> member function or <a href="vimeval.txt.html#method" class="d">method</a>
@lsp.type.modifier       Tokens that represent <a href="insert.txt.html#a" class="d">a</a> modifier
@lsp.type.namespace      Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> namespace, module, or package
@lsp.type.number         Tokens that represent <a href="insert.txt.html#a" class="d">a</a> number literal
@lsp.type.operator       Tokens that represent an <a href="motion.txt.html#operator" class="d">operator</a>
@lsp.type.parameter      Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> function or <a href="vimeval.txt.html#method" class="d">method</a> parameters
@lsp.type.property       Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> member property, member field, or member variable
@lsp.type.regexp         Tokens that represent <a href="insert.txt.html#a" class="d">a</a> regular <a href="vimeval.txt.html#expression" class="d">expression</a> literal
@lsp.type.string         Tokens that represent <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> literal
@lsp.type.struct         Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> struct type
@lsp.type.type           Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> type that <a href="motion.txt.html#is" class="d">is</a> not covered above
@lsp.type.typeParameter  Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> type parameter
@lsp.type.variable       Identifiers that declare or <a href="intro.txt.html#reference" class="d">reference</a> <a href="insert.txt.html#a" class="d">a</a> local or global variable

@lsp.mod.abstract        Types and member <a href="vimeval.txt.html#functions" class="d">functions</a> that are abstract
@lsp.mod.async           Functions that are marked async
@lsp.mod.declaration     Declarations of symbols
@lsp.mod.defaultLibrary  Symbols that are part of the standard library
@lsp.mod.definition      Definitions of symbols, <a href="luaref.txt.html#for" class="d">for</a> example, in header files
@lsp.mod.deprecated      Symbols that should no longer be used
@lsp.mod.documentation   Occurrences of symbols in documentation
@lsp.mod.modification    Variable references where the variable <a href="motion.txt.html#is" class="d">is</a> assigned to
@lsp.mod.readonly        Readonly <a href="vimeval.txt.html#variables" class="d">variables</a> and member fields (constants)
@lsp.mod.static          Class members (static members)

<span class="h">==============================================================================</span>
<span class="c">EVENTS</span>                                                            <span id="lsp-events" class="t">lsp-events</span>

<a href="lsp.txt.html#LspAttach" class="d">LspAttach</a>                                                          <span id="LspAttach" class="t">LspAttach</span>
    After an <a href="lsp.txt.html#LSP" class="d">LSP</a> client performs "initialize" and attaches to <a href="insert.txt.html#a" class="d">a</a> buffer. The
    <a href="autocmd.txt.html#autocmd-pattern" class="l">autocmd-pattern</a> <a href="motion.txt.html#is" class="d">is</a> the buffer name. The client ID <a href="motion.txt.html#is" class="d">is</a> passed in the
    <a href="lua.txt.html#Lua" class="d">Lua</a> handler <a href="api.txt.html#event-data" class="l">event-data</a> argument.

    Example: 
<span class="e">    vim.api.nvim_create_autocmd('LspAttach', {</span>
<span class="e">      callback = function(ev)</span>
<span class="e">        local client = vim.lsp.get_client_by_id(ev.data.client_id)</span>
<span class="e">        -- ...</span>
<span class="e">      end</span>
<span class="e">    })</span>

    <span class="n">Note:</span> If the <a href="lsp.txt.html#LSP" class="d">LSP</a> server performs dynamic registration, capabilities may be
    registered any time _after_ LspAttach. In that <a href="change.txt.html#case" class="d">case</a> you may want to handle
    the "registerCapability" event.

    Example: 
<span class="e">    vim.lsp.handlers['client/registerCapability'] = (function(overridden)</span>
<span class="e">      return function(err, res, ctx)</span>
<span class="e">        local result = overridden(err, res, ctx)</span>
<span class="e">        local client = vim.lsp.get_client_by_id(ctx.client_id)</span>
<span class="e">        if not client then</span>
<span class="e">          return</span>
<span class="e">        end</span>
<span class="e">        for bufnr, _ in pairs(client.attached_buffers) do</span>
<span class="e">          -- Call your custom on_attach logic...</span>
<span class="e">          -- my_on_attach(client, bufnr)</span>
<span class="e">        end</span>
<span class="e">        return result</span>
<span class="e">      end</span>
<span class="e">    end)(vim.lsp.handlers['client/registerCapability'])</span>
<span class="e"></span>
<a href="lsp.txt.html#LspDetach" class="d">LspDetach</a>                                                          <span id="LspDetach" class="t">LspDetach</span>
    Just before an <a href="lsp.txt.html#LSP" class="d">LSP</a> client detaches from <a href="insert.txt.html#a" class="d">a</a> buffer. The <a href="autocmd.txt.html#autocmd-pattern" class="l">autocmd-pattern</a> <a href="motion.txt.html#is" class="d">is</a>
    the buffer name. The client ID <a href="motion.txt.html#is" class="d">is</a> passed in the <a href="lua.txt.html#Lua" class="d">Lua</a> handler <a href="api.txt.html#event-data" class="l">event-data</a>
    argument.

    Example: 
<span class="e">    vim.api.nvim_create_autocmd('LspDetach', {</span>
<span class="e">      callback = function(args)</span>
<span class="e">        -- Get the detaching client</span>
<span class="e">        local client = vim.lsp.get_client_by_id(args.data.client_id)</span>
<span class="e"></span>
<span class="e">        -- Remove the autocommand to format the buffer on save, if it exists</span>
<span class="e">        if client:supports_method('textDocument/formatting') then</span>
<span class="e">          vim.api.nvim_clear_autocmds({</span>
<span class="e">            event = 'BufWritePre',</span>
<span class="e">            buffer = args.buf,</span>
<span class="e">          })</span>
<span class="e">        end</span>
<span class="e">      end,</span>
<span class="e">    })</span>


<a href="lsp.txt.html#LspNotify" class="d">LspNotify</a>                                                          <span id="LspNotify" class="t">LspNotify</span>
    This event <a href="motion.txt.html#is" class="d">is</a> triggered after each successful notification sent to an
    <a href="lsp.txt.html#LSP" class="d">LSP</a> server.

    The client_id, <a href="lsp.txt.html#LSP" class="d">LSP</a> method, and parameters are sent in the <a href="lua.txt.html#Lua" class="d">Lua</a> handler
    <a href="api.txt.html#event-data" class="l">event-data</a> table argument.

    Example: 
<span class="e">    vim.api.nvim_create_autocmd('LspNotify', {</span>
<span class="e">      callback = function(args)</span>
<span class="e">        local bufnr = args.buf</span>
<span class="e">        local client_id = args.data.client_id</span>
<span class="e">        local method = args.data.method</span>
<span class="e">        local params = args.data.params</span>
<span class="e"></span>
<span class="e">        -- do something with the notification</span>
<span class="e">        if method == 'textDocument/...' then</span>
<span class="e">          update_buffer(bufnr)</span>
<span class="e">        end</span>
<span class="e">      end,</span>
<span class="e">    })</span>


<a href="lsp.txt.html#LspProgress" class="d">LspProgress</a>                                                       <span id="LspProgress" class="t">LspProgress</span>
    Upon receipt of <a href="insert.txt.html#a" class="d">a</a> progress notification from the server. Notifications can
    be polled from <a href="insert.txt.html#a" class="d">a</a> <span class="e">progress</span> ring buffer of <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a> or use
    <a href="lsp.txt.html#vim.lsp.status%28%29" class="l">vim.lsp.status()</a> to get an aggregate message.

    If the server sends <a href="insert.txt.html#a" class="d">a</a> "work done progress"<a href="motion.txt.html#%2C" class="d">,</a> the <span class="e">pattern</span> <a href="motion.txt.html#is" class="d">is</a> set to <span class="e">kind</span>
    (one of <span class="e">begin</span>, <span class="e">report</span> or <span class="e">end</span>).

    The <a href="lua.txt.html#Lua" class="d">Lua</a> handler <a href="api.txt.html#event-data" class="l">event-data</a> argument has <span class="e">client_id</span> and <span class="e">params</span>
    properties, where <span class="e">params</span> <a href="motion.txt.html#is" class="d">is</a> the request params sent by the server (see
    <span class="e">lsp.ProgressParams</span>).

    Example: 
<span class="e">        autocmd LspProgress * redrawstatus</span>


<a href="lsp.txt.html#LspRequest" class="d">LspRequest</a>                                                        <span id="LspRequest" class="t">LspRequest</span>
    For each request sent to an <a href="lsp.txt.html#LSP" class="d">LSP</a> server, this event <a href="motion.txt.html#is" class="d">is</a> triggered <a href="luaref.txt.html#for" class="d">for</a>
    every change to the request's status. The status can be one of
    <span class="e">pending</span>, <span class="e">complete</span>, or <span class="e">cancel</span> and <a href="motion.txt.html#is" class="d">is</a> sent <a href="motion.txt.html#as" class="d">as</a> the <span class="s">{type}</span> on the
    "data" table passed to the callback function.

    It triggers when the initial request <a href="motion.txt.html#is" class="d">is</a> sent ({type} <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="e">pending</span>) and
    when the <a href="lsp.txt.html#LSP" class="d">LSP</a> server responds ({type} <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="e">complete</span>). If <a href="insert.txt.html#a" class="d">a</a> cancellation
    <a href="motion.txt.html#is" class="d">is</a> requested using <span class="e">client.cancel_request(request_id)</span>, then this event
    will trigger with <span class="s">{type}</span> <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="e">cancel</span>.

    The <a href="lua.txt.html#Lua" class="d">Lua</a> handler <a href="api.txt.html#event-data" class="l">event-data</a> argument has the client ID, request ID, and
    request (described <a href="motion.txt.html#at" class="d">at</a> <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a><a href="motion.txt.html#%2C" class="d">,</a> <span class="s">{requests}</span> field). If the request
    type <a href="motion.txt.html#is" class="d">is</a> <span class="e">complete</span>, the request will be deleted from the client's pending
    requests table after processing the event handlers.

    Example: 
<span class="e">    vim.api.nvim_create_autocmd('LspRequest', {</span>
<span class="e">      callback = function(args)</span>
<span class="e">        local bufnr = args.buf</span>
<span class="e">        local client_id = args.data.client_id</span>
<span class="e">        local request_id = args.data.request_id</span>
<span class="e">        local request = args.data.request</span>
<span class="e">        if request.type == 'pending' then</span>
<span class="e">          -- do something with pending requests</span>
<span class="e">          track_pending(client_id, bufnr, request_id, request)</span>
<span class="e">        elseif request.type == 'cancel' then</span>
<span class="e">          -- do something with pending cancel requests</span>
<span class="e">          track_canceling(client_id, bufnr, request_id, request)</span>
<span class="e">        elseif request.type == 'complete' then</span>
<span class="e">          -- do something with finished requests. this pending</span>
<span class="e">          -- request entry is about to be removed since it is complete</span>
<span class="e">          track_finish(client_id, bufnr, request_id, request)</span>
<span class="e">        end</span>
<span class="e">      end,</span>
<span class="e">    })</span>


<a href="lsp.txt.html#LspTokenUpdate" class="d">LspTokenUpdate</a>                                                <span id="LspTokenUpdate" class="t">LspTokenUpdate</span>
    When <a href="insert.txt.html#a" class="d">a</a> visible semantic token <a href="motion.txt.html#is" class="d">is</a> sent or updated by the <a href="lsp.txt.html#LSP" class="d">LSP</a> server, or
    when an existing token becomes visible <a href="luaref.txt.html#for" class="d">for</a> the first time. The
    <a href="autocmd.txt.html#autocmd-pattern" class="l">autocmd-pattern</a> <a href="motion.txt.html#is" class="d">is</a> the buffer name. The <a href="lua.txt.html#Lua" class="d">Lua</a> handler <a href="api.txt.html#event-data" class="l">event-data</a>
    argument has the client ID and token (see
    <a href="lsp.txt.html#vim.lsp.semantic_tokens.get_at_pos%28%29" class="l">vim.lsp.semantic_tokens.get_at_pos()</a>).

    Example: 
<span class="e">    vim.api.nvim_create_autocmd('LspTokenUpdate', {</span>
<span class="e">      callback = function(args)</span>
<span class="e">        local token = args.data.token</span>
<span class="e">        if token.type == 'variable' and not token.modifiers.readonly then</span>
<span class="e">          vim.lsp.semantic_tokens.highlight_token(</span>
<span class="e">            token, args.buf, args.data.client_id, 'MyMutableVariableHighlight'</span>
<span class="e">          )</span>
<span class="e">        end</span>
<span class="e">      end,</span>
<span class="e">    })</span>

    <span class="n">Note:</span> doing anything other than calling
    <a href="lsp.txt.html#vim.lsp.semantic_tokens.highlight_token%28%29" class="l">vim.lsp.semantic_tokens.highlight_token()</a> <a href="motion.txt.html#is" class="d">is</a> considered experimental.

<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp                                                 <span id="lsp-core" class="t">lsp-core</span>

<span id="vim.lsp.Config" class="t">vim.lsp.Config</span>
    Extends: <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a>


<span class="h">    Fields: </span>
      • <span class="s">{cmd}</span>?           (`string[]|fun(dispatchers: vim.lsp.rpc.Dispatchers, config: vim.lsp.ClientConfig): vim.lsp.rpc.PublicClient`)
                         See <span class="e">cmd</span> in <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a> See also
                         <span class="e">reuse_client</span> to dynamically decide (per-buffer)
                         when <span class="e">cmd</span> should be re-invoked.
      • <span class="s">{filetypes}</span>?     (`string[]`) Filetypes the client will attach to, if
                         activated by <span class="e">vim.lsp.enable()</span>. If not provided, the
                         client will attach to all filetypes.
      • <span class="s">{reuse_client}</span>?  (`fun(client: vim.lsp.Client, config: vim.lsp.ClientConfig): boolean`)
                         Predicate which decides if <a href="insert.txt.html#a" class="d">a</a> client should be
                         re-used. Used on all running clients. The default
                         implementation re-uses <a href="insert.txt.html#a" class="d">a</a> client if name and root_dir
                         matches.
      • <span class="s">{root_dir}</span>?      (`string|fun(bufnr: integer, on_dir:fun(root_dir?:string))`)
                         <span id="lsp-root_dir%28%29" class="t">lsp-root_dir()</span> Decides the workspace root: the
                         directory where the <a href="lsp.txt.html#LSP" class="d">LSP</a> server will base its
                         workspaceFolders, rootUri, and rootPath on
                         initialization. The function form must call the
                         <span class="e">on_dir</span> callback to provide the root dir, or <a href="lsp.txt.html#LSP" class="d">LSP</a>
                         will not be activated <a href="luaref.txt.html#for" class="d">for</a> the buffer. Thus <a href="insert.txt.html#a" class="d">a</a>
                         <span class="e">root_dir()</span> function can dynamically decide
                         per-buffer whether to activate (or skip) LSP. See
                         example <a href="motion.txt.html#at" class="d">at</a> <a href="lsp.txt.html#vim.lsp.enable%28%29" class="l">vim.lsp.enable()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{root_markers}</span>?  (`(string|string[])[]`)                                    <span id="lsp-root_markers" class="t">lsp-root_markers</span>
                         Filename(s) <a href="motion.txt.html#%28" class="d">(</a>".git/"<a href="motion.txt.html#%2C" class="d">,</a> "package.json"<a href="motion.txt.html#%2C" class="d">,</a> …<a href="motion.txt.html#%29" class="d">)</a> used to
                         decide the workspace root. Unused if <span class="e">root_dir</span> <a href="motion.txt.html#is" class="d">is</a>
                         defined. The <a href="vimeval.txt.html#list" class="d">list</a> order decides priority. To indicate
                         "equal priority"<a href="motion.txt.html#%2C" class="d">,</a> specify names in <a href="insert.txt.html#a" class="d">a</a> nested <a href="vimeval.txt.html#list" class="d">list</a>
                         <a href="motion.txt.html#%60%7B" class="d">`{</a> <span class="s">{ 'a.txt', 'b.lua' }</span>, <a href="userfunc.txt.html#..." class="d">...</a> }`.

                         For each item, Nvim will search upwards (from the
                         buffer file) <a href="luaref.txt.html#for" class="d">for</a> that marker, or <a href="vimeval.txt.html#list" class="d">list</a> of markers;
                         search stops <a href="motion.txt.html#at" class="d">at</a> the first directory containing that
                         marker, and the directory <a href="motion.txt.html#is" class="d">is</a> used <a href="motion.txt.html#as" class="d">as</a> the root dir
                         (workspace folder).

                         Example: Find the first ancestor directory containing
                         file or directory "stylua.toml"<a href="motion.txt.html#%3B" class="d">;</a> if not found, find
                         the first ancestor containing ".git"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">                               root_markers = { 'stylua.toml', '.git' }</span>


                         Example: Find the first ancestor directory containing
                         EITHER "stylua.toml" or ".luarc.json"<a href="motion.txt.html#%3B" class="d">;</a> if not found,
                         find the first ancestor containing ".git"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">                               root_markers = { { 'stylua.toml', '.luarc.json' }, '.git' }</span>



buf_attach_client({bufnr}, <span class="s">{client_id}</span>)          <span id="vim.lsp.buf_attach_client%28%29" class="t">vim.lsp.buf_attach_client()</span>
    Implements the <span class="e">textDocument/did…</span> notifications required to track <a href="insert.txt.html#a" class="d">a</a>
    buffer <a href="luaref.txt.html#for" class="d">for</a> any language server.

    Without calling this, the server won't be notified of changes to <a href="insert.txt.html#a" class="d">a</a> buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>      (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current
      • <span class="s">{client_id}</span>  (`integer`) Client id

<span class="h">    Return: </span>
        (`boolean`) success <span class="e">true</span> if client was attached successfully;
        <span class="e">false</span> otherwise

buf_detach_client({bufnr}, <span class="s">{client_id}</span>)          <span id="vim.lsp.buf_detach_client%28%29" class="t">vim.lsp.buf_detach_client()</span>
    Detaches client from the specified buffer. <span class="n">Note:</span> While the server <a href="motion.txt.html#is" class="d">is</a>
    notified that the text document (buffer) was closed, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> still able to
    send notifications should <a href="motion.txt.html#it" class="d">it</a> ignore this notification.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>      (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current
      • <span class="s">{client_id}</span>  (`integer`) Client id

buf_is_attached({bufnr}, <span class="s">{client_id}</span>)              <span id="vim.lsp.buf_is_attached%28%29" class="t">vim.lsp.buf_is_attached()</span>
    Checks if <a href="insert.txt.html#a" class="d">a</a> buffer <a href="motion.txt.html#is" class="d">is</a> attached <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> particular client.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>      (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current
      • <span class="s">{client_id}</span>  (`integer`) the client id

buf_notify({bufnr}, <span class="s">{method}</span>, <span class="s">{params}</span>)                 <span id="vim.lsp.buf_notify%28%29" class="t">vim.lsp.buf_notify()</span>
    Send <a href="insert.txt.html#a" class="d">a</a> notification to <a href="insert.txt.html#a" class="d">a</a> server

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>   (`integer?`) The number of the buffer
      • <span class="s">{method}</span>  (`string`) Name of the request <a href="vimeval.txt.html#method" class="d">method</a>
      • <span class="s">{params}</span>  (`any`) Arguments to send to the server

<span class="h">    Return: </span>
        (`boolean`) success true if any client returns true; false otherwise

                                                   <span id="vim.lsp.buf_request_all%28%29" class="t">vim.lsp.buf_request_all()</span>
buf_request_all({bufnr}, <span class="s">{method}</span>, <span class="s">{params}</span>, <span class="s">{handler}</span>)
    Sends an async request <a href="luaref.txt.html#for" class="d">for</a> all active clients attached to the buffer and
    executes the <span class="e">handler</span> callback with the combined result.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>    (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current.
      • <span class="s">{method}</span>   (`string`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> name
      • <span class="s">{params}</span>   (`table|(fun(client: vim.lsp.Client, bufnr: integer): table?)?`)
                   Parameters to send to the server. Can also be passed <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a>
                   function that returns the params table <a href="luaref.txt.html#for" class="d">for</a> cases where
                   parameters are specific to the client.
      • <span class="s">{handler}</span>  (`function`) Handler called after all requests are
                   completed. Server results are passed <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a>
                   <span class="e">client_id:result</span> map.

<span class="h">    Return: </span>
        (`function`) cancel Function that cancels all requests.

                                                  <span id="vim.lsp.buf_request_sync%28%29" class="t">vim.lsp.buf_request_sync()</span>
buf_request_sync({bufnr}, <span class="s">{method}</span>, <span class="s">{params}</span>, <span class="s">{timeout_ms}</span>)
    Sends <a href="insert.txt.html#a" class="d">a</a> request to all server and waits <a href="luaref.txt.html#for" class="d">for</a> the response of all of them.

    Calls <a href="lsp.txt.html#vim.lsp.buf_request_all%28%29" class="l">vim.lsp.buf_request_all()</a> but blocks Nvim while awaiting the
    result. Parameters are the same <a href="motion.txt.html#as" class="d">as</a> <a href="lsp.txt.html#vim.lsp.buf_request_all%28%29" class="l">vim.lsp.buf_request_all()</a> but the
    result <a href="motion.txt.html#is" class="d">is</a> different. Waits <a href="insert.txt.html#a" class="d">a</a> maximum of <span class="s">{timeout_ms}</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>       (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current.
      • <span class="s">{method}</span>      (`string`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> name
      • <span class="s">{params}</span>      (`table?`) Parameters to send to the server
      • <span class="s">{timeout_ms}</span>  (`integer?`, default: <span class="e">1000</span>) Maximum time in
                      milliseconds to wait <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> result.

<span class="h">    Return (multiple): </span>
        (`table&lt;integer, <span class="s">{error: lsp.ResponseError?, result: any}</span>&gt;?`) result
        Map of client_id:request_result.
        (`string?`) err On timeout, cancel, or error, <span class="e">err</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a>
        describing the failure reason, and <span class="e">result</span> <a href="motion.txt.html#is" class="d">is</a> nil.

client_is_stopped({client_id})                   <span id="vim.lsp.client_is_stopped%28%29" class="t">vim.lsp.client_is_stopped()</span>
    Checks whether <a href="insert.txt.html#a" class="d">a</a> client <a href="motion.txt.html#is" class="d">is</a> stopped.

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer`)

<span class="h">    Return: </span>
        (`boolean`) stopped true if client <a href="motion.txt.html#is" class="d">is</a> stopped, false otherwise.

commands                                                    <span id="vim.lsp.commands" class="t">vim.lsp.commands</span>
    Registry <a href="luaref.txt.html#for" class="d">for</a> client side commands. This <a href="motion.txt.html#is" class="d">is</a> an extension point <a href="luaref.txt.html#for" class="d">for</a> plugins
    to handle custom commands which are not part of the core language server
    protocol specification.

    The registry <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> table where the key <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> unique command name, and the
    value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function which <a href="motion.txt.html#is" class="d">is</a> called if any <a href="lsp.txt.html#LSP" class="d">LSP</a> action (code action, code
    lenses, ...) triggers the command.

    If an <a href="lsp.txt.html#LSP" class="d">LSP</a> response contains <a href="insert.txt.html#a" class="d">a</a> command <a href="luaref.txt.html#for" class="d">for</a> which no matching entry <a href="motion.txt.html#is" class="d">is</a>
    available in this registry, the command will be executed via the <a href="lsp.txt.html#LSP" class="d">LSP</a>
    server using <span class="e">workspace/executeCommand</span>.

    The first argument to the function will be the <span class="e">Command</span>: Command title:
    <a href="vimeval.txt.html#String" class="d">String</a> command: <a href="vimeval.txt.html#String" class="d">String</a> arguments?: any[]

    The second argument <a href="motion.txt.html#is" class="d">is</a> the <span class="e">ctx</span> of <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a>

config({name}, <span class="s">{cfg}</span>)                                       <span id="vim.lsp.config%28%29" class="t">vim.lsp.config()</span>
    Update the configuration <a href="luaref.txt.html#for" class="d">for</a> an <a href="lsp.txt.html#LSP" class="d">LSP</a> client.

    Use name <a href="motion.txt.html#%27" class="d">'</a>*<a href="motion.txt.html#%27" class="d">'</a> to set default configuration <a href="luaref.txt.html#for" class="d">for</a> all clients.

    Can also be table-assigned to redefine the configuration <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> client.

    Examples:
    • Add <a href="insert.txt.html#a" class="d">a</a> root marker <a href="luaref.txt.html#for" class="d">for</a> all clients: 
<span class="e">        vim.lsp.config('*', {</span>
<span class="e">          root_markers = { '.git' },</span>
<span class="e">        })</span>

    • Add additional capabilities to all clients: 
<span class="e">        vim.lsp.config('*', {</span>
<span class="e">          capabilities = {</span>
<span class="e">            textDocument = {</span>
<span class="e">              semanticTokens = {</span>
<span class="e">                multilineTokenSupport = true,</span>
<span class="e">              }</span>
<span class="e">            }</span>
<span class="e">          }</span>
<span class="e">        })</span>

    • (Re-)define the configuration <a href="luaref.txt.html#for" class="d">for</a> clangd: 
<span class="e">        vim.lsp.config.clangd = {</span>
<span class="e">          cmd = {</span>
<span class="e">            'clangd',</span>
<span class="e">            '--clang-tidy',</span>
<span class="e">            '--background-index',</span>
<span class="e">            '--offset-encoding=utf-8',</span>
<span class="e">          },</span>
<span class="e">          root_markers = { '.clangd', 'compile_commands.json' },</span>
<span class="e">          filetypes = { 'c', 'cpp' },</span>
<span class="e">        }</span>

    • Get configuration <a href="luaref.txt.html#for" class="d">for</a> luals: 
<span class="e">        local cfg = vim.lsp.config.luals</span>


<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>  (`string`)
      • <span class="s">{cfg}</span>   (`vim.lsp.Config`) See <a href="lsp.txt.html#vim.lsp.Config" class="l">vim.lsp.Config</a><a href="repeat.txt.html#." class="d">.</a>

enable({name}, <span class="s">{enable}</span>)                                    <span id="vim.lsp.enable%28%29" class="t">vim.lsp.enable()</span>
    Auto-starts <a href="lsp.txt.html#LSP" class="d">LSP</a> when <a href="insert.txt.html#a" class="d">a</a> buffer <a href="motion.txt.html#is" class="d">is</a> opened, based on the <a href="lsp.txt.html#lsp-config" class="l">lsp-config</a>
    <span class="e">filetypes</span>, <span class="e">root_markers</span>, and <span class="e">root_dir</span> fields.

    Examples: 
<span class="e">        vim.lsp.enable('clangd')</span>
<span class="e">        vim.lsp.enable({'luals', 'pyright'})</span>


    Example: <span id="lsp-restart" class="t">lsp-restart</span> Passing <span class="e">false</span> stops and detaches the client(s).
    Thus you can "restart" <a href="lsp.txt.html#LSP" class="d">LSP</a> by disabling and re-enabling <a href="insert.txt.html#a" class="d">a</a> given config: 
<span class="e">        vim.lsp.enable('clangd', false)</span>
<span class="e">        vim.lsp.enable('clangd', true)</span>


    Example: To dynamically decide whether <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="motion.txt.html#is" class="d">is</a> activated, define <a href="insert.txt.html#a" class="d">a</a>
    <a href="lsp.txt.html#lsp-root_dir%28%29" class="l">lsp-root_dir()</a> function which calls <span class="e">on_dir()</span> only when you want that
    <a href="starting.txt.html#config" class="d">config</a> to activate: 
<span class="e">        vim.lsp.config('lua_ls', {</span>
<span class="e">          root_dir = function(bufnr, on_dir)</span>
<span class="e">            if not vim.fn.bufname(bufnr):match('%.txt$') then</span>
<span class="e">              on_dir(vim.fn.getcwd())</span>
<span class="e">            end</span>
<span class="e">          end</span>
<span class="e">        })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>    (`string|string[]`) Name(s) of client(s) to enable.
      • <span class="s">{enable}</span>  (`boolean?`) <span class="e">true|nil</span> to enable, <span class="e">false</span> to disable
                  (actively stops and detaches clients <a href="motion.txt.html#as" class="d">as</a> needed)

foldclose({kind}, <span class="s">{winid}</span>)                               <span id="vim.lsp.foldclose%28%29" class="t">vim.lsp.foldclose()</span>
    Close all <span class="s">{kind}</span> of <a href="fold.txt.html#folds" class="d">folds</a> in the the <a href="windows.txt.html#window" class="d">window</a> with <span class="s">{winid}</span>.

    To automatically fold imports when opening <a href="insert.txt.html#a" class="d">a</a> file, you can use an autocmd: 
<span class="e">        vim.api.nvim_create_autocmd('LspNotify', {</span>
<span class="e">          callback = function(args)</span>
<span class="e">            if args.data.method == 'textDocument/didOpen' then</span>
<span class="e">              vim.lsp.foldclose('imports', vim.fn.bufwinid(args.buf))</span>
<span class="e">            end</span>
<span class="e">          end,</span>
<span class="e">        })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{kind}</span>   (`lsp.FoldingRangeKind`) Kind to close, one of "comment"<a href="motion.txt.html#%2C" class="d">,</a>
                 "imports" or "region"<a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{winid}</span>  (`integer?`) Defaults to the current window.

foldexpr({lnum})                                          <span id="vim.lsp.foldexpr%28%29" class="t">vim.lsp.foldexpr()</span>
    Provides an interface between the built-in client and <a href="insert.txt.html#a" class="d">a</a> <span class="e">foldexpr</span>
    function.

    To use, set <a href="options.txt.html#%27foldmethod%27" class="o">'foldmethod'</a> to "<a href="vimeval.txt.html#expr" class="d">expr</a>" and set the value of <a href="options.txt.html#%27foldexpr%27" class="o">'foldexpr'</a>: 
<span class="e">        vim.o.foldmethod = 'expr'</span>
<span class="e">        vim.o.foldexpr = 'v:lua.vim.lsp.foldexpr()'</span>


    Or use <a href="motion.txt.html#it" class="d">it</a> only when supported by checking <a href="luaref.txt.html#for" class="d">for</a> the
    "textDocument/foldingRange" capability in an <a href="lsp.txt.html#LspAttach" class="l">LspAttach</a> autocommand.
    Example: 
<span class="e">        vim.o.foldmethod = 'expr'</span>
<span class="e">        -- Default to treesitter folding</span>
<span class="e">        vim.o.foldexpr = 'v:lua.vim.treesitter.foldexpr()'</span>
<span class="e">        -- Prefer LSP folding if client supports it</span>
<span class="e">        vim.api.nvim_create_autocmd('LspAttach', {</span>
<span class="e">          callback = function(args)</span>
<span class="e">            local client = vim.lsp.get_client_by_id(args.data.client_id)</span>
<span class="e">            if client:supports_method('textDocument/foldingRange') then</span>
<span class="e">              local win = vim.api.nvim_get_current_win()</span>
<span class="e">              vim.wo[win][0].foldexpr = 'v:lua.vim.lsp.foldexpr()'</span>
<span class="e">            end</span>
<span class="e">          end,</span>
<span class="e">        })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{lnum}</span>  (`integer`) line number

<a href="vimfn.txt.html#foldtext%28%29" class="d">foldtext()</a>                                                <span id="vim.lsp.foldtext%28%29" class="t">vim.lsp.foldtext()</span>
    Provides <a href="insert.txt.html#a" class="d">a</a> <span class="e">foldtext</span> function that shows the <span class="e">collapsedText</span> retrieved,
    <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to the first folded line if <span class="e">collapsedText</span> <a href="motion.txt.html#is" class="d">is</a> not provided.

formatexpr({opts})                                      <span id="vim.lsp.formatexpr%28%29" class="t">vim.lsp.formatexpr()</span>
    Provides an interface between the built-in client and <a href="insert.txt.html#a" class="d">a</a> <span class="e">formatexpr</span>
    function.

    Currently only supports <a href="insert.txt.html#a" class="d">a</a> single client. This can be set via
    `setlocal formatexpr=v:lua.vim.lsp.formatexpr()` or (more typically) in
    <span class="e">on_attach</span> via
    `vim.bo[bufnr].formatexpr <a href="change.txt.html#%3D" class="d">=</a> 'v:lua.vim.lsp.formatexpr(#{timeout_ms:250})'`.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{timeout_ms}</span> (`integer`, default: 500ms) The timeout period
                  <a href="luaref.txt.html#for" class="d">for</a> the <a href="change.txt.html#formatting" class="d">formatting</a> request..

                                          <span id="vim.lsp.get_buffers_by_client_id%28%29" class="t">vim.lsp.get_buffers_by_client_id()</span>
get_buffers_by_client_id({client_id})
    Returns <a href="vimeval.txt.html#list" class="d">list</a> of <a href="windows.txt.html#buffers" class="d">buffers</a> attached to client_id.

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer`) client id

<span class="h">    Return: </span>
        (`integer[]`) <a href="windows.txt.html#buffers" class="d">buffers</a> <a href="vimeval.txt.html#list" class="d">list</a> of buffer ids

get_client_by_id({client_id})                     <span id="vim.lsp.get_client_by_id%28%29" class="t">vim.lsp.get_client_by_id()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> client by id, or nil if the id <a href="motion.txt.html#is" class="d">is</a> invalid. The returned client may
    not yet be fully initialized.

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer`) client id

<span class="h">    Return: </span>
        (`vim.lsp.Client?`) client <a href="api.txt.html#rpc" class="d">rpc</a> object

get_clients({filter})                                  <span id="vim.lsp.get_clients%28%29" class="t">vim.lsp.get_clients()</span>
    Get active clients.

<span class="h">    Parameters: </span>
      • <span class="s">{filter}</span>  (`table?`) Key-value pairs used to <a href="change.txt.html#filter" class="d">filter</a> the returned
                  clients.
                  • <span class="s">{id}</span>? (`integer`) Only return clients with the given id
                  • <span class="s">{bufnr}</span>? (`integer`) Only return clients attached to this
                    buffer
                  • <span class="s">{name}</span>? (`string`) Only return clients with the given name
                  • <span class="s">{method}</span>? (`string`) Only return clients supporting the
                    given <a href="vimeval.txt.html#method" class="d">method</a>

<span class="h">    Return: </span>
        (`vim.lsp.Client[]`) <a href="vimeval.txt.html#List" class="d">List</a> of <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a> <a href="index.txt.html#objects" class="d">objects</a>

get_log_path()                                        <span id="vim.lsp.get_log_path%28%29" class="t">vim.lsp.get_log_path()</span>
    Gets the path of the logfile used by the <a href="lsp.txt.html#LSP" class="d">LSP</a> client.

<span class="h">    Return: </span>
        (`string`) path to <a href="starting.txt.html#log" class="d">log</a> file

is_enabled({name})                                      <span id="vim.lsp.is_enabled%28%29" class="t">vim.lsp.is_enabled()</span>
    Checks if the given <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="starting.txt.html#config" class="d">config</a> <a href="motion.txt.html#is" class="d">is</a> enabled (globally, not per-buffer).

    Unlike <span class="e">vim.lsp.config['…']</span>, this does not have the side-effect of
    resolving the config.

<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>  (`string`) Config name

<span class="h">    Return: </span>
        (`boolean`)

omnifunc({findstart}, <span class="s">{base}</span>)                             <span id="vim.lsp.omnifunc%28%29" class="t">vim.lsp.omnifunc()</span>
    Implements <a href="options.txt.html#%27omnifunc%27" class="o">'omnifunc'</a> compatible <a href="lsp.txt.html#LSP" class="d">LSP</a> completion.

<span class="h">    Parameters: </span>
      • <span class="s">{findstart}</span>  (`integer`) <a href="motion.txt.html#0" class="d">0</a> or 1, decides behavior
      • <span class="s">{base}</span>       (`integer`) findstart=0, text to match against

<span class="h">    Return: </span>
        (`integer|table`) Decided by <span class="s">{findstart}</span>:
        • findstart=0: column where the completion starts, or -2 or -3
        • findstart=1: <a href="vimeval.txt.html#list" class="d">list</a> of matches (actually just calls <a href="vimfn.txt.html#complete%28%29" class="l">complete()</a><a href="motion.txt.html#%29" class="d">)</a>

<span class="h">    See also: </span>
      • <a href="insert.txt.html#complete-functions" class="l">complete-functions</a>
      • <a href="insert.txt.html#complete-items" class="l">complete-items</a>
      • <a href="autocmd.txt.html#CompleteDone" class="l">CompleteDone</a>

set_log_level({level})                               <span id="vim.lsp.set_log_level%28%29" class="t">vim.lsp.set_log_level()</span>
    Sets the global <a href="starting.txt.html#log" class="d">log</a> level <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> logging.

    Levels by name: "TRACE"<a href="motion.txt.html#%2C" class="d">,</a> "DEBUG"<a href="motion.txt.html#%2C" class="d">,</a> "INFO"<a href="motion.txt.html#%2C" class="d">,</a> "WARN"<a href="motion.txt.html#%2C" class="d">,</a> "ERROR"<a href="motion.txt.html#%2C" class="d">,</a> "OFF"

    Level numbers begin with "TRACE" <a href="motion.txt.html#at" class="d">at</a> <a href="motion.txt.html#0" class="d">0</a>

    Use <span class="e">lsp.log_levels</span> <a href="luaref.txt.html#for" class="d">for</a> reverse lookup.

<span class="h">    Parameters: </span>
      • <span class="s">{level}</span>  (`integer|string`) the <a href="change.txt.html#case" class="d">case</a> insensitive level name or number

<span class="h">    See also: </span>
      • <a href="lsp.txt.html#vim.lsp.log_levels" class="l">vim.lsp.log_levels</a>

start({config}, <span class="s">{opts}</span>)                                      <span id="vim.lsp.start%28%29" class="t">vim.lsp.start()</span>
    Create <a href="insert.txt.html#a" class="d">a</a> new <a href="lsp.txt.html#LSP" class="d">LSP</a> client and start <a href="insert.txt.html#a" class="d">a</a> language server or reuses an already
    running client if one <a href="motion.txt.html#is" class="d">is</a> found matching <span class="e">name</span> and <span class="e">root_dir</span>. Attaches
    the current buffer to the client.

    Example: 
<span class="e">        vim.lsp.start({</span>
<span class="e">           name = 'my-server-name',</span>
<span class="e">           cmd = {'name-of-language-server-executable'},</span>
<span class="e">           root_dir = vim.fs.root(0, {'pyproject.toml', 'setup.py'}),</span>
<span class="e">        })</span>


    See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a> <a href="luaref.txt.html#for" class="d">for</a> all available options. The most important
    are:
    • <span class="e">name</span> arbitrary name <a href="luaref.txt.html#for" class="d">for</a> the <a href="lsp.txt.html#LSP" class="d">LSP</a> client. Should be unique per language
      server.
    • <span class="e">cmd</span> command string[] or function.
    • <span class="e">root_dir</span> path to the project root. By default this <a href="motion.txt.html#is" class="d">is</a> used to decide
      if an existing client should be re-used. The example above uses
      <a href="lua.txt.html#vim.fs.root%28%29" class="l">vim.fs.root()</a> to detect the root by traversing the file system upwards
      <a href="starting.txt.html#starting" class="d">starting</a> from the current directory until either <a href="insert.txt.html#a" class="d">a</a> <span class="e">pyproject.toml</span> or
      <span class="e">setup.py</span> file <a href="motion.txt.html#is" class="d">is</a> found.
    • <span class="e">workspace_folders</span> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="motion.txt.html#%60%7B" class="d">`{</a> uri:string, name: <a href="vimeval.txt.html#string" class="d">string</a> }` tables
      specifying the project root folders used by the language server. If
      <span class="e">nil</span> the property <a href="motion.txt.html#is" class="d">is</a> derived from <span class="e">root_dir</span> <a href="luaref.txt.html#for" class="d">for</a> convenience.

    Language servers use this information to discover metadata like the
    dependencies of your project and they tend to <a href="index.txt.html#index" class="d">index</a> the contents within
    the project folder.

    To ensure <a href="insert.txt.html#a" class="d">a</a> language server <a href="motion.txt.html#is" class="d">is</a> only started <a href="luaref.txt.html#for" class="d">for</a> languages <a href="motion.txt.html#it" class="d">it</a> can handle,
    make sure to call <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a> within <a href="insert.txt.html#a" class="d">a</a> <a href="autocmd.txt.html#FileType" class="l">FileType</a> autocmd. Either
    use <a href="autocmd.txt.html#%3Aau" class="l">:au</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="api.txt.html#nvim_create_autocmd%28%29" class="l">nvim_create_autocmd()</a> or <a href="change.txt.html#put" class="d">put</a> the call in <a href="insert.txt.html#a" class="d">a</a>
    <span class="e">ftplugin/&lt;filetype_name&gt;.lua</span> (See <a href="usr_05.txt.html#ftplugin-name" class="l">ftplugin-name</a><a href="motion.txt.html#%29" class="d">)</a>

<span class="h">    Parameters: </span>
      • <span class="s">{config}</span>  (`vim.lsp.ClientConfig`) Configuration <a href="luaref.txt.html#for" class="d">for</a> the server. See
                  <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{opts}</span>    (`table?`) Optional keyword arguments.
                  • <span class="s">{reuse_client}</span>?
                    (`fun(client: vim.lsp.Client, config: vim.lsp.ClientConfig): boolean`)
                    Predicate used to decide if <a href="insert.txt.html#a" class="d">a</a> client should be re-used.
                    Used on all running clients. The default implementation
                    re-uses <a href="insert.txt.html#a" class="d">a</a> client if <a href="motion.txt.html#it" class="d">it</a> has the same name and if the given
                    workspace folders (or root_dir) are all included in the
                    client's workspace folders.
                  • <span class="s">{bufnr}</span>? (`integer`) Buffer handle to attach to if
                    <a href="starting.txt.html#starting" class="d">starting</a> or re-using <a href="insert.txt.html#a" class="d">a</a> client (0 <a href="luaref.txt.html#for" class="d">for</a> current).
                  • <span class="s">{attach}</span>? (`boolean`) Whether to attach the client to <a href="insert.txt.html#a" class="d">a</a>
                    buffer (default true). If set to <span class="e">false</span>, <span class="e">reuse_client</span>
                    and <span class="e">bufnr</span> will be ignored.
                  • <span class="s">{silent}</span>? (`boolean`) Suppress error reporting if the <a href="lsp.txt.html#LSP" class="d">LSP</a>
                    server fails to start (default false).

<span class="h">    Return: </span>
        (`integer?`) client_id

status()                                                    <span id="vim.lsp.status%28%29" class="t">vim.lsp.status()</span>
    Consumes the latest progress <a href="message.txt.html#messages" class="d">messages</a> from all clients and formats them <a href="motion.txt.html#as" class="d">as</a>
    <a href="insert.txt.html#a" class="d">a</a> string. Empty if there are no clients or if no new <a href="message.txt.html#messages" class="d">messages</a>

<span class="h">    Return: </span>
        (`string`)

stop_client({client_id}, <span class="s">{force}</span>)                      <span id="vim.lsp.stop_client%28%29" class="t">vim.lsp.stop_client()</span>
    Stops <a href="insert.txt.html#a" class="d">a</a> client(s).

    You can also use the <span class="e">stop()</span> function on <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a> object. To
    stop all clients: 
<span class="e">        vim.lsp.stop_client(vim.lsp.get_clients())</span>


    By default asks the server to shutdown, unless stop was requested already
    <a href="luaref.txt.html#for" class="d">for</a> this client, then force-shutdown <a href="motion.txt.html#is" class="d">is</a> attempted.

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer<span class="l">integer[]</span>vim.lsp.Client[]`) id, <a href="vimeval.txt.html#list" class="d">list</a> of id's,
                     or <a href="vimeval.txt.html#list" class="d">list</a> of <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a> <a href="index.txt.html#objects" class="d">objects</a>
      • <span class="s">{force}</span>      (`boolean?`) shutdown forcefully

tagfunc({pattern}, <span class="s">{flags}</span>)                                <span id="vim.lsp.tagfunc%28%29" class="t">vim.lsp.tagfunc()</span>
    Provides an interface between the built-in client and <a href="options.txt.html#%27tagfunc%27" class="o">'tagfunc'</a>.

    When used with normal mode commands (e.g. <a href="tagsrch.txt.html#CTRL-%5D" class="l">CTRL-]</a><a href="motion.txt.html#%29" class="d">)</a> this will invoke the
    "textDocument/definition" <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> to find the <a href="tagsrch.txt.html#tag" class="d">tag</a> under the cursor.
    Otherwise, uses "workspace/symbol"<a href="repeat.txt.html#." class="d">.</a> If no results are returned from any
    <a href="lsp.txt.html#LSP" class="d">LSP</a> servers, falls back to using built-in tags.

<span class="h">    Parameters: </span>
      • <span class="s">{pattern}</span>  (`string`) <a href="pattern.txt.html#Pattern" class="d">Pattern</a> used to find <a href="insert.txt.html#a" class="d">a</a> workspace symbol
      • <span class="s">{flags}</span>    (`string`) See <a href="tagsrch.txt.html#tag-function" class="l">tag-function</a>

<span class="h">    Return: </span>
        (`table[]`) <a href="tagsrch.txt.html#tags" class="d">tags</a> <a href="insert.txt.html#A" class="d">A</a> <a href="vimeval.txt.html#list" class="d">list</a> of matching <a href="tagsrch.txt.html#tags" class="d">tags</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.client                                        <span id="lsp-client" class="t">lsp-client</span>

<span id="vim.lsp.Client" class="t">vim.lsp.Client</span>

<span class="h">    Fields: </span>
      • <span class="s">{attached_buffers}</span>      (`table&lt;integer,true&gt;`)
      • <span class="s">{capabilities}</span>          (`lsp.ClientCapabilities`) Capabilities
                                provided by the client (editor or tool), <a href="motion.txt.html#at" class="d">at</a>
                                startup.
      • <span class="s">{commands}</span>              (`table&lt;string,fun(command: lsp.Command, ctx: table)&gt;`)
                                Client commands. See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{config}</span>                (`vim.lsp.ClientConfig`) Copy of the <a href="starting.txt.html#config" class="d">config</a>
                                passed to <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a><a href="repeat.txt.html#." class="d">.</a> See
                                <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{dynamic_capabilities}</span>  (`lsp.DynamicCapabilities`) Capabilities
                                provided <a href="motion.txt.html#at" class="d">at</a> runtime (after startup).
      • <span class="s">{flags}</span>                 (`table`) <a href="insert.txt.html#A" class="d">A</a> table with flags <a href="luaref.txt.html#for" class="d">for</a> the client.
                                The current (experimental) flags are:
                                • <span class="s">{allow_incremental_sync}</span>? (`boolean`,
                                  default: <span class="e">true</span>) Allow using incremental
                                  sync <a href="luaref.txt.html#for" class="d">for</a> buffer edits
                                • <span class="s">{debounce_text_changes}</span> (`integer`, default:
                                  <span class="e">150</span>) Debounce <span class="e">didChange</span> notifications to
                                  the server by the given number in
                                  milliseconds. No debounce occurs if <span class="e">nil</span>.
                                • <span class="s">{exit_timeout}</span> (`integer|false`, default:
                                  <span class="e">false</span>) Milliseconds to wait <a href="luaref.txt.html#for" class="d">for</a> server to
                                  exit cleanly after sending the "shutdown"
                                  request before sending kill -15. If set to
                                  false, <a href="nvim.txt.html#nvim" class="d">nvim</a> exits immediately after sending
                                  the "shutdown" request to the server.
      • <span class="s">{get_language_id}</span>       (`fun(bufnr: integer, filetype: string): string`)
                                See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{handlers}</span>              (`table&lt;string,lsp.Handler&gt;`) See
                                <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{id}</span>                    (`integer`) The id allocated to the client.
      • <span class="s">{initialized}</span>           (`true?`)
      • <span class="s">{name}</span>                  (`string`) See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{offset_encoding}</span>       (`string`) See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{progress}</span>              (`vim.lsp.Client.Progress`) <a href="insert.txt.html#A" class="d">A</a> ring buffer
                                <a href="motion.txt.html#%28" class="d">(</a><a href="lua.txt.html#vim.ringbuf%28%29" class="l">vim.ringbuf()</a><a href="motion.txt.html#%29" class="d">)</a> containing progress <a href="message.txt.html#messages" class="d">messages</a>
                                sent by the server. See
                                <a href="lsp.txt.html#vim.lsp.Client.Progress" class="l">vim.lsp.Client.Progress</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{requests}</span>              (`table&lt;integer,{ type: string, bufnr: integer, method: string}?&gt;`)
                                The current pending requests in flight to the
                                server. Entries are key-value pairs with the
                                key being the request id while the value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a>
                                table with <span class="e">type</span>, <span class="e">bufnr</span>, and <span class="e">method</span>
                                key-value pairs. <span class="e">type</span> <a href="motion.txt.html#is" class="d">is</a> either "pending"
                                <a href="luaref.txt.html#for" class="d">for</a> an active request, or "cancel" <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a>
                                cancel request. It will be "complete"
                                ephemerally while executing <a href="lsp.txt.html#LspRequest" class="l">LspRequest</a>
                                autocmds when replies are received from the
                                server.
      • <span class="s">{root_dir}</span>              (`string?`) See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{rpc}</span>                   (`vim.lsp.rpc.PublicClient`) <a href="api.txt.html#RPC" class="d">RPC</a> client
                                object, <a href="luaref.txt.html#for" class="d">for</a> low level interaction with the
                                client. See <a href="lsp.txt.html#vim.lsp.rpc.start%28%29" class="l">vim.lsp.rpc.start()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{server_capabilities}</span>   (`lsp.ServerCapabilities?`) Response from the
                                server sent on <span class="e">initialize</span> describing the
                                server's capabilities.
      • <span class="s">{server_info}</span>           (`lsp.ServerInfo?`) Response from the server
                                sent on <span class="e">initialize</span> describing server
                                information (e.g. version).
      • <span class="s">{settings}</span>              (`lsp.LSPObject`) See <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{workspace_folders}</span>     (`lsp.WorkspaceFolder[]?`) See
                                <a href="lsp.txt.html#vim.lsp.ClientConfig" class="l">vim.lsp.ClientConfig</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{request}</span>               (`fun(self: vim.lsp.Client, method: string, params: table?, handler: lsp.Handler?, bufnr: integer?): boolean, integer?`)
                                See <a href="lsp.txt.html#Client%3Arequest%28%29" class="l">Client:request()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{request_sync}</span>          (`fun(self: vim.lsp.Client, method: string, params: table, timeout_ms: integer?, bufnr: integer?): <span class="s">{err: lsp.ResponseError?, result:any}</span>?, string?`)
                                See <a href="lsp.txt.html#Client%3Arequest_sync%28%29" class="l">Client:request_sync()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{notify}</span>                (`fun(self: vim.lsp.Client, method: string, params: table?): boolean`)
                                See <a href="lsp.txt.html#Client%3Anotify%28%29" class="l">Client:notify()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{cancel_request}</span>        (`fun(self: vim.lsp.Client, id: integer): boolean`)
                                See <a href="lsp.txt.html#Client%3Acancel_request%28%29" class="l">Client:cancel_request()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{stop}</span>                  (`fun(self: vim.lsp.Client, force: boolean?)`)
                                See <a href="lsp.txt.html#Client%3Astop%28%29" class="l">Client:stop()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{is_stopped}</span>            (`fun(self: vim.lsp.Client): boolean`) See
                                <a href="lsp.txt.html#Client%3Ais_stopped%28%29" class="l">Client:is_stopped()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{exec_cmd}</span>              (`fun(self: vim.lsp.Client, command: lsp.Command, context: <span class="s">{bufnr?: integer}</span>?, handler: lsp.Handler?)`)
                                See <a href="lsp.txt.html#Client%3Aexec_cmd%28%29" class="l">Client:exec_cmd()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{on_attach}</span>             (`fun(self: vim.lsp.Client, bufnr: integer)`)
                                See <a href="lsp.txt.html#Client%3Aon_attach%28%29" class="l">Client:on_attach()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{supports_method}</span>       (`fun(self: vim.lsp.Client, method: string, bufnr: integer?)`)
                                See <a href="lsp.txt.html#Client%3Asupports_method%28%29" class="l">Client:supports_method()</a><a href="repeat.txt.html#." class="d">.</a>

<span id="vim.lsp.Client.Progress" class="t">vim.lsp.Client.Progress</span>
    Extends: <a href="lua.txt.html#vim.Ringbuf" class="l">vim.Ringbuf</a>


<span class="h">    Fields: </span>
      • <span class="s">{pending}</span>  (`table&lt;lsp.ProgressToken,lsp.LSPAny&gt;`)

<span id="vim.lsp.ClientConfig" class="t">vim.lsp.ClientConfig</span>

<span class="h">    Fields: </span>
      • <span class="s">{before_init}</span>?         (`fun(params: lsp.InitializeParams, config: vim.lsp.ClientConfig)`)
                               Callback invoked before the <a href="lsp.txt.html#LSP" class="d">LSP</a> "initialize"
                               phase, where <span class="e">params</span> contains the parameters
                               being sent to the server and <span class="e">config</span> <a href="motion.txt.html#is" class="d">is</a> the
                               <a href="starting.txt.html#config" class="d">config</a> that was passed to <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a><a href="repeat.txt.html#." class="d">.</a>
                               You can use this to modify parameters before
                               they are sent.
      • <span class="s">{capabilities}</span>?        (`lsp.ClientCapabilities`) Map overriding the
                               default capabilities defined by
                               <a href="lsp.txt.html#vim.lsp.protocol.make_client_capabilities%28%29" class="l">vim.lsp.protocol.make_client_capabilities()</a><a href="motion.txt.html#%2C" class="d">,</a>
                               passed to the language server on
                               initialization. Hint: use
                               make_client_capabilities() and modify its
                               result.
                               • <span class="n">Note:</span> To send an empty dictionary use
                                 <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a><a href="motion.txt.html#%2C" class="d">,</a> else <a href="motion.txt.html#it" class="d">it</a> will be encoded
                                 <a href="motion.txt.html#as" class="d">as</a> an array.
      • <span class="s">{cmd}</span>                  (`string[]|fun(dispatchers: vim.lsp.rpc.Dispatchers, config: vim.lsp.ClientConfig): vim.lsp.rpc.PublicClient`)
                               Command <span class="e">string[]</span> that launches the language
                               server (treated <a href="motion.txt.html#as" class="d">as</a> in <a href="vimfn.txt.html#jobstart%28%29" class="l">jobstart()</a><a href="motion.txt.html#%2C" class="d">,</a> must be
                               absolute or on <span class="e">$PATH</span>, shell constructs like
                               "<a href="change.txt.html#~" class="d">~</a>" are not expanded), or function that creates
                               an <a href="api.txt.html#RPC" class="d">RPC</a> client. Function receives <a href="insert.txt.html#a" class="d">a</a>
                               <span class="e">dispatchers</span> table and the resolved <span class="e">config</span>,
                               and must return <a href="insert.txt.html#a" class="d">a</a> table with member <a href="vimeval.txt.html#functions" class="d">functions</a>
                               <span class="e">request</span>, <span class="e">notify</span>, <span class="e">is_closing</span> and
                               <span class="e">terminate</span>. See <a href="lsp.txt.html#vim.lsp.rpc.request%28%29" class="l">vim.lsp.rpc.request()</a><a href="motion.txt.html#%2C" class="d">,</a>
                               <a href="lsp.txt.html#vim.lsp.rpc.notify%28%29" class="l">vim.lsp.rpc.notify()</a><a href="repeat.txt.html#." class="d">.</a> For TCP there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a>
                               builtin <a href="api.txt.html#RPC" class="d">RPC</a> client factory:
                               <a href="lsp.txt.html#vim.lsp.rpc.connect%28%29" class="l">vim.lsp.rpc.connect()</a>
      • <span class="s">{cmd_cwd}</span>?             (`string`, default: cwd) Directory to launch
                               the <span class="e">cmd</span> process. Not related to <span class="e">root_dir</span>.
      • <span class="s">{cmd_env}</span>?             (`table`) Environment <a href="vimeval.txt.html#variables" class="d">variables</a> passed to the
                               <a href="lsp.txt.html#LSP" class="d">LSP</a> process on spawn. Non-string values are
                               coerced to string. Example: 
<span class="e">                                   { PORT = 8080; HOST = '0.0.0.0'; }</span>

      • <span class="s">{commands}</span>?            (`table&lt;string,fun(command: lsp.Command, ctx: table)&gt;`)
                               Client commands. Map of command names to
                               user-defined functions. Commands passed to
                               <span class="e">start()</span> take precedence over the global
                               command registry. Each key must be <a href="insert.txt.html#a" class="d">a</a> unique
                               command name, and the value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function which
                               <a href="motion.txt.html#is" class="d">is</a> called if any <a href="lsp.txt.html#LSP" class="d">LSP</a> action (code action, code
                               lenses, …<a href="motion.txt.html#%29" class="d">)</a> triggers the command.
      • <span class="s">{detached}</span>?            (`boolean`, default: <span class="e">true</span>) Daemonize the
                               server process so that <a href="motion.txt.html#it" class="d">it</a> runs in <a href="insert.txt.html#a" class="d">a</a> separate
                               process group from Nvim. Nvim will shutdown the
                               process on exit, but if Nvim fails to exit
                               cleanly this could leave behind orphaned server
                               processes.
      • <span class="s">{flags}</span>?               (`table`) <a href="insert.txt.html#A" class="d">A</a> table with flags <a href="luaref.txt.html#for" class="d">for</a> the client.
                               The current (experimental) flags are:
                               • <span class="s">{allow_incremental_sync}</span>? (`boolean`,
                                 default: <span class="e">true</span>) Allow using incremental sync
                                 <a href="luaref.txt.html#for" class="d">for</a> buffer edits
                               • <span class="s">{debounce_text_changes}</span> (`integer`, default:
                                 <span class="e">150</span>) Debounce <span class="e">didChange</span> notifications to
                                 the server by the given number in
                                 milliseconds. No debounce occurs if <span class="e">nil</span>.
                               • <span class="s">{exit_timeout}</span> (`integer|false`, default:
                                 <span class="e">false</span>) Milliseconds to wait <a href="luaref.txt.html#for" class="d">for</a> server to
                                 exit cleanly after sending the "shutdown"
                                 request before sending kill -15. If set to
                                 false, <a href="nvim.txt.html#nvim" class="d">nvim</a> exits immediately after sending
                                 the "shutdown" request to the server.
      • <span class="s">{get_language_id}</span>?     (`fun(bufnr: integer, filetype: string): string`)
                               Language ID <a href="motion.txt.html#as" class="d">as</a> string. Defaults to the buffer
                               filetype.
      • <span class="s">{handlers}</span>?            (`table&lt;string,function&gt;`) Map of <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a>
                               names to <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a>s.
      • <span class="s">{init_options}</span>?        (`lsp.LSPObject`) Values to pass in the
                               <a href="starting.txt.html#initialization" class="d">initialization</a> request <a href="motion.txt.html#as" class="d">as</a>
                               <span class="e">initializationOptions</span>. See <span class="e">initialize</span> in
                               the <a href="lsp.txt.html#LSP" class="d">LSP</a> spec.
      • <span class="s">{name}</span>?                (`string`, default: client-id) Name in logs and
                               user messages.
      • <span class="s">{offset_encoding}</span>?     (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`) Called "position
                               encoding" in <a href="lsp.txt.html#LSP" class="d">LSP</a> spec. The encoding that the
                               <a href="lsp.txt.html#LSP" class="d">LSP</a> server expects, used <a href="luaref.txt.html#for" class="d">for</a> communication. Not
                               validated. Can be modified in <span class="e">on_init</span> before
                               text <a href="motion.txt.html#is" class="d">is</a> sent to the server.
      • <span class="s">{on_attach}</span>?           (`elem_or_list&lt;fun(client: vim.lsp.Client, bufnr: integer)&gt;`)
                               Callback invoked when client attaches to <a href="insert.txt.html#a" class="d">a</a>
                               buffer.
      • <span class="s">{on_error}</span>?            (`fun(code: integer, err: string)`) Callback
                               invoked when the client operation throws an
                               error. <span class="e">code</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> number describing the error.
                               Other arguments may be passed depending on the
                               error kind. See <span class="e">vim.lsp.rpc.client_errors</span> <a href="luaref.txt.html#for" class="d">for</a>
                               possible errors. Use
                               <span class="e">vim.lsp.rpc.client_errors[code]</span> to get
                               human-friendly name.
      • <span class="s">{on_exit}</span>?             (`elem_or_list&lt;fun(code: integer, signal: integer, client_id: integer)&gt;`)
                               Callback invoked on client exit.
                               • code: exit code of the process
                               • signal: number describing the signal used to
                                 terminate (if any)
                               • client_id: client handle
      • <span class="s">{on_init}</span>?             (`elem_or_list&lt;fun(client: vim.lsp.Client, init_result: lsp.InitializeResult)&gt;`)
                               Callback invoked after <a href="lsp.txt.html#LSP" class="d">LSP</a> "initialize"<a href="motion.txt.html#%2C" class="d">,</a> where
                               <span class="e">result</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> table of <span class="e">capabilities</span> and
                               anything else the server may send. For example,
                               clangd sends <span class="e">init_result.offsetEncoding</span> if
                               <span class="e">capabilities.offsetEncoding</span> was sent to it.
                               You can only modify the
                               <span class="e">client.offset_encoding</span> here before any
                               notifications are sent.
      • <span class="s">{root_dir}</span>?            (`string`) Directory where the <a href="lsp.txt.html#LSP" class="d">LSP</a> server will
                               base its workspaceFolders, rootUri, and
                               rootPath on initialization.
      • <span class="s">{settings}</span>?            (`lsp.LSPObject`) Map of language
                               server-specific settings, decided by the
                               client. Sent to the LS if requested via
                               <span class="e">workspace/configuration</span>. Keys are
                               case-sensitive.
      • <span class="s">{trace}</span>?               (`'off'<span class="l">'messages'</span><a href="options.txt.html#%27verbose%27" class="o">'verbose'</a>`, default: "off"<a href="motion.txt.html#%29" class="d">)</a>
                               Passed directly to the language server in the
                               initialize request. Invalid/empty values will
      • <span class="s">{workspace_folders}</span>?   (`lsp.WorkspaceFolder[]`) <a href="vimeval.txt.html#List" class="d">List</a> of workspace
                               folders passed to the language server. For
                               backwards compatibility rootUri and rootPath
                               are derived from the first workspace folder in
                               this list. Can be <span class="e">null</span> if the client supports
                               workspace folders but none are configured. See
                               <span class="e">workspaceFolders</span> in <a href="lsp.txt.html#LSP" class="d">LSP</a> spec.
      • <span class="s">{workspace_required}</span>?  (`boolean`, default: <span class="e">false</span>) Server requires <a href="insert.txt.html#a" class="d">a</a>
                               workspace (no "single file" support). <span class="n">Note:</span>
                               Without <a href="insert.txt.html#a" class="d">a</a> workspace, cross-file features
                               (navigation, hover) may or may not work
                               depending on the language server, even if the
                               server doesn't require <a href="insert.txt.html#a" class="d">a</a> workspace.


Client:cancel_request({id})                          <span id="Client%3Acancel_request%28%29" class="t">Client:cancel_request()</span>
    Cancels <a href="insert.txt.html#a" class="d">a</a> request with <a href="insert.txt.html#a" class="d">a</a> given request id.

<span class="h">    Parameters: </span>
      • <span class="s">{id}</span>  (`integer`) id of request to cancel

<span class="h">    Return: </span>
        (`boolean`) status indicating if the notification was successful.

<span class="h">    See also: </span>
      • <a href="lsp.txt.html#Client%3Anotify%28%29" class="l">Client:notify()</a>

Client:exec_cmd({command}, <span class="s">{context}</span>, <span class="s">{handler}</span>)           <span id="Client%3Aexec_cmd%28%29" class="t">Client:exec_cmd()</span>
    Execute <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#lsp" class="d">lsp</a> command, either via client command function (if available)
    or via workspace/executeCommand (if supported by the server)

<span class="h">    Parameters: </span>
      • <span class="s">{command}</span>  (`lsp.Command`)
      • <span class="s">{context}</span>  (`{bufnr?: integer}?`)
      • <span class="s">{handler}</span>  (`lsp.Handler?`) only called if <a href="insert.txt.html#a" class="d">a</a> server command

<a href="lsp.txt.html#Client%3Ais_stopped%28%29" class="d">Client:is_stopped()</a>                                      <span id="Client%3Ais_stopped%28%29" class="t">Client:is_stopped()</span>
    Checks whether <a href="insert.txt.html#a" class="d">a</a> client <a href="motion.txt.html#is" class="d">is</a> stopped.

<span class="h">    Return: </span>
        (`boolean`) true if client <a href="motion.txt.html#is" class="d">is</a> stopped or in the process of being
        stopped; false otherwise

Client:notify({method}, <span class="s">{params}</span>)                            <span id="Client%3Anotify%28%29" class="t">Client:notify()</span>
    Sends <a href="insert.txt.html#a" class="d">a</a> notification to an <a href="lsp.txt.html#LSP" class="d">LSP</a> server.

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>  (`string`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> name.
      • <span class="s">{params}</span>  (`table?`) <a href="lsp.txt.html#LSP" class="d">LSP</a> request params.

<span class="h">    Return: </span>
        (`boolean`) status indicating if the notification was successful. If
        <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> false, then the client has shutdown.

Client:on_attach({bufnr})                                 <span id="Client%3Aon_attach%28%29" class="t">Client:on_attach()</span>
    Runs the on_attach function from the client's <a href="starting.txt.html#config" class="d">config</a> if <a href="motion.txt.html#it" class="d">it</a> was defined.
    Useful <a href="luaref.txt.html#for" class="d">for</a> buffer-local setup.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer`) Buffer number

                                                            <span id="Client%3Arequest%28%29" class="t">Client:request()</span>
Client:request({method}, <span class="s">{params}</span>, <span class="s">{handler}</span>, <span class="s">{bufnr}</span>)
    Sends <a href="insert.txt.html#a" class="d">a</a> request to the server.

    This <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> thin wrapper around <span class="s">{client.rpc.request}</span> with some additional
    checks <a href="luaref.txt.html#for" class="d">for</a> capabilities and handler availability.

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>   (`string`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> name.
      • <span class="s">{params}</span>   (`table?`) <a href="lsp.txt.html#LSP" class="d">LSP</a> request params.
      • <span class="s">{handler}</span>  (`lsp.Handler?`) Response <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> <a href="luaref.txt.html#for" class="d">for</a> this method.
      • <span class="s">{bufnr}</span>    (`integer?`) (default: 0) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current.

<span class="h">    Return (multiple): </span>
        (`boolean`) status indicates whether the request was successful. If <a href="motion.txt.html#it" class="d">it</a>
        <a href="motion.txt.html#is" class="d">is</a> <span class="e">false</span>, then <a href="motion.txt.html#it" class="d">it</a> will always be <span class="e">false</span> (the client has shutdown).
        (`integer?`) request_id Can be used with <a href="lsp.txt.html#Client%3Acancel_request%28%29" class="l">Client:cancel_request()</a><a href="repeat.txt.html#." class="d">.</a>
        <span class="e">nil</span> <a href="motion.txt.html#is" class="d">is</a> request failed.

<span class="h">    See also: </span>
      • <a href="lsp.txt.html#vim.lsp.buf_request_all%28%29" class="l">vim.lsp.buf_request_all()</a>

                                                       <span id="Client%3Arequest_sync%28%29" class="t">Client:request_sync()</span>
Client:request_sync({method}, <span class="s">{params}</span>, <span class="s">{timeout_ms}</span>, <span class="s">{bufnr}</span>)
    Sends <a href="insert.txt.html#a" class="d">a</a> request to the server and synchronously waits <a href="luaref.txt.html#for" class="d">for</a> the response.

    This <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> wrapper around <a href="lsp.txt.html#Client%3Arequest%28%29" class="l">Client:request()</a>

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>      (`string`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> name.
      • <span class="s">{params}</span>      (`table`) <a href="lsp.txt.html#LSP" class="d">LSP</a> request params.
      • <span class="s">{timeout_ms}</span>  (`integer?`) Maximum time in milliseconds to wait <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a>
                      result. Defaults to 1000
      • <span class="s">{bufnr}</span>       (`integer?`) (default: 0) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a>
                      current.

<span class="h">    Return (multiple): </span>
        (`{err: lsp.ResponseError?, result:any}?`) <span class="e">result</span> and <span class="e">err</span> from the
        <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a><a href="repeat.txt.html#." class="d">.</a> <span class="e">nil</span> <a href="motion.txt.html#is" class="d">is</a> the request was unsuccessful
        (`string?`) err On timeout, cancel or error, where <span class="e">err</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a>
        describing the failure reason.

<span class="h">    See also: </span>
      • <a href="lsp.txt.html#vim.lsp.buf_request_sync%28%29" class="l">vim.lsp.buf_request_sync()</a>

Client:stop({force})                                           <span id="Client%3Astop%28%29" class="t">Client:stop()</span>
    Stops <a href="insert.txt.html#a" class="d">a</a> client, optionally with force.

    By default, <a href="motion.txt.html#it" class="d">it</a> will just request the server to shutdown without force. If
    you request to stop <a href="insert.txt.html#a" class="d">a</a> client which has previously been requested to
    shutdown, <a href="motion.txt.html#it" class="d">it</a> will automatically escalate and force shutdown.

<span class="h">    Parameters: </span>
      • <span class="s">{force}</span>  (`boolean?`)

Client:supports_method({method}, <span class="s">{bufnr}</span>)           <span id="Client%3Asupports_method%28%29" class="t">Client:supports_method()</span>
    Checks if <a href="insert.txt.html#a" class="d">a</a> client supports <a href="insert.txt.html#a" class="d">a</a> given method. Always returns true <a href="luaref.txt.html#for" class="d">for</a>
    unknown off-spec methods.

    <span class="n">Note:</span> Some language server capabilities can be file specific.

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>  (`string`)
      • <span class="s">{bufnr}</span>   (`integer?`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.buf                                              <span id="lsp-buf" class="t">lsp-buf</span>

The <span class="e">vim.lsp.buf_…</span> <a href="vimeval.txt.html#functions" class="d">functions</a> perform operations <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> clients attached to
the current buffer.


<span id="vim.lsp.ListOpts" class="t">vim.lsp.ListOpts</span>

<span class="h">    Fields: </span>
      • <span class="s">{on_list}</span>?  (`fun(t: vim.lsp.LocationOpts.OnList)`) list-handler
                    <a href="change.txt.html#replacing" class="d">replacing</a> the default handler. Called <a href="luaref.txt.html#for" class="d">for</a> any non-empty
                    result. This table can be used with <a href="vimfn.txt.html#setqflist%28%29" class="l">setqflist()</a> or
                    <a href="vimfn.txt.html#setloclist%28%29" class="l">setloclist()</a><a href="repeat.txt.html#." class="d">.</a> E.g.: 
<span class="e">                        local function on_list(options)</span>
<span class="e">                          vim.fn.setqflist({}, ' ', options)</span>
<span class="e">                          vim.cmd.cfirst()</span>
<span class="e">                        end</span>
<span class="e"></span>
<span class="e">                        vim.lsp.buf.definition({ on_list = on_list })</span>
<span class="e">                        vim.lsp.buf.references(nil, { on_list = on_list })</span>

      • <span class="s">{loclist}</span>?  (`boolean`) Whether to use the <a href="quickfix.txt.html#location-list" class="l">location-list</a> or the
                    <a href="quickfix.txt.html#quickfix" class="l">quickfix</a> <a href="vimeval.txt.html#list" class="d">list</a> in the default handler. 
<span class="e">                        vim.lsp.buf.definition({ loclist = true })</span>
<span class="e">                        vim.lsp.buf.references(nil, { loclist = false })</span>


<span id="vim.lsp.LocationOpts" class="t">vim.lsp.LocationOpts</span>
    Extends: <a href="lsp.txt.html#vim.lsp.ListOpts" class="l">vim.lsp.ListOpts</a>


<span class="h">    Fields: </span>
      • <span class="s">{reuse_win}</span>?  (`boolean`) Jump to existing <a href="windows.txt.html#window" class="d">window</a> if buffer <a href="motion.txt.html#is" class="d">is</a> already
                      open.

<span id="vim.lsp.LocationOpts.OnList" class="t">vim.lsp.LocationOpts.OnList</span>

<span class="h">    Fields: </span>
      • <span class="s">{items}</span>     (`table[]`) Structured like <a href="vimfn.txt.html#setqflist-what" class="l">setqflist-what</a>
      • <span class="s">{title}</span>?    (`string`) Title <a href="luaref.txt.html#for" class="d">for</a> the list.
      • <span class="s">{context}</span>?  (`{ bufnr: integer, method: <a href="vimeval.txt.html#string" class="d">string</a> }`) Subset of <span class="e">ctx</span>
                    from <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a><a href="repeat.txt.html#." class="d">.</a>

<span id="vim.lsp.buf.hover.Opts" class="t">vim.lsp.buf.hover.Opts</span>
    Extends: <a href="lsp.txt.html#vim.lsp.util.open_floating_preview.Opts" class="l">vim.lsp.util.open_floating_preview.Opts</a>


<span class="h">    Fields: </span>
      • <span class="s">{silent}</span>?  (`boolean`)

<span id="vim.lsp.buf.signature_help.Opts" class="t">vim.lsp.buf.signature_help.Opts</span>
    Extends: <a href="lsp.txt.html#vim.lsp.util.open_floating_preview.Opts" class="l">vim.lsp.util.open_floating_preview.Opts</a>


<span class="h">    Fields: </span>
      • <span class="s">{silent}</span>?  (`boolean`)


                                          <span id="vim.lsp.buf.add_workspace_folder%28%29" class="t">vim.lsp.buf.add_workspace_folder()</span>
add_workspace_folder({workspace_folder})
    Add the folder <a href="motion.txt.html#at" class="d">at</a> path to the workspace folders. If <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> not
    provided, the user will be prompted <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> path using <a href="vimfn.txt.html#input%28%29" class="l">input()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{workspace_folder}</span>  (`string?`)

clear_references()                            <span id="vim.lsp.buf.clear_references%28%29" class="t">vim.lsp.buf.clear_references()</span>
    Removes document highlights from current buffer.

code_action({opts})                                <span id="vim.lsp.buf.code_action%28%29" class="t">vim.lsp.buf.code_action()</span>
    Selects <a href="insert.txt.html#a" class="d">a</a> code action (LSP: "textDocument/codeAction" request) available
    <a href="motion.txt.html#at" class="d">at</a> cursor position.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{context}</span>? (`lsp.CodeActionContext`) Corresponds to
                  <span class="e">CodeActionContext</span> of the <a href="lsp.txt.html#LSP" class="d">LSP</a> specification:
                  • <span class="s">{diagnostics}</span>? (`table`) <a href="lsp.txt.html#LSP" class="d">LSP</a> <span class="e">Diagnostic[]</span>. Inferred from
                    the current position if not provided.
                  • <span class="s">{only}</span>? (`table`) <a href="vimeval.txt.html#List" class="d">List</a> of <a href="lsp.txt.html#LSP" class="d">LSP</a> <span class="e">CodeActionKind</span>s used to
                    <a href="change.txt.html#filter" class="d">filter</a> the code actions. Most language servers <a href="support.txt.html#support" class="d">support</a>
                    values like <span class="e">refactor</span> or <span class="e">quickfix</span>.
                  • <span class="s">{triggerKind}</span>? (`integer`) The reason why code actions
                    were requested.
                • <span class="s">{filter}</span>? (`fun(x: lsp.CodeAction|lsp.Command):boolean`)
                  Predicate taking an <span class="e">CodeAction</span> and returning <a href="insert.txt.html#a" class="d">a</a> boolean.
                • <span class="s">{apply}</span>? (`boolean`) When set to <span class="e">true</span>, and there <a href="motion.txt.html#is" class="d">is</a> just
                  one remaining action (after filtering), the action <a href="motion.txt.html#is" class="d">is</a>
                  applied without user query.
                • <span class="s">{range}</span>? (`{start: integer[], end: integer[]}`) Range <a href="luaref.txt.html#for" class="d">for</a>
                  which code actions should be requested. If in visual mode
                  this <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to the active selection. Table must contain
                  <span class="e">start</span> and <span class="e">end</span> keys with <span class="s">{row,col}</span> tuples using mark-like
                  indexing. See <a href="api.txt.html#api-indexing" class="l">api-indexing</a>

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction</a>
      • vim.lsp.protocol.CodeActionTriggerKind

declaration({opts})                                <span id="vim.lsp.buf.declaration%28%29" class="t">vim.lsp.buf.declaration()</span>
    Jumps to the declaration of the symbol under the cursor.

<span class="h">    Note: </span>
      • Many servers <a href="diff.txt.html#do" class="d">do</a> not implement this method. Generally, see
        <a href="lsp.txt.html#vim.lsp.buf.definition%28%29" class="l">vim.lsp.buf.definition()</a> instead.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`vim.lsp.LocationOpts?`) See <a href="lsp.txt.html#vim.lsp.LocationOpts" class="l">vim.lsp.LocationOpts</a><a href="repeat.txt.html#." class="d">.</a>

definition({opts})                                  <span id="vim.lsp.buf.definition%28%29" class="t">vim.lsp.buf.definition()</span>
    Jumps to the definition of the symbol under the cursor.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`vim.lsp.LocationOpts?`) See <a href="lsp.txt.html#vim.lsp.LocationOpts" class="l">vim.lsp.LocationOpts</a><a href="repeat.txt.html#." class="d">.</a>

document_highlight()                        <span id="vim.lsp.buf.document_highlight%28%29" class="t">vim.lsp.buf.document_highlight()</span>
    Send request to the server to resolve document highlights <a href="luaref.txt.html#for" class="d">for</a> the current
    text document position. This request can be triggered by <a href="insert.txt.html#a" class="d">a</a> key <a href="map.txt.html#mapping" class="d">mapping</a> or
    by <a href="autocmd.txt.html#events" class="d">events</a> such <a href="motion.txt.html#as" class="d">as</a> <span class="e">CursorHold</span>, e.g.: 
<span class="e">        autocmd CursorHold  &lt;buffer&gt; lua vim.lsp.buf.document_highlight()</span>
<span class="e">        autocmd CursorHoldI &lt;buffer&gt; lua vim.lsp.buf.document_highlight()</span>
<span class="e">        autocmd CursorMoved &lt;buffer&gt; lua vim.lsp.buf.clear_references()</span>


    <span class="n">Note:</span> Usage of <a href="lsp.txt.html#vim.lsp.buf.document_highlight%28%29" class="l">vim.lsp.buf.document_highlight()</a> requires the following
    highlight groups to be defined or you won't be able to see the actual
    highlights. <a href="lsp.txt.html#hl-LspReferenceText" class="l">hl-LspReferenceText</a> <a href="lsp.txt.html#hl-LspReferenceRead" class="l">hl-LspReferenceRead</a>
    <a href="lsp.txt.html#hl-LspReferenceWrite" class="l">hl-LspReferenceWrite</a>

document_symbol({opts})                        <span id="vim.lsp.buf.document_symbol%28%29" class="t">vim.lsp.buf.document_symbol()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all symbols in the current buffer in the <a href="quickfix.txt.html#location-list" class="l">location-list</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`vim.lsp.ListOpts?`) See <a href="lsp.txt.html#vim.lsp.ListOpts" class="l">vim.lsp.ListOpts</a><a href="repeat.txt.html#." class="d">.</a>

format({opts})                                          <span id="vim.lsp.buf.format%28%29" class="t">vim.lsp.buf.format()</span>
    Formats <a href="insert.txt.html#a" class="d">a</a> buffer using the attached (and optionally filtered) language
    server clients.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{formatting_options}</span>? (`table`) Can be used to specify
                  FormattingOptions. Some unspecified <a href="options.txt.html#options" class="d">options</a> will be
                  automatically derived from the current Nvim options. See
                  <a class="u" href="https://microsoft.github.io/language-server-protocol/specification/#formattingOptions">https://microsoft.github.io/language-server-protocol/specification/#formattingOptions</a>
                • <span class="s">{timeout_ms}</span>? (`integer`, default: <span class="e">1000</span>) Time in
                  milliseconds to block <a href="luaref.txt.html#for" class="d">for</a> <a href="change.txt.html#formatting" class="d">formatting</a> requests. No effect if
                  async=true.
                • <span class="s">{bufnr}</span>? (`integer`, default: current buffer) Restrict
                  <a href="change.txt.html#formatting" class="d">formatting</a> to the clients attached to the given buffer.
                • <span class="s">{filter}</span>? (`fun(client: vim.lsp.Client): boolean?`)
                  Predicate used to <a href="change.txt.html#filter" class="d">filter</a> clients. Receives <a href="insert.txt.html#a" class="d">a</a> client <a href="motion.txt.html#as" class="d">as</a>
                  argument and must return <a href="insert.txt.html#a" class="d">a</a> boolean. Clients matching the
                  predicate are included. Example: 
<span class="e">                    -- Never request typescript-language-server for formatting</span>
<span class="e">                    vim.lsp.buf.format {</span>
<span class="e">                      filter = function(client) return client.name ~= "ts_ls" end</span>
<span class="e">                    }</span>

                • <span class="s">{async}</span>? (`boolean`, default: false) If true the <a href="vimeval.txt.html#method" class="d">method</a>
                  won't block. Editing the buffer while <a href="change.txt.html#formatting" class="d">formatting</a>
                  asynchronous can lead to unexpected changes.
                • <span class="s">{id}</span>? (`integer`) Restrict <a href="change.txt.html#formatting" class="d">formatting</a> to the client with ID
                  (client.id) matching this field.
                • <span class="s">{name}</span>? (`string`) Restrict <a href="change.txt.html#formatting" class="d">formatting</a> to the client with
                  name (client.name) matching this field.
                • <span class="s">{range}</span>?
                  (`{start:[integer,integer],end:[integer, integer]}|<span class="s">{start:[integer,integer],end:[integer,integer]}</span>[]`,
                  default: current selection in visual mode, <span class="e">nil</span> in other
                  modes, <a href="change.txt.html#formatting" class="d">formatting</a> the full buffer) Range to format. Table
                  must contain <span class="e">start</span> and <span class="e">end</span> keys with <span class="s">{row,col}</span> tuples
                  using (1,0) indexing. Can also be <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of tables that
                  contain <span class="e">start</span> and <span class="e">end</span> keys <a href="motion.txt.html#as" class="d">as</a> described above, in which
                  <a href="change.txt.html#case" class="d">case</a> <span class="e">textDocument/rangesFormatting</span> <a href="support.txt.html#support" class="d">support</a> <a href="motion.txt.html#is" class="d">is</a> required.

hover({config})                                          <span id="vim.lsp.buf.hover%28%29" class="t">vim.lsp.buf.hover()</span>
    Displays hover information about the symbol under the cursor in <a href="insert.txt.html#a" class="d">a</a> floating
    window. The <a href="windows.txt.html#window" class="d">window</a> will be dismissed on cursor move. Calling the function
    twice will jump into the floating <a href="windows.txt.html#window" class="d">window</a> (thus by default, "KK" will open
    the hover <a href="windows.txt.html#window" class="d">window</a> and focus it). In the floating window, all commands and
    mappings are available <a href="motion.txt.html#as" class="d">as</a> usual, except that "<a href="repeat.txt.html#q" class="d">q</a>" dismisses the window. You
    can scroll the contents the same <a href="motion.txt.html#as" class="d">as</a> you would any other buffer.

    <span class="n">Note:</span> to disable hover highlights, add the following to your config: 
<span class="e">        vim.api.nvim_create_autocmd('ColorScheme', {</span>
<span class="e">          callback = function()</span>
<span class="e">            vim.api.nvim_set_hl(0, 'LspReferenceTarget', {})</span>
<span class="e">          end,</span>
<span class="e">        })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{config}</span>  (`vim.lsp.buf.hover.Opts?`) See <a href="lsp.txt.html#vim.lsp.buf.hover.Opts" class="l">vim.lsp.buf.hover.Opts</a><a href="repeat.txt.html#." class="d">.</a>

implementation({opts})                          <span id="vim.lsp.buf.implementation%28%29" class="t">vim.lsp.buf.implementation()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all the implementations <a href="luaref.txt.html#for" class="d">for</a> the symbol under the cursor in the
    <a href="quickfix.txt.html#quickfix" class="d">quickfix</a> window.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`vim.lsp.LocationOpts?`) See <a href="lsp.txt.html#vim.lsp.LocationOpts" class="l">vim.lsp.LocationOpts</a><a href="repeat.txt.html#." class="d">.</a>

incoming_calls()                                <span id="vim.lsp.buf.incoming_calls%28%29" class="t">vim.lsp.buf.incoming_calls()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all the call sites of the symbol under the cursor in the <a href="quickfix.txt.html#quickfix" class="l">quickfix</a>
    window. If the symbol can resolve to multiple items, the user can pick one
    in the <a href="vimfn.txt.html#inputlist%28%29" class="l">inputlist()</a><a href="repeat.txt.html#." class="d">.</a>

list_workspace_folders()                <span id="vim.lsp.buf.list_workspace_folders%28%29" class="t">vim.lsp.buf.list_workspace_folders()</span>
    <a href="vimeval.txt.html#List" class="d">List</a> workspace folders.

outgoing_calls()                                <span id="vim.lsp.buf.outgoing_calls%28%29" class="t">vim.lsp.buf.outgoing_calls()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all the items that are called by the symbol under the cursor in the
    <a href="quickfix.txt.html#quickfix" class="l">quickfix</a> window. If the symbol can resolve to multiple items, the user
    can pick one in the <a href="vimfn.txt.html#inputlist%28%29" class="l">inputlist()</a><a href="repeat.txt.html#." class="d">.</a>

references({context}, <span class="s">{opts}</span>)                       <span id="vim.lsp.buf.references%28%29" class="t">vim.lsp.buf.references()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all the references to the symbol under the cursor in the <a href="quickfix.txt.html#quickfix" class="d">quickfix</a>
    window.

<span class="h">    Parameters: </span>
      • <span class="s">{context}</span>  (`lsp.ReferenceContext?`) <a href="repeat.txt.html#Context" class="d">Context</a> <a href="luaref.txt.html#for" class="d">for</a> the request
      • <span class="s">{opts}</span>     (`vim.lsp.ListOpts?`) See <a href="lsp.txt.html#vim.lsp.ListOpts" class="l">vim.lsp.ListOpts</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references</a>

                                       <span id="vim.lsp.buf.remove_workspace_folder%28%29" class="t">vim.lsp.buf.remove_workspace_folder()</span>
remove_workspace_folder({workspace_folder})
    Remove the folder <a href="motion.txt.html#at" class="d">at</a> path from the workspace folders. If <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> not
    provided, the user will be prompted <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> path using <a href="vimfn.txt.html#input%28%29" class="l">input()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{workspace_folder}</span>  (`string?`)

rename({new_name}, <span class="s">{opts}</span>)                              <span id="vim.lsp.buf.rename%28%29" class="t">vim.lsp.buf.rename()</span>
    Renames all references to the symbol under the cursor.

<span class="h">    Parameters: </span>
      • <span class="s">{new_name}</span>  (`string?`) If not provided, the user will be prompted <a href="luaref.txt.html#for" class="d">for</a>
                    <a href="insert.txt.html#a" class="d">a</a> new name using <a href="lua.txt.html#vim.ui.input%28%29" class="l">vim.ui.input()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{opts}</span>      (`table?`) Additional options:
                    • <span class="s">{filter}</span>? (`fun(client: vim.lsp.Client): boolean?`)
                      Predicate used to <a href="change.txt.html#filter" class="d">filter</a> clients. Receives <a href="insert.txt.html#a" class="d">a</a> client <a href="motion.txt.html#as" class="d">as</a>
                      argument and must return <a href="insert.txt.html#a" class="d">a</a> boolean. Clients matching the
                      predicate are included.
                    • <span class="s">{name}</span>? (`string`) Restrict clients used <a href="luaref.txt.html#for" class="d">for</a> rename to
                      ones where client.name matches this field.
                    • <span class="s">{bufnr}</span>? (`integer`) (default: current buffer)

signature_help({config})                        <span id="vim.lsp.buf.signature_help%28%29" class="t">vim.lsp.buf.signature_help()</span>
    Displays signature information about the symbol under the cursor in <a href="insert.txt.html#a" class="d">a</a>
    floating window.

<span class="h">    Parameters: </span>
      • <span class="s">{config}</span>  (`vim.lsp.buf.signature_help.Opts?`) See
                  <a href="lsp.txt.html#vim.lsp.buf.signature_help.Opts" class="l">vim.lsp.buf.signature_help.Opts</a><a href="repeat.txt.html#." class="d">.</a>

type_definition({opts})                        <span id="vim.lsp.buf.type_definition%28%29" class="t">vim.lsp.buf.type_definition()</span>
    Jumps to the definition of the type of the symbol under the cursor.

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`vim.lsp.LocationOpts?`) See <a href="lsp.txt.html#vim.lsp.LocationOpts" class="l">vim.lsp.LocationOpts</a><a href="repeat.txt.html#." class="d">.</a>

typehierarchy({kind})                            <span id="vim.lsp.buf.typehierarchy%28%29" class="t">vim.lsp.buf.typehierarchy()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all the subtypes or supertypes of the symbol under the cursor in the
    <a href="quickfix.txt.html#quickfix" class="l">quickfix</a> window. If the symbol can resolve to multiple items, the user
    can pick one using <a href="lua.txt.html#vim.ui.select%28%29" class="l">vim.ui.select()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{kind}</span>  (`"subtypes"|"supertypes"<a href="motion.txt.html#%60%29" class="d">`)</a>

workspace_symbol({query}, <span class="s">{opts}</span>)             <span id="vim.lsp.buf.workspace_symbol%28%29" class="t">vim.lsp.buf.workspace_symbol()</span>
    <a href="vimeval.txt.html#Lists" class="d">Lists</a> all symbols in the current workspace in the <a href="quickfix.txt.html#quickfix" class="d">quickfix</a> window.

    The <a href="vimeval.txt.html#list" class="d">list</a> <a href="motion.txt.html#is" class="d">is</a> filtered against <span class="s">{query}</span>; if the argument <a href="motion.txt.html#is" class="d">is</a> omitted from the
    call, the user <a href="motion.txt.html#is" class="d">is</a> prompted to enter <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> on the command line. An empty
    <a href="vimeval.txt.html#string" class="d">string</a> means no filtering <a href="motion.txt.html#is" class="d">is</a> done.

<span class="h">    Parameters: </span>
      • <span class="s">{query}</span>  (`string?`) optional
      • <span class="s">{opts}</span>   (`vim.lsp.ListOpts?`) See <a href="lsp.txt.html#vim.lsp.ListOpts" class="l">vim.lsp.ListOpts</a><a href="repeat.txt.html#." class="d">.</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.diagnostic                                <span id="lsp-diagnostic" class="t">lsp-diagnostic</span>

from({diagnostics})                                <span id="vim.lsp.diagnostic.from%28%29" class="t">vim.lsp.diagnostic.from()</span>
    Converts the input <span class="e">vim.Diagnostic</span>s to <a href="lsp.txt.html#LSP" class="d">LSP</a> diagnostics.

<span class="h">    Parameters: </span>
      • <span class="s">{diagnostics}</span>  (`vim.Diagnostic[]`)

<span class="h">    Return: </span>
        (`lsp.Diagnostic[]`)

                                          <span id="vim.lsp.diagnostic.get_namespace%28%29" class="t">vim.lsp.diagnostic.get_namespace()</span>
get_namespace({client_id}, <span class="s">{is_pull}</span>)
    Get the diagnostic <a href="api.txt.html#namespace" class="d">namespace</a> associated with an <a href="lsp.txt.html#LSP" class="d">LSP</a> client
    <a href="diagnostic.txt.html#vim.diagnostic" class="l">vim.diagnostic</a> <a href="luaref.txt.html#for" class="d">for</a> diagnostics

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer`) The id of the <a href="lsp.txt.html#LSP" class="d">LSP</a> client
      • <span class="s">{is_pull}</span>    (`boolean?`) Whether the <a href="api.txt.html#namespace" class="d">namespace</a> <a href="motion.txt.html#is" class="d">is</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> pull or push
                     client. Defaults to push

                                          <span id="vim.lsp.diagnostic.on_diagnostic%28%29" class="t">vim.lsp.diagnostic.on_diagnostic()</span>
on_diagnostic({error}, <span class="s">{result}</span>, <span class="s">{ctx}</span>)
    <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="vimeval.txt.html#method" class="d">method</a> "textDocument/diagnostic"

    See <a href="diagnostic.txt.html#vim.diagnostic.config%28%29" class="l">vim.diagnostic.config()</a> <a href="luaref.txt.html#for" class="d">for</a> configuration options.

<span class="h">    Parameters: </span>
      • <span class="s">{error}</span>   (`lsp.ResponseError?`)
      • <span class="s">{result}</span>  (`lsp.DocumentDiagnosticReport`)
      • <span class="s">{ctx}</span>     (`lsp.HandlerContext`)

                                 <span id="vim.lsp.diagnostic.on_publish_diagnostics%28%29" class="t">vim.lsp.diagnostic.on_publish_diagnostics()</span>
on_publish_diagnostics({_}, <span class="s">{params}</span>, <span class="s">{ctx}</span>)
    <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="vimeval.txt.html#method" class="d">method</a> "textDocument/publishDiagnostics"

    See <a href="diagnostic.txt.html#vim.diagnostic.config%28%29" class="l">vim.diagnostic.config()</a> <a href="luaref.txt.html#for" class="d">for</a> configuration options.

<span class="h">    Parameters: </span>
      • <span class="s">{params}</span>  (`lsp.PublishDiagnosticsParams`)
      • <span class="s">{ctx}</span>     (`lsp.HandlerContext`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.codelens                                    <span id="lsp-codelens" class="t">lsp-codelens</span>

clear({client_id}, <span class="s">{bufnr}</span>)                         <span id="vim.lsp.codelens.clear%28%29" class="t">vim.lsp.codelens.clear()</span>
    Clear the lenses

<span class="h">    Parameters: </span>
      • <span class="s">{client_id}</span>  (`integer?`) <a href="change.txt.html#filter" class="d">filter</a> by client_id. All clients if nil
      • <span class="s">{bufnr}</span>      (`integer?`) <a href="change.txt.html#filter" class="d">filter</a> by buffer. All <a href="windows.txt.html#buffers" class="d">buffers</a> if nil, <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a>
                     current buffer

display({lenses}, <span class="s">{bufnr}</span>, <span class="s">{client_id}</span>)           <span id="vim.lsp.codelens.display%28%29" class="t">vim.lsp.codelens.display()</span>
    Display the lenses using virtual text

<span class="h">    Parameters: </span>
      • <span class="s">{lenses}</span>     (`lsp.CodeLens[]?`) lenses to display
      • <span class="s">{bufnr}</span>      (`integer`)
      • <span class="s">{client_id}</span>  (`integer`)

get({bufnr})                                          <span id="vim.lsp.codelens.get%28%29" class="t">vim.lsp.codelens.get()</span>
    Return all lenses <a href="luaref.txt.html#for" class="d">for</a> the given buffer

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer`) Buffer number. <a href="motion.txt.html#0" class="d">0</a> can be used <a href="luaref.txt.html#for" class="d">for</a> the current
                 buffer.

<span class="h">    Return: </span>
        (`lsp.CodeLens[]`)

on_codelens({err}, <span class="s">{result}</span>, <span class="s">{ctx}</span>)           <span id="vim.lsp.codelens.on_codelens%28%29" class="t">vim.lsp.codelens.on_codelens()</span>
    <a href="lsp.txt.html#lsp-handler" class="l">lsp-handler</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="vimeval.txt.html#method" class="d">method</a> <span class="e">textDocument/codeLens</span>

<span class="h">    Parameters: </span>
      • <span class="s">{err}</span>     (`lsp.ResponseError?`)
      • <span class="s">{result}</span>  (`lsp.CodeLens[]`)
      • <span class="s">{ctx}</span>     (`lsp.HandlerContext`)

refresh({opts})                                   <span id="vim.lsp.codelens.refresh%28%29" class="t">vim.lsp.codelens.refresh()</span>
    Refresh the lenses.

    It <a href="motion.txt.html#is" class="d">is</a> recommended to trigger this using an <a href="autocmd.txt.html#autocmd" class="d">autocmd</a> or via keymap.

    Example: 
<span class="e">        autocmd BufEnter,CursorHold,InsertLeave &lt;buffer&gt; lua vim.lsp.codelens.refresh({ bufnr = 0 })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) Optional fields
                • <span class="s">{bufnr}</span> (`integer?`) <a href="change.txt.html#filter" class="d">filter</a> by buffer. All <a href="windows.txt.html#buffers" class="d">buffers</a> if nil, <a href="motion.txt.html#0" class="d">0</a>
                  <a href="luaref.txt.html#for" class="d">for</a> current buffer

run()                                                 <span id="vim.lsp.codelens.run%28%29" class="t">vim.lsp.codelens.run()</span>
    Run the code lens in the current line

save({lenses}, <span class="s">{bufnr}</span>, <span class="s">{client_id}</span>)                 <span id="vim.lsp.codelens.save%28%29" class="t">vim.lsp.codelens.save()</span>
    Store lenses <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific buffer and client

<span class="h">    Parameters: </span>
      • <span class="s">{lenses}</span>     (`lsp.CodeLens[]?`) lenses to store
      • <span class="s">{bufnr}</span>      (`integer`)
      • <span class="s">{client_id}</span>  (`integer`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.completion                                <span id="lsp-completion" class="t">lsp-completion</span>

The <span class="e">vim.lsp.completion</span> module enables insert-mode completion driven by an
<a href="lsp.txt.html#LSP" class="d">LSP</a> server. Call <span class="e">enable()</span> to make <a href="motion.txt.html#it" class="d">it</a> available through Nvim builtin
completion (via the <a href="autocmd.txt.html#CompleteDone" class="l">CompleteDone</a> event). Specify <span class="e">autotrigger=true</span> to
activate "auto-completion" when you type any of the server-defined
<span class="e">triggerCharacters</span>. Use <a href="scroll.txt.html#CTRL-Y" class="k">CTRL-Y</a> to select an item from the completion menu.
<a href="insert.txt.html#complete_CTRL-Y" class="l">complete_CTRL-Y</a>

Example: activate LSP-driven auto-completion: 
<span class="e">    -- Works best with completeopt=noselect.</span>
<span class="e">    -- Use CTRL-Y to select an item. |complete_CTRL-Y|</span>
<span class="e">    vim.cmd[[set completeopt+=menuone,noselect,popup]]</span>
<span class="e">    vim.lsp.start({</span>
<span class="e">      name = 'ts_ls',</span>
<span class="e">      cmd = …,</span>
<span class="e">      on_attach = function(client, bufnr)</span>
<span class="e">        vim.lsp.completion.enable(true, client.id, bufnr, {</span>
<span class="e">          autotrigger = true,</span>
<span class="e">          convert = function(item)</span>
<span class="e">            return { abbr = item.label:gsub('%b()', '') }</span>
<span class="e">          end,</span>
<span class="e">        })</span>
<span class="e">      end,</span>
<span class="e">    })</span>


                                                          <span id="lsp-autocompletion" class="t">lsp-autocompletion</span>

The <a href="lsp.txt.html#LSP" class="d">LSP</a> <span class="e">triggerCharacters</span> field decides when to trigger autocompletion. If
you want to trigger on EVERY keypress you can either:
• Extend <span class="e">client.server_capabilities.completionProvider.triggerCharacters</span> on
  <span class="e">LspAttach</span>, before you call
  `vim.lsp.completion.enable(… <span class="s">{autotrigger=true}</span>)`. See the <a href="lsp.txt.html#lsp-attach" class="l">lsp-attach</a>
  example.
• Call <span class="e">vim.lsp.completion.get()</span> from the handler described <a href="motion.txt.html#at" class="d">at</a>
  <a href="insert.txt.html#compl-autocomplete" class="l">compl-autocomplete</a><a href="repeat.txt.html#." class="d">.</a>


                                                 <span id="vim.lsp.completion.enable%28%29" class="t">vim.lsp.completion.enable()</span>
enable({enable}, <span class="s">{client_id}</span>, <span class="s">{bufnr}</span>, <span class="s">{opts}</span>)
    Enables or disables completions from the given language client in the
    given buffer. Effects of enabling completions are:
    • Calling <a href="lsp.txt.html#vim.lsp.completion.get%28%29" class="l">vim.lsp.completion.get()</a> uses the enabled clients to retrieve
      completion candidates
    • Accepting <a href="insert.txt.html#a" class="d">a</a> completion candidate using <span class="e">&lt;c-y&gt;</span> applies side effects like
      expanding snippets, text edits (e.g. <a href="insert.txt.html#insert" class="d">insert</a> import statements) and
      executing associated commands. This works <a href="luaref.txt.html#for" class="d">for</a> completions triggered via
      autotrigger, omnifunc or completion.get()

    Example: <a href="lsp.txt.html#lsp-attach" class="l">lsp-attach</a> <a href="lsp.txt.html#lsp-completion" class="l">lsp-completion</a>

    <span class="n">Note:</span> the behavior of <span class="e">autotrigger=true</span> <a href="motion.txt.html#is" class="d">is</a> controlled by the <a href="lsp.txt.html#LSP" class="d">LSP</a>
    <span class="e">triggerCharacters</span> field. You can override <a href="motion.txt.html#it" class="d">it</a> on LspAttach, see
    <a href="lsp.txt.html#lsp-autocompletion" class="l">lsp-autocompletion</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{enable}</span>     (`boolean`) True to enable, false to disable
      • <span class="s">{client_id}</span>  (`integer`) Client ID
      • <span class="s">{bufnr}</span>      (`integer`) Buffer handle, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> the current buffer
      • <span class="s">{opts}</span>       (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                     • <span class="s">{autotrigger}</span>? (`boolean`) (default: false) When true,
                       completion triggers automatically based on the server's
                       <span class="e">triggerCharacters</span>.
                     • <span class="s">{convert}</span>? (`fun(item: lsp.CompletionItem): table`)
                       Transforms an <a href="lsp.txt.html#LSP" class="d">LSP</a> CompletionItem to <a href="insert.txt.html#complete-items" class="l">complete-items</a><a href="repeat.txt.html#." class="d">.</a>

get({opts})                                         <span id="vim.lsp.completion.get%28%29" class="t">vim.lsp.completion.get()</span>
    Triggers <a href="lsp.txt.html#LSP" class="d">LSP</a> completion once in the current buffer, if <a href="lsp.txt.html#LSP" class="d">LSP</a> completion <a href="motion.txt.html#is" class="d">is</a>
    enabled (see <a href="lsp.txt.html#lsp-attach" class="l">lsp-attach</a> <a href="lsp.txt.html#lsp-completion" class="l">lsp-completion</a>).

    Used by the default <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="insert.txt.html#omnicompletion" class="l">omnicompletion</a> <a href="provider.txt.html#provider" class="d">provider</a> <a href="lsp.txt.html#vim.lsp.omnifunc%28%29" class="l">vim.lsp.omnifunc()</a><a href="motion.txt.html#%2C" class="d">,</a>
    thus <a href="insert.txt.html#i_CTRL-X_CTRL-O" class="l">i_CTRL-X_CTRL-O</a> invokes this in LSP-enabled buffers. Use <a href="scroll.txt.html#CTRL-Y" class="k">CTRL-Y</a> to
    select an item from the completion menu. <a href="insert.txt.html#complete_CTRL-Y" class="l">complete_CTRL-Y</a>

    To invoke manually with <span class="k">CTRL-s</span>pace, use this mapping: 
<span class="e">        -- Use CTRL-space to trigger LSP completion.</span>
<span class="e">        -- Use CTRL-Y to select an item. |complete_CTRL-Y|</span>
<span class="e">        vim.keymap.set('i', '&lt;c-space&gt;', function()</span>
<span class="e">          vim.lsp.completion.get()</span>
<span class="e">        end)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{ctx}</span>? (`lsp.CompletionContext`) Completion context.
                  Defaults to <a href="insert.txt.html#a" class="d">a</a> trigger kind of <span class="e">invoked</span>.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.inlay_hint                                <span id="lsp-inlay_hint" class="t">lsp-inlay_hint</span>

enable({enable}, <span class="s">{filter}</span>)                       <span id="vim.lsp.inlay_hint.enable%28%29" class="t">vim.lsp.inlay_hint.enable()</span>
    Enables or disables inlay hints <a href="luaref.txt.html#for" class="d">for</a> the <span class="s">{filter}</span>ed scope.

    To "<a href="options.txt.html#toggle" class="d">toggle</a>"<a href="motion.txt.html#%2C" class="d">,</a> pass the <a href="syntax.txt.html#inverse" class="d">inverse</a> of <span class="e">is_enabled()</span>: 
<span class="e">        vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled())</span>


<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{enable}</span>  (`boolean?`) true/nil to enable, false to disable
      • <span class="s">{filter}</span>  (`table?`) Optional filters <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="motion.txt.html#%2C" class="d">,</a> or <span class="e">nil</span> <a href="luaref.txt.html#for" class="d">for</a> all.
                  • <span class="s">{bufnr}</span> (`integer?`) Buffer number, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current
                    buffer, or nil <a href="luaref.txt.html#for" class="d">for</a> all.

get({filter})                                       <span id="vim.lsp.inlay_hint.get%28%29" class="t">vim.lsp.inlay_hint.get()</span>
    Get the <a href="vimeval.txt.html#list" class="d">list</a> of inlay hints, (optionally) restricted by buffer or range.

    Example usage: 
<span class="e">        local hint = vim.lsp.inlay_hint.get({ bufnr = 0 })[1] -- 0 for current buffer</span>
<span class="e"></span>
<span class="e">        local client = vim.lsp.get_client_by_id(hint.client_id)</span>
<span class="e">        local resp = client:request_sync('inlayHint/resolve', hint.inlay_hint, 100, 0)</span>
<span class="e">        local resolved_hint = assert(resp and resp.result, resp.err)</span>
<span class="e">        vim.lsp.util.apply_text_edits(resolved_hint.textEdits, 0, client.encoding)</span>
<span class="e"></span>
<span class="e">        location = resolved_hint.label[1].location</span>
<span class="e">        client:request('textDocument/hover', {</span>
<span class="e">          textDocument = { uri = location.uri },</span>
<span class="e">          position = location.range.start,</span>
<span class="e">        })</span>


<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{filter}</span>  (`table?`) Optional filters <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="cmdline.txt.html#%3A" class="d">:</a>
                  • <span class="s">{bufnr}</span> (`integer?`)
                  • <span class="s">{range}</span> (`lsp.Range?`)

<span class="h">    Return: </span>
        (`table[]`) <a href="insert.txt.html#A" class="d">A</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="index.txt.html#objects" class="d">objects</a> with the following fields:
        • <span class="s">{bufnr}</span> (`integer`)
        • <span class="s">{client_id}</span> (`integer`)
        • <span class="s">{inlay_hint}</span> (`lsp.InlayHint`)

is_enabled({filter})                         <span id="vim.lsp.inlay_hint.is_enabled%28%29" class="t">vim.lsp.inlay_hint.is_enabled()</span>
    Query whether inlay hint <a href="motion.txt.html#is" class="d">is</a> enabled in the <span class="s">{filter}</span>ed scope

<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{filter}</span>  (`table?`) Optional filters <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="motion.txt.html#%2C" class="d">,</a> or <span class="e">nil</span> <a href="luaref.txt.html#for" class="d">for</a> all.
                  • <span class="s">{bufnr}</span> (`integer?`) Buffer number, or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current
                    buffer, or nil <a href="luaref.txt.html#for" class="d">for</a> all.

<span class="h">    Return: </span>
        (`boolean`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.semantic_tokens                      <span id="lsp-semantic_tokens" class="t">lsp-semantic_tokens</span>

force_refresh({bufnr})               <span id="vim.lsp.semantic_tokens.force_refresh%28%29" class="t">vim.lsp.semantic_tokens.force_refresh()</span>
    Force <a href="insert.txt.html#a" class="d">a</a> refresh of all semantic tokens

    Only has an effect if the buffer <a href="motion.txt.html#is" class="d">is</a> currently active <a href="luaref.txt.html#for" class="d">for</a> semantic token
    highlighting <a href="motion.txt.html#%28" class="d">(</a><a href="lsp.txt.html#vim.lsp.semantic_tokens.start%28%29" class="l">vim.lsp.semantic_tokens.start()</a> has been called <a href="luaref.txt.html#for" class="d">for</a> it)

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer?`) <a href="change.txt.html#filter" class="d">filter</a> by buffer. All <a href="windows.txt.html#buffers" class="d">buffers</a> if nil, current
                 buffer if <a href="motion.txt.html#0" class="d">0</a>

                                        <span id="vim.lsp.semantic_tokens.get_at_pos%28%29" class="t">vim.lsp.semantic_tokens.get_at_pos()</span>
get_at_pos({bufnr}, <span class="s">{row}</span>, <span class="s">{col}</span>)
    Return the semantic token(s) <a href="motion.txt.html#at" class="d">at</a> the given position. If called without
    arguments, returns the token under the cursor.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer?`) Buffer number (0 <a href="luaref.txt.html#for" class="d">for</a> current buffer, default)
      • <span class="s">{row}</span>    (`integer?`) Position row (default cursor position)
      • <span class="s">{col}</span>    (`integer?`) Position column (default cursor position)

<span class="h">    Return: </span>
        (`table?`) <a href="vimeval.txt.html#List" class="d">List</a> of tokens <a href="motion.txt.html#at" class="d">at</a> position. Each token has the following
        fields:
        • line (integer) line number, 0-based
        • start_col (integer) start column, 0-based
        • end_col (integer) <a href="intro.txt.html#end" class="d">end</a> column, 0-based
        • type (string) token type <a href="motion.txt.html#as" class="d">as</a> string, e.g. "variable"
        • modifiers (table) token modifiers <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> set. E.g., <a href="motion.txt.html#%7B" class="d">{</a> static <a href="change.txt.html#%3D" class="d">=</a> true,
          readonly <a href="change.txt.html#%3D" class="d">=</a> true <a href="motion.txt.html#%7D" class="d">}</a>
        • client_id (integer)

                                   <span id="vim.lsp.semantic_tokens.highlight_token%28%29" class="t">vim.lsp.semantic_tokens.highlight_token()</span>
highlight_token({token}, <span class="s">{bufnr}</span>, <span class="s">{client_id}</span>, <span class="s">{hl_group}</span>, <span class="s">{opts}</span>)
    Highlight <a href="insert.txt.html#a" class="d">a</a> semantic token.

    Apply an <a href="api.txt.html#extmark" class="d">extmark</a> with <a href="insert.txt.html#a" class="d">a</a> given highlight group <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> semantic token. The
    <a href="motion.txt.html#mark" class="d">mark</a> will be deleted by the semantic token engine when appropriate; <a href="luaref.txt.html#for" class="d">for</a>
    example, when the <a href="lsp.txt.html#LSP" class="d">LSP</a> sends updated tokens. This function <a href="motion.txt.html#is" class="d">is</a> intended <a href="luaref.txt.html#for" class="d">for</a>
    use inside <a href="lsp.txt.html#LspTokenUpdate" class="l">LspTokenUpdate</a> callbacks.

<span class="h">    Parameters: </span>
      • <span class="s">{token}</span>      (`table`) <a href="insert.txt.html#A" class="d">A</a> semantic token, found <a href="motion.txt.html#as" class="d">as</a> <span class="e">args.data.token</span> in
                     <a href="lsp.txt.html#LspTokenUpdate" class="l">LspTokenUpdate</a>
      • <span class="s">{bufnr}</span>      (`integer`) The buffer to highlight, or <span class="e">0</span> <a href="luaref.txt.html#for" class="d">for</a> current
                     buffer
      • <span class="s">{client_id}</span>  (`integer`) The ID of the <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a>
      • <span class="s">{hl_group}</span>   (`string`) Highlight group name
      • <span class="s">{opts}</span>       (`table?`) Optional parameters:
                     • <span class="s">{priority}</span>? (`integer`, default:
                       `vim.hl.priorities.semantic_tokens <a href="motion.txt.html#%2B" class="d">+</a> 3`) Priority <a href="luaref.txt.html#for" class="d">for</a>
                       the applied extmark.

start({bufnr}, <span class="s">{client_id}</span>, <span class="s">{opts}</span>)          <span id="vim.lsp.semantic_tokens.start%28%29" class="t">vim.lsp.semantic_tokens.start()</span>
    Start the semantic token highlighting engine <a href="luaref.txt.html#for" class="d">for</a> the given buffer with the
    given client. The client must already be attached to the buffer.

    <span class="n">NOTE:</span> This <a href="motion.txt.html#is" class="d">is</a> currently called automatically by
    <a href="lsp.txt.html#vim.lsp.buf_attach_client%28%29" class="l">vim.lsp.buf_attach_client()</a><a href="repeat.txt.html#." class="d">.</a> To opt-out of semantic highlighting with <a href="insert.txt.html#a" class="d">a</a>
    server that supports it, you can delete the semanticTokensProvider table
    from the <span class="s">{server_capabilities}</span> of your client in your <a href="lsp.txt.html#LspAttach" class="l">LspAttach</a> callback
    or your configuration's <span class="e">on_attach</span> callback: 
<span class="e">        client.server_capabilities.semanticTokensProvider = nil</span>


<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>      (`integer`) Buffer number, or <span class="e">0</span> <a href="luaref.txt.html#for" class="d">for</a> current buffer
      • <span class="s">{client_id}</span>  (`integer`) The ID of the <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a>
      • <span class="s">{opts}</span>       (`table?`) Optional keyword arguments
                     • debounce (integer, default: 200): Debounce token
                       requests to the server by the given number in
                       milliseconds

stop({bufnr}, <span class="s">{client_id}</span>)                    <span id="vim.lsp.semantic_tokens.stop%28%29" class="t">vim.lsp.semantic_tokens.stop()</span>
    Stop the semantic token highlighting engine <a href="luaref.txt.html#for" class="d">for</a> the given buffer with the
    given client.

    <span class="n">NOTE:</span> This <a href="motion.txt.html#is" class="d">is</a> automatically called by <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#LspDetach" class="l">LspDetach</a> <a href="autocmd.txt.html#autocmd" class="d">autocmd</a> that <a href="motion.txt.html#is" class="d">is</a> set up
    <a href="motion.txt.html#as" class="d">as</a> part of <span class="e">start()</span>, so you should only need this function to manually
    disengage the semantic token engine without fully detaching the <a href="lsp.txt.html#LSP" class="d">LSP</a> client
    from the buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>      (`integer`) Buffer number, or <span class="e">0</span> <a href="luaref.txt.html#for" class="d">for</a> current buffer
      • <span class="s">{client_id}</span>  (`integer`) The ID of the <a href="lsp.txt.html#vim.lsp.Client" class="l">vim.lsp.Client</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.util                                            <span id="lsp-util" class="t">lsp-util</span>

<span id="vim.lsp.util.open_floating_preview.Opts" class="t">vim.lsp.util.open_floating_preview.Opts</span>

<span class="h">    Fields: </span>
      • <span class="s">{height}</span>?        (`integer`) Height of floating <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{width}</span>?         (`integer`) Width of floating <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{wrap}</span>?          (`boolean`, default: <span class="e">true</span>) Wrap long lines
      • <span class="s">{wrap_at}</span>?       (`integer`) Character to wrap <a href="motion.txt.html#at" class="d">at</a> <a href="luaref.txt.html#for" class="d">for</a> computing height
                         when wrap <a href="motion.txt.html#is" class="d">is</a> enabled
      • <span class="s">{max_width}</span>?     (`integer`) Maximal width of floating <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{max_height}</span>?    (`integer`) Maximal height of floating <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{focus_id}</span>?      (`string`) If <a href="insert.txt.html#a" class="d">a</a> popup with this id <a href="motion.txt.html#is" class="d">is</a> opened, then
                         focus <a href="motion.txt.html#it" class="d">it</a>
      • <span class="s">{close_events}</span>?  (`table`) <a href="vimeval.txt.html#List" class="d">List</a> of <a href="autocmd.txt.html#events" class="d">events</a> that closes the floating
                         <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{focusable}</span>?     (`boolean`, default: <span class="e">true</span>) Make float focusable.
      • <span class="s">{focus}</span>?         (`boolean`, default: <span class="e">true</span>) If <span class="e">true</span>, and if
                         <span class="s">{focusable}</span> <a href="motion.txt.html#is" class="d">is</a> also <span class="e">true</span>, focus an existing
                         floating <a href="windows.txt.html#window" class="d">window</a> with the same <span class="s">{focus_id}</span>
      • <span class="s">{offset_x}</span>?      (`integer`) offset to add to <span class="e">col</span>
      • <span class="s">{offset_y}</span>?      (`integer`) offset to add to <span class="e">row</span>
      • <span class="s">{border}</span>?        (`string<span class="l">(string</span>[string,string])[]`) override
                         <span class="e">border</span>
      • <span class="s">{zindex}</span>?        (`integer`) override <span class="e">zindex</span>, <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to 50
      • <span class="s">{title}</span>?         (`string|[string,string][]`)
      • <span class="s">{title_pos}</span>?     (`'left'<span class="l">'center'</span><span class="o">'right'</span>`)
      • <span class="s">{relative}</span>?      (`'mouse'<span class="l">'cursor'</span><span class="o">'editor'</span>`) (default: <span class="e">'cursor'</span>)
      • <span class="s">{anchor_bias}</span>?   (`'auto'<span class="l">'above'</span><span class="o">'below'</span>`, default: <span class="e">'auto'</span>) Adjusts
                         placement relative to cursor.
                         • "auto"<a href="cmdline.txt.html#%3A" class="d">:</a> place <a href="windows.txt.html#window" class="d">window</a> based on which side of the
                           cursor has more lines
                         • "above"<a href="cmdline.txt.html#%3A" class="d">:</a> place the <a href="windows.txt.html#window" class="d">window</a> above the cursor unless
                           there are not enough lines to display the full
                           <a href="windows.txt.html#window" class="d">window</a> height.
                         • "below"<a href="cmdline.txt.html#%3A" class="d">:</a> place the <a href="windows.txt.html#window" class="d">window</a> below the cursor unless
                           there are not enough lines to display the full
                           <a href="windows.txt.html#window" class="d">window</a> height.


                                     <span id="vim.lsp.util.apply_text_document_edit%28%29" class="t">vim.lsp.util.apply_text_document_edit()</span>
apply_text_document_edit({text_document_edit}, <span class="s">{index}</span>, <span class="s">{position_encoding}</span>)
    Applies <a href="insert.txt.html#a" class="d">a</a> <span class="e">TextDocumentEdit</span>, which <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of changes to <a href="insert.txt.html#a" class="d">a</a> single
    document.

<span class="h">    Parameters: </span>
      • <span class="s">{text_document_edit}</span>  (`lsp.TextDocumentEdit`)
      • <span class="s">{index}</span>               (`integer?`) Optional <a href="index.txt.html#index" class="d">index</a> of the edit, if from
                              <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of edits (or nil, if not from <a href="insert.txt.html#a" class="d">a</a> list)
      • <span class="s">{position_encoding}</span>   (`'utf-8'<span class="l">'utf-16'</span>'utf-32'?`)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit</a>

                                             <span id="vim.lsp.util.apply_text_edits%28%29" class="t">vim.lsp.util.apply_text_edits()</span>
apply_text_edits({text_edits}, <span class="s">{bufnr}</span>, <span class="s">{position_encoding}</span>)
    Applies <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of text edits to <a href="insert.txt.html#a" class="d">a</a> buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{text_edits}</span>         (`lsp.TextEdit[]`)
      • <span class="s">{bufnr}</span>              (`integer`) Buffer id
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textEdit">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textEdit</a>

                                         <span id="vim.lsp.util.apply_workspace_edit%28%29" class="t">vim.lsp.util.apply_workspace_edit()</span>
apply_workspace_edit({workspace_edit}, <span class="s">{position_encoding}</span>)
    Applies <a href="insert.txt.html#a" class="d">a</a> <span class="e">WorkspaceEdit</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{workspace_edit}</span>     (`lsp.WorkspaceEdit`)
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`) (required)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_applyEdit">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_applyEdit</a>

buf_clear_references({bufnr})            <span id="vim.lsp.util.buf_clear_references%28%29" class="t">vim.lsp.util.buf_clear_references()</span>
    Removes document highlights from <a href="insert.txt.html#a" class="d">a</a> buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer?`) Buffer id

                                     <span id="vim.lsp.util.buf_highlight_references%28%29" class="t">vim.lsp.util.buf_highlight_references()</span>
buf_highlight_references({bufnr}, <span class="s">{references}</span>, <span class="s">{position_encoding}</span>)
    Shows <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of document highlights <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> certain buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>              (`integer`) Buffer id
      • <span class="s">{references}</span>         (`lsp.DocumentHighlight[]`) <a href="index.txt.html#objects" class="d">objects</a> to highlight
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specification/#textDocumentContentChangeEvent">https://microsoft.github.io/language-server-protocol/specification/#textDocumentContentChangeEvent</a>

                                             <span id="vim.lsp.util.character_offset%28%29" class="t">vim.lsp.util.character_offset()</span>
character_offset({buf}, <span class="s">{row}</span>, <span class="s">{col}</span>, <span class="s">{offset_encoding}</span>)
    Returns the UTF-32 and UTF-16 offsets <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> position in <a href="insert.txt.html#a" class="d">a</a> certain buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{buf}</span>              (`integer`) buffer number (0 <a href="luaref.txt.html#for" class="d">for</a> current)
      • <span class="s">{row}</span>              (`integer`) 0-indexed line
      • <span class="s">{col}</span>              (`integer`) 0-indexed byte offset in line
      • <span class="s">{offset_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'?`) <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to
                           <span class="e">offset_encoding</span> of first client of <span class="e">buf</span>

<span class="h">    Return: </span>
        (`integer`) <span class="e">offset_encoding</span> <a href="index.txt.html#index" class="d">index</a> of the character in line <span class="s">{row}</span>
        column <span class="s">{col}</span> in buffer <span class="s">{buf}</span>

                              <span id="vim.lsp.util.convert_input_to_markdown_lines%28%29" class="t">vim.lsp.util.convert_input_to_markdown_lines()</span>
convert_input_to_markdown_lines({input}, <span class="s">{contents}</span>)
    Converts any of <span class="e">MarkedString</span> | <span class="e">MarkedString[]</span> | <span class="e">MarkupContent</span> into <a href="insert.txt.html#a" class="d">a</a>
    <a href="vimeval.txt.html#list" class="d">list</a> of lines containing valid markdown. Useful to populate the hover
    <a href="windows.txt.html#window" class="d">window</a> <a href="luaref.txt.html#for" class="d">for</a> <span class="e">textDocument/hover</span>, <a href="luaref.txt.html#for" class="d">for</a> parsing the result of
    <span class="e">textDocument/signatureHelp</span>, and potentially others.

    <span class="n">Note</span> that if the input <a href="motion.txt.html#is" class="d">is</a> of type <span class="e">MarkupContent</span> and its kind <a href="motion.txt.html#is" class="d">is</a>
    <span class="e">plaintext</span>, then the corresponding value <a href="motion.txt.html#is" class="d">is</a> returned without further
    modifications.

<span class="h">    Parameters: </span>
      • <span class="s">{input}</span>     (`lsp.MarkedString<span class="l">lsp.MarkedString[]</span>lsp.MarkupContent`)
      • <span class="s">{contents}</span>  (`string[]?`) <a href="vimeval.txt.html#List" class="d">List</a> of strings to extend with converted
                    lines. Defaults to {}.

<span class="h">    Return: </span>
        (`string[]`) extended with lines of converted markdown.

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover</a>

                     <span id="vim.lsp.util.convert_signature_help_to_markdown_lines%28%29" class="t">vim.lsp.util.convert_signature_help_to_markdown_lines()</span>
convert_signature_help_to_markdown_lines({signature_help}, <span class="s">{ft}</span>, <span class="s">{triggers}</span>)
    Converts <span class="e">textDocument/signatureHelp</span> response to markdown lines.

<span class="h">    Parameters: </span>
      • <span class="s">{signature_help}</span>  (`lsp.SignatureHelp`) Response of
                          <span class="e">textDocument/SignatureHelp</span>
      • <span class="s">{ft}</span>              (`string?`) <a href="filetype.txt.html#filetype" class="d">filetype</a> that will be use <a href="motion.txt.html#as" class="d">as</a> the <span class="e">lang</span>
                          <a href="luaref.txt.html#for" class="d">for</a> the label markdown code block
      • <span class="s">{triggers}</span>        (`string[]?`) <a href="vimeval.txt.html#list" class="d">list</a> of trigger characters from the
                          <a href="lsp.txt.html#lsp" class="d">lsp</a> server. used to better determine parameter
                          offsets

<span class="h">    Return (multiple): </span>
        (`string[]?`) lines of converted markdown.
        (`Range4?`) highlight range <a href="luaref.txt.html#for" class="d">for</a> the active parameter

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp</a>

get_effective_tabstop({bufnr})          <span id="vim.lsp.util.get_effective_tabstop%28%29" class="t">vim.lsp.util.get_effective_tabstop()</span>
    Returns indentation size.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer?`) Buffer handle, <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current

<span class="h">    Return: </span>
        (`integer`) indentation size

<span class="h">    See also: </span>
      • <a href="options.txt.html#%27shiftwidth%27" class="o">'shiftwidth'</a>

                                           <span id="vim.lsp.util.locations_to_items%28%29" class="t">vim.lsp.util.locations_to_items()</span>
locations_to_items({locations}, <span class="s">{position_encoding}</span>)
    Returns the items with the byte position calculated correctly and in
    sorted order, <a href="luaref.txt.html#for" class="d">for</a> display in <a href="quickfix.txt.html#quickfix" class="d">quickfix</a> and location lists.

    The <span class="e">user_data</span> field of each resulting item will contain the original
    <span class="e">Location</span> or <span class="e">LocationLink</span> <a href="motion.txt.html#it" class="d">it</a> was computed from.

    The result can be passed to the <span class="s">{list}</span> argument of <a href="vimfn.txt.html#setqflist%28%29" class="l">setqflist()</a> or
    <a href="vimfn.txt.html#setloclist%28%29" class="l">setloclist()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{locations}</span>          (`lsp.Location[]|lsp.LocationLink[]`)
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'?`) default to first
                             client of buffer

<span class="h">    Return: </span>
        (`vim.quickfix.entry[]`) See <a href="vimfn.txt.html#setqflist%28%29" class="l">setqflist()</a> <a href="luaref.txt.html#for" class="d">for</a> the format

                                  <span id="vim.lsp.util.make_floating_popup_options%28%29" class="t">vim.lsp.util.make_floating_popup_options()</span>
make_floating_popup_options({width}, <span class="s">{height}</span>, <span class="s">{opts}</span>)
    Creates <a href="insert.txt.html#a" class="d">a</a> table with sensible default <a href="options.txt.html#options" class="d">options</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> floating window. The
    table can be passed to <a href="api.txt.html#nvim_open_win%28%29" class="l">nvim_open_win()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{width}</span>   (`integer`) <a href="windows.txt.html#window" class="d">window</a> width (in character cells)
      • <span class="s">{height}</span>  (`integer`) <a href="windows.txt.html#window" class="d">window</a> height (in character cells)
      • <span class="s">{opts}</span>    (`vim.lsp.util.open_floating_preview.Opts?`) See
                  <a href="lsp.txt.html#vim.lsp.util.open_floating_preview.Opts" class="l">vim.lsp.util.open_floating_preview.Opts</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return: </span>
        (`vim.api.keyset.win_config`)

                                       <span id="vim.lsp.util.make_formatting_params%28%29" class="t">vim.lsp.util.make_formatting_params()</span>
make_formatting_params({options})
    Creates <a href="insert.txt.html#a" class="d">a</a> <span class="e">DocumentFormattingParams</span> object <a href="luaref.txt.html#for" class="d">for</a> the current buffer and
    cursor position.

<span class="h">    Parameters: </span>
      • <span class="s">{options}</span>  (`lsp.FormattingOptions?`) with valid <span class="e">FormattingOptions</span>
                   entries

<span class="h">    Return: </span>
        (`lsp.DocumentFormattingParams`) object

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting</a>

                                      <span id="vim.lsp.util.make_given_range_params%28%29" class="t">vim.lsp.util.make_given_range_params()</span>
make_given_range_params({start_pos}, <span class="s">{end_pos}</span>, <span class="s">{bufnr}</span>, <span class="s">{position_encoding}</span>)
    Using the given range in the current buffer, creates an object that <a href="motion.txt.html#is" class="d">is</a>
    similar to <a href="lsp.txt.html#vim.lsp.util.make_range_params%28%29" class="l">vim.lsp.util.make_range_params()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{start_pos}</span>          (`[integer,integer]?`) <span class="s">{row,col}</span> mark-indexed
                             position. Defaults to the start of the last
                             visual selection.
      • <span class="s">{end_pos}</span>            (`[integer,integer]?`) <span class="s">{row,col}</span> mark-indexed
                             position. Defaults to the <a href="intro.txt.html#end" class="d">end</a> of the last visual
                             selection.
      • <span class="s">{bufnr}</span>              (`integer?`) buffer handle or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current,
                             <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`)

<span class="h">    Return: </span>
        (`{ textDocument: <span class="s">{ uri: lsp.DocumentUri }</span>, range: lsp.Range }`)

                                         <span id="vim.lsp.util.make_position_params%28%29" class="t">vim.lsp.util.make_position_params()</span>
make_position_params({window}, <span class="s">{position_encoding}</span>)
    Creates <a href="insert.txt.html#a" class="d">a</a> <span class="e">TextDocumentPositionParams</span> object <a href="luaref.txt.html#for" class="d">for</a> the current buffer and
    cursor position.

<span class="h">    Parameters: </span>
      • <span class="s">{window}</span>             (`integer?`) <a href="windows.txt.html#window-ID" class="l">window-ID</a> or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current,
                             <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'`)

<span class="h">    Return: </span>
        (`lsp.TextDocumentPositionParams`)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams</a>

                                            <span id="vim.lsp.util.make_range_params%28%29" class="t">vim.lsp.util.make_range_params()</span>
make_range_params({window}, <span class="s">{position_encoding}</span>)
    Using the current position in the current buffer, creates an object that
    can be used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> building block <a href="luaref.txt.html#for" class="d">for</a> several <a href="lsp.txt.html#LSP" class="d">LSP</a> requests, such <a href="motion.txt.html#as" class="d">as</a>
    <span class="e">textDocument/codeAction</span>, <span class="e">textDocument/colorPresentation</span>,
    <span class="e">textDocument/rangeFormatting</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{window}</span>             (`integer?`) <a href="windows.txt.html#window-ID" class="l">window-ID</a> or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current,
                             <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current
      • <span class="s">{position_encoding}</span>  (`"<a href="mbyte.txt.html#utf-8" class="d">utf-8</a>"|"utf-16"|"utf-32"<a href="motion.txt.html#%60%29" class="d">`)</a>

<span class="h">    Return: </span>
        (`{ textDocument: <span class="s">{ uri: lsp.DocumentUri }</span>, range: lsp.Range }`)

                                    <span id="vim.lsp.util.make_text_document_params%28%29" class="t">vim.lsp.util.make_text_document_params()</span>
make_text_document_params({bufnr})
    Creates <a href="insert.txt.html#a" class="d">a</a> <span class="e">TextDocumentIdentifier</span> object <a href="luaref.txt.html#for" class="d">for</a> the current buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer?`) Buffer handle, <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current

<span class="h">    Return: </span>
        (`lsp.TextDocumentIdentifier`)

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier">https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier</a>

                                        <span id="vim.lsp.util.make_workspace_params%28%29" class="t">vim.lsp.util.make_workspace_params()</span>
make_workspace_params({added}, <span class="s">{removed}</span>)
    Create the workspace params

<span class="h">    Parameters: </span>
      • <span class="s">{added}</span>    (`lsp.WorkspaceFolder[]`)
      • <span class="s">{removed}</span>  (`lsp.WorkspaceFolder[]`)

<span class="h">    Return: </span>
        (`lsp.WorkspaceFoldersChangeEvent`)

                                        <span id="vim.lsp.util.open_floating_preview%28%29" class="t">vim.lsp.util.open_floating_preview()</span>
open_floating_preview({contents}, <span class="s">{syntax}</span>, <span class="s">{opts}</span>)
    Shows contents in <a href="insert.txt.html#a" class="d">a</a> floating window.

<span class="h">    Parameters: </span>
      • <span class="s">{contents}</span>  (`table`) of lines to show in <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{syntax}</span>    (`string`) of <a href="syntax.txt.html#syntax" class="d">syntax</a> to set <a href="luaref.txt.html#for" class="d">for</a> opened buffer
      • <span class="s">{opts}</span>      (`vim.lsp.util.open_floating_preview.Opts?`) with optional
                    fields (additional keys are filtered with
                    <a href="lsp.txt.html#vim.lsp.util.make_floating_popup_options%28%29" class="l">vim.lsp.util.make_floating_popup_options()</a> before they
                    are passed on to <a href="api.txt.html#nvim_open_win%28%29" class="l">nvim_open_win()</a>). See
                    <a href="lsp.txt.html#vim.lsp.util.open_floating_preview.Opts" class="l">vim.lsp.util.open_floating_preview.Opts</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return (multiple): </span>
        (`integer`) bufnr of newly created float <a href="windows.txt.html#window" class="d">window</a>
        (`integer`) <a href="windows.txt.html#winid" class="d">winid</a> of newly created float <a href="windows.txt.html#window" class="d">window</a> preview <a href="windows.txt.html#window" class="d">window</a>

preview_location({location}, <span class="s">{opts}</span>)         <span id="vim.lsp.util.preview_location%28%29" class="t">vim.lsp.util.preview_location()</span>
    Previews <a href="insert.txt.html#a" class="d">a</a> location in <a href="insert.txt.html#a" class="d">a</a> floating <a href="windows.txt.html#window" class="d">window</a>

    behavior depends on type of location:
    • <a href="luaref.txt.html#for" class="d">for</a> Location, range <a href="motion.txt.html#is" class="d">is</a> shown (e.g., function definition)
    • <a href="luaref.txt.html#for" class="d">for</a> LocationLink, targetRange <a href="motion.txt.html#is" class="d">is</a> shown (e.g., body of function
      definition)

<span class="h">    Parameters: </span>
      • <span class="s">{location}</span>  (`lsp.Location|lsp.LocationLink`)
      • <span class="s">{opts}</span>      (`vim.lsp.util.open_floating_preview.Opts?`) See
                    <a href="lsp.txt.html#vim.lsp.util.open_floating_preview.Opts" class="l">vim.lsp.util.open_floating_preview.Opts</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return (multiple): </span>
        (`integer?`) buffer id of float <a href="windows.txt.html#window" class="d">window</a>
        (`integer?`) <a href="windows.txt.html#window" class="d">window</a> id of float <a href="windows.txt.html#window" class="d">window</a>

rename({old_fname}, <span class="s">{new_fname}</span>, <span class="s">{opts}</span>)               <span id="vim.lsp.util.rename%28%29" class="t">vim.lsp.util.rename()</span>
    Rename old_fname to new_fname

    Existing <a href="windows.txt.html#buffers" class="d">buffers</a> are renamed <a href="motion.txt.html#as" class="d">as</a> well, while maintaining their bufnr.

    It deletes existing <a href="windows.txt.html#buffers" class="d">buffers</a> that conflict with the renamed file name only
    when
    • <span class="e">opts</span> requests overwriting; or
    • the conflicting <a href="windows.txt.html#buffers" class="d">buffers</a> are not loaded, so that <a href="change.txt.html#deleting" class="d">deleting</a> them does not
      result in data loss.

<span class="h">    Parameters: </span>
      • <span class="s">{old_fname}</span>  (`string`)
      • <span class="s">{new_fname}</span>  (`string`)
      • <span class="s">{opts}</span>       (`table?`) Options:
                     • <span class="s">{overwrite}</span>? (`boolean`)
                     • <span class="s">{ignoreIfExists}</span>? (`boolean`)

                                                <span id="vim.lsp.util.show_document%28%29" class="t">vim.lsp.util.show_document()</span>
show_document({location}, <span class="s">{position_encoding}</span>, <span class="s">{opts}</span>)
    Shows document and optionally jumps to the location.

<span class="h">    Parameters: </span>
      • <span class="s">{location}</span>           (`lsp.Location|lsp.LocationLink`)
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'?`)
      • <span class="s">{opts}</span>               (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                             • <span class="s">{reuse_win}</span>? (`boolean`) Jump to existing
                               <a href="windows.txt.html#window" class="d">window</a> if buffer <a href="motion.txt.html#is" class="d">is</a> already open.
                             • <span class="s">{focus}</span>? (`boolean`) Whether to focus/jump to
                               location if possible. (defaults: true)

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if succeeded

                                             <span id="vim.lsp.util.stylize_markdown%28%29" class="t">vim.lsp.util.stylize_markdown()</span>
stylize_markdown({bufnr}, <span class="s">{contents}</span>, <span class="s">{opts}</span>)
    Converts markdown into <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighted regions by stripping the code
    blocks and converting them into highlighted code. This will by default
    <a href="insert.txt.html#insert" class="d">insert</a> <a href="insert.txt.html#a" class="d">a</a> blank line separator after those code block regions to improve
    readability.

    This <a href="vimeval.txt.html#method" class="d">method</a> configures the given buffer and returns the lines to set.

    If you want to open <a href="insert.txt.html#a" class="d">a</a> popup with fancy markdown, use
    <span class="e">open_floating_preview</span> instead

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>     (`integer`)
      • <span class="s">{contents}</span>  (`string[]`) of lines to show in <a href="windows.txt.html#window" class="d">window</a>
      • <span class="s">{opts}</span>      (`table?`) with optional fields
                    • height of floating <a href="windows.txt.html#window" class="d">window</a>
                    • width of floating <a href="windows.txt.html#window" class="d">window</a>
                    • wrap_at character to wrap <a href="motion.txt.html#at" class="d">at</a> <a href="luaref.txt.html#for" class="d">for</a> computing height
                    • max_width maximal width of floating <a href="windows.txt.html#window" class="d">window</a>
                    • max_height maximal height of floating <a href="windows.txt.html#window" class="d">window</a>
                    • separator <a href="insert.txt.html#insert" class="d">insert</a> separator after code block

<span class="h">    Return: </span>
        (`table`) stripped content

                                             <span id="vim.lsp.util.symbols_to_items%28%29" class="t">vim.lsp.util.symbols_to_items()</span>
symbols_to_items({symbols}, <span class="s">{bufnr}</span>, <span class="s">{position_encoding}</span>)
    Converts symbols to <a href="quickfix.txt.html#quickfix" class="d">quickfix</a> <a href="vimeval.txt.html#list" class="d">list</a> items.

<span class="h">    Parameters: </span>
      • <span class="s">{symbols}</span>            (`lsp.DocumentSymbol[]|lsp.SymbolInformation[]`)
                             <a href="vimeval.txt.html#list" class="d">list</a> of symbols
      • <span class="s">{bufnr}</span>              (`integer?`) buffer handle or <a href="motion.txt.html#0" class="d">0</a> <a href="luaref.txt.html#for" class="d">for</a> current,
                             <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to current
      • <span class="s">{position_encoding}</span>  (`'utf-8'<span class="l">'utf-16'</span>'utf-32'?`) default to first
                             client of buffer

<span class="h">    Return: </span>
        (`vim.quickfix.entry[]`) See <a href="vimfn.txt.html#setqflist%28%29" class="l">setqflist()</a> <a href="luaref.txt.html#for" class="d">for</a> the format


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.log                                              <span id="lsp-log" class="t">lsp-log</span>

The <span class="e">vim.lsp.log</span> module provides logging <a href="luaref.txt.html#for" class="d">for</a> the Nvim <a href="lsp.txt.html#LSP" class="d">LSP</a> client.

When debugging language servers, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> helpful to enable extra-verbose logging
of the <a href="lsp.txt.html#LSP" class="d">LSP</a> client <a href="api.txt.html#RPC" class="d">RPC</a> events. Example: 
<span class="e">    vim.lsp.set_log_level 'trace'</span>
<span class="e">    require('vim.lsp.log').set_format_func(vim.inspect)</span>


Then try to run the language server, and open the <a href="starting.txt.html#log" class="d">log</a> with: 
<span class="e">    :lua vim.cmd('tabnew ' .. vim.lsp.get_log_path())</span>


(Or use <span class="e">:LspLog</span> if you have nvim-lspconfig installed.)

<span class="n">Note:</span>
• Remember to DISABLE <a href="starting.txt.html#verbose" class="d">verbose</a> logging <a href="motion.txt.html#%28" class="d">(</a>"debug" or "trace" level), else you may
  encounter performance issues.
• "ERROR" <a href="message.txt.html#messages" class="d">messages</a> containing "stderr" only indicate that the <a href="starting.txt.html#log" class="d">log</a> was sent to
  stderr. Many servers send harmless <a href="message.txt.html#messages" class="d">messages</a> via stderr.


get_filename()                                    <span id="vim.lsp.log.get_filename%28%29" class="t">vim.lsp.log.get_filename()</span>
    Returns the <a href="starting.txt.html#log" class="d">log</a> filename.

<span class="h">    Return: </span>
        (`string`) <a href="starting.txt.html#log" class="d">log</a> filename

get_level()                                          <span id="vim.lsp.log.get_level%28%29" class="t">vim.lsp.log.get_level()</span>
    Gets the current <a href="starting.txt.html#log" class="d">log</a> level.

<span class="h">    Return: </span>
        (`integer`) current <a href="starting.txt.html#log" class="d">log</a> level

set_format_func({handle})                      <span id="vim.lsp.log.set_format_func%28%29" class="t">vim.lsp.log.set_format_func()</span>
    Sets <a href="change.txt.html#formatting" class="d">formatting</a> function used to format logs

<span class="h">    Parameters: </span>
      • <span class="s">{handle}</span>  (`function`) function to apply to logging arguments, pass
                  vim.inspect <a href="luaref.txt.html#for" class="d">for</a> multi-line <a href="change.txt.html#formatting" class="d">formatting</a>

set_level({level})                                   <span id="vim.lsp.log.set_level%28%29" class="t">vim.lsp.log.set_level()</span>
    Sets the current <a href="starting.txt.html#log" class="d">log</a> level.

<span class="h">    Parameters: </span>
      • <span class="s">{level}</span>  (`string|integer`) One of <a href="lua.txt.html#vim.log.levels" class="l">vim.log.levels</a>

should_log({level})                                 <span id="vim.lsp.log.should_log%28%29" class="t">vim.lsp.log.should_log()</span>
    Checks whether the level <a href="motion.txt.html#is" class="d">is</a> sufficient <a href="luaref.txt.html#for" class="d">for</a> logging.

<span class="h">    Parameters: </span>
      • <span class="s">{level}</span>  (`integer`) <a href="starting.txt.html#log" class="d">log</a> level

<span class="h">    Return: </span>
        (`boolean`) true if would log, false if not


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim.lsp.rpc                                              <span id="lsp-rpc" class="t">lsp-rpc</span>

<span id="vim.lsp.rpc.PublicClient" class="t">vim.lsp.rpc.PublicClient</span>
    Client <a href="api.txt.html#RPC" class="d">RPC</a> object

<span class="h">    Fields: </span>
      • <span class="s">{request}</span>     (`fun(method: string, params: table?, callback: fun(err?: lsp.ResponseError, result: any), notify_reply_callback?: fun(message_id: integer)):boolean,integer?`)
                      See <a href="lsp.txt.html#vim.lsp.rpc.request%28%29" class="l">vim.lsp.rpc.request()</a>
      • <span class="s">{notify}</span>      (`fun(method: string, params: any): boolean`) See
                      <a href="lsp.txt.html#vim.lsp.rpc.notify%28%29" class="l">vim.lsp.rpc.notify()</a>
      • <span class="s">{is_closing}</span>  (`fun(): boolean`) Indicates if the <a href="api.txt.html#RPC" class="d">RPC</a> <a href="motion.txt.html#is" class="d">is</a> closing.
      • <span class="s">{terminate}</span>   (`fun()`) Terminates the <a href="api.txt.html#RPC" class="d">RPC</a> client.


connect({host_or_path}, <span class="s">{port}</span>)                        <span id="vim.lsp.rpc.connect%28%29" class="t">vim.lsp.rpc.connect()</span>
    Create <a href="insert.txt.html#a" class="d">a</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="api.txt.html#RPC" class="d">RPC</a> client factory that connects to either:
    • <a href="insert.txt.html#a" class="d">a</a> named pipe (windows)
    • <a href="insert.txt.html#a" class="d">a</a> domain socket (unix)
    • <a href="insert.txt.html#a" class="d">a</a> host and port via TCP

    Return <a href="insert.txt.html#a" class="d">a</a> function that can be passed to the <span class="e">cmd</span> field <a href="luaref.txt.html#for" class="d">for</a>
    <a href="lsp.txt.html#vim.lsp.start%28%29" class="l">vim.lsp.start()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{host_or_path}</span>  (`string`) host to connect to or path to <a href="insert.txt.html#a" class="d">a</a> pipe/domain
                        socket
      • <span class="s">{port}</span>          (`integer?`) TCP port to connect to. If absent the
                        first argument must be <a href="insert.txt.html#a" class="d">a</a> pipe

<span class="h">    Return: </span>
        (`fun(dispatchers: vim.lsp.rpc.Dispatchers): vim.lsp.rpc.PublicClient`)

format_rpc_error({err})                       <span id="vim.lsp.rpc.format_rpc_error%28%29" class="t">vim.lsp.rpc.format_rpc_error()</span>
    Constructs an error message from an <a href="lsp.txt.html#LSP" class="d">LSP</a> error object.

<span class="h">    Parameters: </span>
      • <span class="s">{err}</span>  (`table`) The error object

<span class="h">    Return: </span>
        (`string`) error_message The formatted error message

notify({method}, <span class="s">{params}</span>)                              <span id="vim.lsp.rpc.notify%28%29" class="t">vim.lsp.rpc.notify()</span>
    Sends <a href="insert.txt.html#a" class="d">a</a> notification to the <a href="lsp.txt.html#LSP" class="d">LSP</a> server.

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>  (`string`) The invoked <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a>
      • <span class="s">{params}</span>  (`table?`) Parameters <a href="luaref.txt.html#for" class="d">for</a> the invoked <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a>

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if notification could be sent, <span class="e">false</span> if not

                                                       <span id="vim.lsp.rpc.request%28%29" class="t">vim.lsp.rpc.request()</span>
request({method}, <span class="s">{params}</span>, <span class="s">{callback}</span>, <span class="s">{notify_reply_callback}</span>)
    Sends <a href="insert.txt.html#a" class="d">a</a> request to the <a href="lsp.txt.html#LSP" class="d">LSP</a> server and runs <span class="s">{callback}</span> upon response.

<span class="h">    Parameters: </span>
      • <span class="s">{method}</span>                 (`string`) The invoked <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a>
      • <span class="s">{params}</span>                 (`table?`) Parameters <a href="luaref.txt.html#for" class="d">for</a> the invoked <a href="lsp.txt.html#LSP" class="d">LSP</a>
                                 <a href="vimeval.txt.html#method" class="d">method</a>
      • <span class="s">{callback}</span>               (`fun(err: lsp.ResponseError?, result: any)`)
                                 Callback to invoke
      • <span class="s">{notify_reply_callback}</span>  (`fun(message_id: integer)?`) Callback to
                                 invoke <a href="motion.txt.html#as" class="d">as</a> soon <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> request <a href="motion.txt.html#is" class="d">is</a> no longer
                                 pending

<span class="h">    Return (multiple): </span>
        (`boolean`) success <span class="e">true</span> if request could be sent, <span class="e">false</span> if not
        (`integer?`) message_id if request could be sent, <span class="e">nil</span> if not

                                            <span id="vim.lsp.rpc.rpc_response_error%28%29" class="t">vim.lsp.rpc.rpc_response_error()</span>
rpc_response_error({code}, <span class="s">{message}</span>, <span class="s">{data}</span>)
    Creates an <a href="api.txt.html#RPC" class="d">RPC</a> response table <span class="e">error</span> to be sent to the <a href="lsp.txt.html#LSP" class="d">LSP</a> response.

<span class="h">    Parameters: </span>
      • <span class="s">{code}</span>     (`integer`) <a href="api.txt.html#RPC" class="d">RPC</a> error code defined, see
                   <span class="e">vim.lsp.protocol.ErrorCodes</span>
      • <span class="s">{message}</span>  (`string?`) arbitrary message to send to server
      • <span class="s">{data}</span>     (`any?`) arbitrary data to send to server

<span class="h">    Return: </span>
        (`lsp.ResponseError`)

<span class="h">    See also: </span>
      • lsp.ErrorCodes See <span class="e">vim.lsp.protocol.ErrorCodes</span>

start({cmd}, <span class="s">{dispatchers}</span>, <span class="s">{extra_spawn_params}</span>)        <span id="vim.lsp.rpc.start%28%29" class="t">vim.lsp.rpc.start()</span>
    Starts an <a href="lsp.txt.html#LSP" class="d">LSP</a> server process and create an <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="api.txt.html#RPC" class="d">RPC</a> client object to
    interact with it. Communication with the spawned process happens via
    stdio. For communication via TCP, spawn <a href="insert.txt.html#a" class="d">a</a> process manually and use
    <a href="lsp.txt.html#vim.lsp.rpc.connect%28%29" class="l">vim.lsp.rpc.connect()</a>

<span class="h">    Parameters: </span>
      • <span class="s">{cmd}</span>                 (`string[]`) Command to start the <a href="lsp.txt.html#LSP" class="d">LSP</a> server.
      • <span class="s">{dispatchers}</span>         (`table?`) Dispatchers <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> message types.
                              • <span class="s">{notification}</span>
                                (`fun(method: string, params: table)`)
                              • <span class="s">{server_request}</span>
                                (`fun(method: string, params: table): any?, lsp.ResponseError?`)
                              • <span class="s">{on_exit}</span>
                                (`fun(code: integer, signal: integer)`)
                              • <span class="s">{on_error}</span> (`fun(code: integer, err: any)`)
      • <span class="s">{extra_spawn_params}</span>  (`table?`) Additional <a href="repeat.txt.html#context" class="d">context</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="lsp.txt.html#LSP" class="d">LSP</a> server
                              process.
                              • <span class="s">{cwd}</span>? (`string`) Working directory <a href="luaref.txt.html#for" class="d">for</a> the
                                <a href="lsp.txt.html#LSP" class="d">LSP</a> server process
                              • <span class="s">{detached}</span>? (`boolean`) Detach the <a href="lsp.txt.html#LSP" class="d">LSP</a> server
                                process from the current process
                              • <span class="s">{env}</span>? (`table&lt;string,string&gt;`) Additional
                                environment <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> server process.
                                See <a href="lua.txt.html#vim.system%28%29" class="l">vim.system()</a>

<span class="h">    Return: </span>
        (`vim.lsp.rpc.PublicClient`) See <a href="lsp.txt.html#vim.lsp.rpc.PublicClient" class="l">vim.lsp.rpc.PublicClient</a><a href="repeat.txt.html#." class="d">.</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lsp.txt.html#vim.lsp.protocol" class="d">vim.lsp.protocol</a>                                    <span id="lsp-protocol" class="t">lsp-protocol</span>

                                 <span id="vim.lsp.protocol.make_client_capabilities%28%29" class="t">vim.lsp.protocol.make_client_capabilities()</span>
make_client_capabilities()
    Gets <a href="insert.txt.html#a" class="d">a</a> new ClientCapabilities object describing the <a href="lsp.txt.html#LSP" class="d">LSP</a> client
    capabilities.

<span class="h">    Return: </span>
        (`lsp.ClientCapabilities`)

Methods                                             <span id="vim.lsp.protocol.Methods" class="t">vim.lsp.protocol.Methods</span>
    <a href="lsp.txt.html#LSP" class="d">LSP</a> <a href="vimeval.txt.html#method" class="d">method</a> names.

<span class="h">    See also: </span>
      • <a class="u" href="https://microsoft.github.io/language-server-protocol/specification/#metaModel">https://microsoft.github.io/language-server-protocol/specification/#metaModel</a>

                                     <span id="vim.lsp.protocol.resolve_capabilities%28%29" class="t">vim.lsp.protocol.resolve_capabilities()</span>
resolve_capabilities({server_capabilities})
    Creates <a href="insert.txt.html#a" class="d">a</a> normalized object describing <a href="lsp.txt.html#LSP" class="d">LSP</a> server capabilities.

<span class="h">    Parameters: </span>
      • <span class="s">{server_capabilities}</span>  (`table`) Table of capabilities supported by
                               the server

<span class="h">    Return: </span>
        (`lsp.ServerCapabilities?`) Normalized table of capabilities


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:


</pre>
</div>
</main>
<p>Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
</p>
<footer>This site is maintained by Carlo Teubner (<i>(my first name) at cteubner dot net</i>).</footer>
</body>
</html>