<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="color-scheme" content="light dark">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Neovim help pages, always up-to-date">
<title>Neovim: lua.txt</title>
<link rel="shortcut icon" href="s/h3E0J2MHNKfIuCqP/favicon-neovim.ico">
<!-- favicon taken from https://neovim.io/favicon.ico, which is licensed under CC-BY-3.0: https://creativecommons.org/licenses/by/3.0/ -->

<link rel="stylesheet" href="s/MsMIu46igYudff1x/tom-select.min.css">
<script defer src="s/RLcAbtLBYX-q5me0/tom-select.base.min.js"></script>

<link rel="stylesheet" href="s/QRMkrs52-wJfIQ-w/vimhelp.css">
<noscript><link rel="stylesheet" href="s/eRFCn9A-K4lmzV_A/noscript.css"></noscript>
<script defer src="s/KpwrKyx19dtnhPoe/vimhelp.js"></script>
</head>
<body>




<div class="bar">
  <div class="ql">Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
</div>
  <div class="tag srch need-js">
    <select id="vh-select-tag"></select>
    <div class="placeholder">Go to keyword<span class="not-mobile">&nbsp;(shortcut: <kbd>k</kbd>)</span></div>
  </div>
  <form class="site srch" action="https://duckduckgo.com" method="get" target="_blank" rel="noopener noreferrer">
    <input type="hidden" name="sites" value="neo.vimhelp.org">
    <input type="search" name="q" id="vh-srch-input" placeholder="Site search">
    <div class="placeholder need-js">Site search<span class="not-mobile">&nbsp;(shortcut: <kbd>s</kbd>)</span></div>
  </form>
  <div id="theme-switcher" class="need-js">
  <button id="theme-current" title="Switch theme">Theme</button>
  <div id="theme-dropdown"><ul>
    <li><button id="theme-native" title="Switch to native theme">Native</button></li>
    <li><button id="theme-light" title="Switch to light theme">Light</button></li>
    <li><button id="theme-dark" title="Switch to dark theme">Dark</button></li>
  </ul></div>
</div>

</div>

<main>
<div id="vh-sidebar">
<ul><li><a href="lua.txt.html#">↑Top↑</a></li>
<li><a href="lua.txt.html#lua-eval">luaeval()</a></li>
<li><a href="lua.txt.html#v%3Alua-call">Vimscript v:lua interface</a></li>
<li><a href="lua.txt.html#lua-stdlib">Lua standard modules</a></li>
<li><a href="lua.txt.html#lua-vim">Lua module: vim</a></li>
<li><a href="lua.txt.html#vim.inspector">Lua module: vim.inspector</a></li>
<li><a href="lua.txt.html#vim.loader">Lua module: vim.loader</a></li>
<li><a href="lua.txt.html#vim.uri">Lua module: vim.uri</a></li>
<li><a href="lua.txt.html#vim.ui">Lua module: vim.ui</a></li>
<li><a href="lua.txt.html#vim.filetype">Lua module: vim.filetype</a></li>
<li><a href="lua.txt.html#vim.keymap">Lua module: vim.keymap</a></li>
<li><a href="lua.txt.html#vim.fs">Lua module: vim.fs</a></li>
<li><a href="lua.txt.html#vim.glob">Lua module: vim.glob</a></li>
<li><a href="lua.txt.html#vim.secure">Lua module: vim.secure</a></li>
<li><a href="lua.txt.html#vim.version">Lua module: vim.version</a></li>
<li><a href="lua.txt.html#vim.iter">Lua module: vim.iter</a></li>
<li><a href="lua.txt.html#vim.snippet">Lua module: vim.snippet</a></li>
<li><a href="lua.txt.html#vim.text">Lua module: vim.text</a></li>
<li><a href="lua.txt.html#vim.tohtml">Lua module: tohtml</a></li>
</ul>
</div>
<div id="vh-content">
<pre>
<span id="lua.txt" class="t">lua.txt</span>    Nvim


                            <span class="i">NVIM REFERENCE MANUAL</span>


<a href="lua.txt.html#Lua" class="d">Lua</a> engine                                                           <span id="lua" class="t">lua</span> <span id="Lua" class="t">Lua</span>

                                       Type <a href="various.txt.html#gO" class="l">gO</a> to see the table of contents.

<span class="h">==============================================================================</span>
<span class="c">INTRODUCTION</span>                                                       <span id="lua-intro" class="t">lua-intro</span>

The <a href="lua.txt.html#Lua" class="d">Lua</a> 5.1 <a href="usr_41.txt.html#script" class="d">script</a> engine <a href="motion.txt.html#is" class="d">is</a> builtin and always available. Try this command to
get an idea of what lurks beneath: 
<span class="e"></span>
<span class="e">    :lua vim.print(package.loaded)</span>
<span class="e"></span>
Nvim includes <a href="insert.txt.html#a" class="d">a</a> "standard library" <a href="lua.txt.html#lua-stdlib" class="l">lua-stdlib</a> <a href="luaref.txt.html#for" class="d">for</a> Lua.  It complements the
"editor stdlib" <a href="motion.txt.html#%28" class="d">(</a><a href="vimfn.txt.html#vimscript-functions" class="l">vimscript-functions</a> <a href="motion.txt.html#%2B" class="d">+</a> <a href="index.txt.html#Ex-commands" class="l">Ex-commands</a><a href="motion.txt.html#%29" class="d">)</a> and the <a href="api.txt.html#API" class="l">API</a><a href="motion.txt.html#%2C" class="d">,</a> all of
which can be used from <a href="lua.txt.html#Lua" class="d">Lua</a> code <a href="motion.txt.html#%28" class="d">(</a><a href="lua.txt.html#lua-vimscript" class="l">lua-vimscript</a> <a href="lua.txt.html#vim.api" class="l">vim.api</a>). These three
namespaces form the Nvim programming interface.

<a href="lua.txt.html#Lua" class="d">Lua</a> plugins and user <a href="starting.txt.html#config" class="d">config</a> are automatically discovered and loaded, just like
Vimscript. See <a href="lua-guide.txt.html#lua-guide" class="l">lua-guide</a> <a href="luaref.txt.html#for" class="d">for</a> practical guidance.

You can also run <a href="lua.txt.html#Lua" class="d">Lua</a> scripts from your shell using the <a href="starting.txt.html#-l" class="l">-l</a> argument: 
<span class="e">    nvim -l foo.lua [args...]</span>

                                                                  <span id="lua-compat" class="t">lua-compat</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> 5.1 <a href="motion.txt.html#is" class="d">is</a> the permanent interface <a href="luaref.txt.html#for" class="d">for</a> Nvim Lua. Plugins should target <a href="lua.txt.html#Lua" class="d">Lua</a> 5.1
<a href="motion.txt.html#as" class="d">as</a> specified in <a href="luaref.txt.html#luaref" class="l">luaref</a><a href="motion.txt.html#%3B" class="d">;</a> later versions (which are essentially different,
incompatible, dialects) are not supported. This includes extensions such <a href="motion.txt.html#as" class="d">as</a>
<span class="e">goto</span> that some <a href="lua.txt.html#Lua" class="d">Lua</a> 5.1 interpreters like LuaJIT may support.

                                                                  <span id="lua-luajit" class="t">lua-luajit</span>
While Nvim officially only requires <a href="lua.txt.html#Lua" class="d">Lua</a> 5.1 support, <a href="motion.txt.html#it" class="d">it</a> should be built with
LuaJIT or <a href="insert.txt.html#a" class="d">a</a> compatible fork on supported platforms <a href="luaref.txt.html#for" class="d">for</a> performance reasons.
LuaJIT also comes with useful extensions such <a href="motion.txt.html#as" class="d">as</a> <span class="e">ffi</span>, <a href="lua.txt.html#lua-profile" class="l">lua-profile</a><a href="motion.txt.html#%2C" class="d">,</a> and
enhanced standard library functions; these cannot be assumed to be available,
and <a href="lua.txt.html#Lua" class="d">Lua</a> code in <a href="starting.txt.html#init.lua" class="l">init.lua</a> or plugins should check the <span class="e">jit</span> global variable
before using them: 
<span class="e">  if jit then</span>
<span class="e">    -- code for luajit</span>
<span class="e">  else</span>
<span class="e">    -- code for plain lua 5.1</span>
<span class="e">  end</span>

One exception <a href="motion.txt.html#is" class="d">is</a> the LuaJIT <span class="e">bit</span> extension, which <a href="motion.txt.html#is" class="d">is</a> always available: when
built with PUC Lua, Nvim includes <a href="insert.txt.html#a" class="d">a</a> fallback implementation which provides
<span class="e">require("bit")</span>. See <a href="lua-bit.txt.html#lua-bit" class="l">lua-bit</a><a href="repeat.txt.html#." class="d">.</a>

                                                                  <span id="lua-profile" class="t">lua-profile</span>
If Nvim <a href="motion.txt.html#is" class="d">is</a> built with LuaJIT, <a href="lua.txt.html#Lua" class="d">Lua</a> code can be profiled via 
<span class="e">    -- Start a profiling session:</span>
<span class="e">    require('jit.p').start('ri1', '/tmp/profile')</span>
<span class="e"></span>
<span class="e">    -- Perform arbitrary tasks (use plugins, scripts, etc.) ...</span>
<span class="e"></span>
<span class="e">    -- Stop the session. Profile is written to /tmp/profile.</span>
<span class="e">    require('jit.p').stop()</span>
<span class="e"></span>
See <a class="u" href="https://luajit.org/ext_profiler.html">https://luajit.org/ext_profiler.html</a> or the <span class="e">p.lua</span> source <a href="luaref.txt.html#for" class="d">for</a> details: 
<span class="e">    :lua vim.cmd.edit(package.searchpath('jit.p', package.path))</span>
<span class="e"></span>
<span class="h">==============================================================================</span>
<span class="c">LUA CONCEPTS AND IDIOMS</span>                                         <span id="lua-concepts" class="t">lua-concepts</span>

<a href="lua.txt.html#Lua" class="d">Lua</a> <a href="motion.txt.html#is" class="d">is</a> very simple, and _consistent_: while there are some quirks, once you
internalize those quirks, everything works the same everywhere. Scopes
(closures) in particular are very consistent, unlike JavaScript or most other
languages.

<a href="lua.txt.html#Lua" class="d">Lua</a> has three fundamental mechanisms—one <a href="luaref.txt.html#for" class="d">for</a> "each major aspect of
programming"<a href="cmdline.txt.html#%3A" class="d">:</a> tables, closures, and coroutines.
<a class="u" href="https://www.lua.org/doc/cacm2018.pdf">https://www.lua.org/doc/cacm2018.pdf</a>
<a href="motion.txt.html#-" class="d">-</a> Tables are the "object" or container datastructure: they represent both
  lists and maps, you can extend them to represent your own datatypes and
  change their behavior using <a href="luaref.txt.html#metatable" class="l">metatable</a><a href="change.txt.html#s" class="d">s</a> (like Python's "datamodel").
<a href="motion.txt.html#-" class="d">-</a> EVERY scope in <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> closure: <a href="insert.txt.html#a" class="d">a</a> function <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> closure, <a href="insert.txt.html#a" class="d">a</a> module <a href="motion.txt.html#is" class="d">is</a>
  <a href="insert.txt.html#a" class="d">a</a> closure, <a href="insert.txt.html#a" class="d">a</a> <span class="e">do</span> block <a href="motion.txt.html#%28" class="d">(</a><a href="luaref.txt.html#lua-do" class="l">lua-do</a><a href="motion.txt.html#%29" class="d">)</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> closure--and they all work the same.
  <a href="insert.txt.html#A" class="d">A</a> <a href="lua.txt.html#Lua" class="d">Lua</a> module <a href="motion.txt.html#is" class="d">is</a> literally just <a href="insert.txt.html#a" class="d">a</a> big <a href="vimeval.txt.html#closure" class="d">closure</a> discovered on the "path"
  (where your modules are found: <a href="luaref.txt.html#package.cpath" class="l">package.cpath</a>).
<a href="motion.txt.html#-" class="d">-</a> Stackful coroutines enable cooperative multithreading, generators, and
  versatile <a href="intro.txt.html#control" class="d">control</a> <a href="luaref.txt.html#for" class="d">for</a> both <a href="lua.txt.html#Lua" class="d">Lua</a> and its host (Nvim).

                                                          <span id="lua-error-handling" class="t">lua-error-handling</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#functions" class="d">functions</a> may throw <a href="luaref.txt.html#lua-errors" class="l">lua-errors</a> <a href="luaref.txt.html#for" class="d">for</a> exceptional (unexpected) failures,
which you can handle with <a href="luaref.txt.html#pcall%28%29" class="l">pcall()</a><a href="repeat.txt.html#." class="d">.</a>
                                                       <span id="lua-result-or-message" class="t">lua-result-or-message</span>
When failure <a href="motion.txt.html#is" class="d">is</a> normal and expected, it's idiomatic to return <span class="e">nil</span> which
signals to the caller that failure <a href="motion.txt.html#is" class="d">is</a> not "exceptional" and must be handled.
This "result-or-message" <a href="pattern.txt.html#pattern" class="d">pattern</a> <a href="motion.txt.html#is" class="d">is</a> expressed <a href="motion.txt.html#as" class="d">as</a> the multi-value return type
<span class="e">any|nil,nil|string</span>, or in LuaLS notation: 
<span class="e"></span>
<span class="e">    ---@return any|nil    # result on success, nil on failure.</span>
<span class="e">    ---@return nil|string # nil on success, error message on failure.</span>

Examples of the "result-or-message" pattern:
<a href="motion.txt.html#-" class="d">-</a> <a href="lua.txt.html#vim.ui.open%28%29" class="l">vim.ui.open()</a>
<a href="motion.txt.html#-" class="d">-</a> <a href="luaref.txt.html#io.open%28%29" class="l">io.open()</a>
<a href="motion.txt.html#-" class="d">-</a> <a href="luvref.txt.html#luv-error-handling" class="l">luv-error-handling</a>

When <a href="insert.txt.html#a" class="d">a</a> caller can't proceed on failure, it's idiomatic to <span class="e">assert()</span> the
"result-or-message" result: 
<span class="e"></span>
<span class="e">    local value = assert(fn())</span>
<span class="e"></span>
Guidance: use the "result-or-message" <a href="pattern.txt.html#pattern" class="d">pattern</a> for...
<a href="motion.txt.html#-" class="d">-</a> Functions where failure <a href="motion.txt.html#is" class="d">is</a> expected, especially when communicating with the
  external world. E.g. HTTP requests or <a href="lsp.txt.html#LSP" class="d">LSP</a> requests often fail because of
  server problems, even if the caller did everything right.
<a href="motion.txt.html#-" class="d">-</a> Functions that return <a href="insert.txt.html#a" class="d">a</a> value, e.g. Foo:new().
<a href="motion.txt.html#-" class="d">-</a> When there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of known error codes which can be returned <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> third
  value (like <a href="luvref.txt.html#luv-error-handling" class="l">luv-error-handling</a>).
<a href="change.txt.html#%3C" class="d">&lt;</a>
                                                                    <span id="iterator" class="t">iterator</span>
An <a href="lua.txt.html#iterator" class="d">iterator</a> <a href="motion.txt.html#is" class="d">is</a> just <a href="insert.txt.html#a" class="d">a</a> function that can be called repeatedly to get the "next"
value of <a href="insert.txt.html#a" class="d">a</a> collection (or any other <a href="lua.txt.html#iterable" class="l">iterable</a>). This interface <a href="motion.txt.html#is" class="d">is</a> expected by
<a href="luaref.txt.html#for-in" class="l">for-in</a> loops, produced by <a href="luaref.txt.html#pairs%28%29" class="l">pairs()</a><a href="motion.txt.html#%2C" class="d">,</a> supported by <a href="lua.txt.html#vim.iter" class="l">vim.iter</a><a href="motion.txt.html#%2C" class="d">,</a> etc.
<a class="u" href="https://www.lua.org/pil/7.1.html">https://www.lua.org/pil/7.1.html</a>

                                                                    <span id="iterable" class="t">iterable</span>
An "<a href="lua.txt.html#iterable" class="d">iterable</a>" <a href="motion.txt.html#is" class="d">is</a> anything that <a href="lua.txt.html#vim.iter%28%29" class="l">vim.iter()</a> can consume: tables, dicts, lists,
<a href="lua.txt.html#iterator" class="d">iterator</a> functions, tables implementing the <a href="luaref.txt.html#__call%28%29" class="l">__call()</a> metamethod, and
<a href="lua.txt.html#vim.iter%28%29" class="l">vim.iter()</a> objects.

                                                               <span id="list-iterator" class="t">list-iterator</span>
Iterators on <a href="lua.txt.html#lua-list" class="l">lua-list</a> tables have <a href="insert.txt.html#a" class="d">a</a> "middle" and "<a href="intro.txt.html#end" class="d">end</a>"<a href="motion.txt.html#%2C" class="d">,</a> whereas iterators in
general may be logically infinite. Therefore some <a href="lua.txt.html#vim.iter" class="l">vim.iter</a> operations (e.g.
<a href="lua.txt.html#Iter%3Arev%28%29" class="l">Iter:rev()</a><a href="motion.txt.html#%29" class="d">)</a> make sense only on list-like tables (which are finite by
definition).

                                                           <span id="lua-function-call" class="t">lua-function-call</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#functions" class="d">functions</a> can be called in multiple ways. Consider the function: 
<span class="e">    local foo = function(a, b)</span>
<span class="e">        print("A: ", a)</span>
<span class="e">        print("B: ", b)</span>
<span class="e">    end</span>
<span class="e"></span>
The first way to call this function is: 
<span class="e">    foo(1, 2)</span>
<span class="e">    -- ==== Result ====</span>
<span class="e">    -- A: 1</span>
<span class="e">    -- B: 2</span>
<span class="e"></span>
This way of calling <a href="insert.txt.html#a" class="d">a</a> function <a href="motion.txt.html#is" class="d">is</a> familiar from most scripting languages. In
Lua, any missing arguments are passed <a href="motion.txt.html#as" class="d">as</a> <span class="e">nil</span>, and extra parameters are
silently discarded. Example: 
<span class="e">    foo(1)</span>
<span class="e">    -- ==== Result ====</span>
<span class="e">    -- A: 1</span>
<span class="e">    -- B: nil</span>

                                                                      <span id="kwargs" class="t">kwargs</span>
When calling <a href="insert.txt.html#a" class="d">a</a> function, you can omit the parentheses if the function takes
exactly one <a href="vimeval.txt.html#string" class="d">string</a> literal (`"foo"<a href="motion.txt.html#%60%29" class="d">`)</a> or table literal (`{1,2,3}`). The latter
<a href="motion.txt.html#is" class="d">is</a> often used to mimic "named parameters" <a href="motion.txt.html#%28" class="d">(</a>"<a href="lua.txt.html#kwargs" class="d">kwargs</a>" or "keyword args"<a href="motion.txt.html#%29" class="d">)</a> <a href="motion.txt.html#as" class="d">as</a> in
languages like <a href="if_pyth.txt.html#Python" class="d">Python</a> and C#. Example: 
<span class="e">    local func_with_opts = function(opts)</span>
<span class="e">        local will_do_foo = opts.foo</span>
<span class="e">        local filename = opts.filename</span>
<span class="e">        -- ...</span>
<span class="e">    end</span>
<span class="e"></span>
<span class="e">    func_with_opts { foo = true, filename = "hello.world" }</span>

There's nothing special going on here except that parentheses are implicitly
added. But visually, this small bit of sugar gets reasonably close to <a href="insert.txt.html#a" class="d">a</a>
"keyword args" interface.

                                                                   <span id="lua-regex" class="t">lua-regex</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> intentionally does not <a href="support.txt.html#support" class="d">support</a> regular expressions, instead <a href="motion.txt.html#it" class="d">it</a> has limited
<a href="luaref.txt.html#lua-pattern" class="l">lua-pattern</a><a href="change.txt.html#s" class="d">s</a> which avoid the performance pitfalls of extended regex. <a href="lua.txt.html#Lua" class="d">Lua</a>
scripts can also use Vim regex via <a href="lua.txt.html#vim.regex%28%29" class="l">vim.regex()</a><a href="repeat.txt.html#." class="d">.</a>

Examples: 
<span class="e"></span>
<span class="e">    print(string.match("foo123bar123", "%d+"))</span>
<span class="e">    -- 123</span>
<span class="e">    print(string.match("foo123bar123", "[^%d]+"))</span>
<span class="e">    -- foo</span>
<span class="e">    print(string.match("foo123bar123", "[abc]+"))</span>
<span class="e">    -- ba</span>
<span class="e">    print(string.match("foo.bar", "%.bar"))</span>
<span class="e">    -- .bar</span>
<span class="e"></span>
<span class="h">==============================================================================</span>
<span class="c">IMPORTING LUA MODULES</span>                                        <span id="lua-module-load" class="t">lua-module-load</span>

Modules are searched <a href="luaref.txt.html#for" class="d">for</a> under the directories specified in <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> and
<a href="options.txt.html#packages-runtimepath" class="l">packages-runtimepath</a><a href="motion.txt.html#%2C" class="d">,</a> in the order they appear in the output of this command

<span class="e">	:echo nvim_list_runtime_paths()</span>

Any "<a href="repeat.txt.html#." class="d">.</a>" in the module name <a href="motion.txt.html#is" class="d">is</a> treated <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> directory separator when searching.
For <a href="insert.txt.html#a" class="d">a</a> module <span class="e">foo.bar</span>, each directory <a href="motion.txt.html#is" class="d">is</a> searched <a href="luaref.txt.html#for" class="d">for</a> <span class="e">lua/foo/bar.lua</span>, then
<span class="e">lua/foo/bar/init.lua</span>.  If no files are found, the directories are searched
again <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> shared library with <a href="insert.txt.html#a" class="d">a</a> name matching <span class="e">lua/foo/bar.?</span>, where <span class="e">?</span> <a href="motion.txt.html#is" class="d">is</a>
<a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="cmdline.txt.html#suffixes" class="d">suffixes</a> (such <a href="motion.txt.html#as" class="d">as</a> <span class="e">so</span> or <span class="e">dll</span>) derived from the initial value of
<a href="luaref.txt.html#package.cpath" class="l">package.cpath</a><a href="repeat.txt.html#." class="d">.</a> If still no files are found, Nvim falls back to Lua's default
search mechanism. The first <a href="usr_41.txt.html#script" class="d">script</a> found <a href="motion.txt.html#is" class="d">is</a> run and <span class="e">require()</span> returns the
value returned by the <a href="usr_41.txt.html#script" class="d">script</a> if any, else <span class="e">true</span>.

The return value <a href="motion.txt.html#is" class="d">is</a> cached after the first call to <span class="e">require()</span> <a href="luaref.txt.html#for" class="d">for</a> each module,
with subsequent calls returning the cached value without searching for, or
executing any script. For further details see <a href="luaref.txt.html#require%28%29" class="l">require()</a><a href="repeat.txt.html#." class="d">.</a>

For example, if <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> <a href="motion.txt.html#is" class="d">is</a> <span class="e">foo,bar</span> and <a href="luaref.txt.html#package.cpath" class="l">package.cpath</a> was
<span class="e">./?.so;./?.dll</span> <a href="motion.txt.html#at" class="d">at</a> startup, <span class="e">require('mod')</span> searches these paths in order
and loads the first module found <a href="motion.txt.html#%28" class="d">(</a>"first wins"): 
<span class="e">    foo/lua/mod.lua</span>
<span class="e">    foo/lua/mod/init.lua</span>
<span class="e">    bar/lua/mod.lua</span>
<span class="e">    bar/lua/mod/init.lua</span>
<span class="e">    foo/lua/mod.so</span>
<span class="e">    foo/lua/mod.dll</span>
<span class="e">    bar/lua/mod.so</span>
<span class="e">    bar/lua/mod.dll</span>

<span class="n">Note:</span>

<a href="motion.txt.html#-" class="d">-</a> Although <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> <a href="motion.txt.html#is" class="d">is</a> tracked, Nvim does not track current
  values of <a href="luaref.txt.html#package.path" class="l">package.path</a> or <a href="luaref.txt.html#package.cpath" class="l">package.cpath</a><a href="repeat.txt.html#." class="d">.</a> If you happen to delete some
  paths from there you can set <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> to trigger an update: 
<span class="e">      let &amp;runtimepath = &amp;runtimepath</span>
<span class="e"></span>
<a href="motion.txt.html#-" class="d">-</a> Skipping paths from <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> which contain semicolons applies both to
  <a href="luaref.txt.html#package.path" class="l">package.path</a> and <a href="luaref.txt.html#package.cpath" class="l">package.cpath</a><a href="repeat.txt.html#." class="d">.</a> Given that there are some badly written
  plugins using shell, which will not work with paths containing semicolons,
  <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> better to not have them in <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> <a href="motion.txt.html#at" class="d">at</a> all.

<span class="h">==============================================================================</span>
<span class="c">COMMANDS</span>                                                        <span id="lua-commands" class="t">lua-commands</span>

These commands execute <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> chunk from either the command line (:lua, :luado)
or <a href="insert.txt.html#a" class="d">a</a> file (:luafile) on the given line <a href="cmdline.txt.html#%5Brange%5D" class="s">[range]</a>. As always in Lua, each chunk
has its own scope (closure), so only global <a href="vimeval.txt.html#variables" class="d">variables</a> are shared between
command calls. The <a href="lua.txt.html#lua-stdlib" class="l">lua-stdlib</a> modules, user modules, and anything else on
<a href="luaref.txt.html#package.path" class="l">package.path</a> are available.

The <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="luaref.txt.html#print%28%29" class="d">print()</a> function redirects its output to the Nvim message area, with
arguments separated by " " (space) instead of "\t" (tab).

                                                                  <span id="%3Alua%3D" class="t">:lua=</span> <span id="%3Alua" class="t">:lua</span>
<a href="lua.txt.html#%3Alua" class="d">:lua</a> <span class="s">{chunk}</span>
    Executes <a href="lua.txt.html#Lua" class="d">Lua</a> chunk <span class="s">{chunk}</span>. If <span class="s">{chunk}</span> starts with "<a href="change.txt.html#%3D" class="d">=</a>" the rest of the
    chunk <a href="motion.txt.html#is" class="d">is</a> evaluated <a href="motion.txt.html#as" class="d">as</a> an <a href="vimeval.txt.html#expression" class="d">expression</a> and printed. `:lua =expr` and <span class="e">:=expr</span>
    are equivalent to `:lua print(vim.inspect(expr))`.

    Examples: 
<span class="e">        :lua vim.api.nvim_command('echo "Hello, Nvim!"')</span>
    To see the <a href="lua.txt.html#Lua" class="d">Lua</a> version: 
<span class="e">        :lua print(_VERSION)</span>
    To see the LuaJIT version: 
<span class="e">        :lua =jit.version</span>

:{range}lua
    Executes buffer lines in <span class="s">{range}</span> <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#Lua" class="d">Lua</a> code. Unlike <a href="repeat.txt.html#%3Asource" class="l">:source</a><a href="motion.txt.html#%2C" class="d">,</a> this
    always treats the lines <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#Lua" class="d">Lua</a> code.

    Example: select the following code and type ":lua&lt;Enter&gt;" to execute it: 
<span class="e">        print(string.format(</span>
<span class="e">            'unix time: %s', os.time()))</span>

                                                                <span id="%3Alua-heredoc" class="t">:lua-heredoc</span>
<a href="lua.txt.html#%3Alua" class="d">:lua</a> <a href="change.txt.html#%3C%3C" class="d">&lt;&lt;</a> <span class="s">[trim]</span> [{endmarker}]
<span class="s">{script}</span>
<span class="s">{endmarker}</span>
    Executes <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="usr_41.txt.html#script" class="d">script</a> <span class="s">{script}</span> from within Vimscript. You can omit
    <span class="s">[endmarker]</span> after the "<a href="change.txt.html#%3C%3C" class="d">&lt;&lt;</a>" and use <a href="insert.txt.html#a" class="d">a</a> dot "<a href="repeat.txt.html#." class="d">.</a>" after <span class="s">{script}</span> (similar to
    <a href="insert.txt.html#%3Aappend" class="l">:append</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="insert.txt.html#%3Ainsert" class="l">:insert</a>). Refer to <a href="vimeval.txt.html#%3Alet-heredoc" class="l">:let-heredoc</a> <a href="luaref.txt.html#for" class="d">for</a> more information.

    Example: 
<span class="e">        function! CurrentLineInfo()</span>
<span class="e">        lua &lt;&lt; EOF</span>
<span class="e">        local linenr = vim.api.nvim_win_get_cursor(0)[1]</span>
<span class="e">        local curline = vim.api.nvim_buf_get_lines(0, linenr - 1, linenr, false)[1]</span>
<span class="e">        print(string.format('Line [%d] has %d bytes', linenr, #curline))</span>
<span class="e">        EOF</span>
<span class="e">        endfunction</span>

    <span class="n">Note</span> that the <span class="e">local</span> <a href="vimeval.txt.html#variables" class="d">variables</a> will disappear when the block finishes.
    But not globals.

                                                                      <span id="%3Aluado" class="t">:luado</span>
:[range]luado <span class="s">{body}</span>
    Executes <a href="lua.txt.html#Lua" class="d">Lua</a> chunk "function(line, linenr) <span class="s">{body}</span> <a href="intro.txt.html#end" class="d">end</a>" <a href="luaref.txt.html#for" class="d">for</a> each buffer
    line in <a href="cmdline.txt.html#%5Brange%5D" class="s">[range]</a>, where <span class="e">line</span> <a href="motion.txt.html#is" class="d">is</a> the current line text (without <a href="intro.txt.html#%3CEOL%3E" class="s">&lt;EOL&gt;</a>),
    and <span class="e">linenr</span> <a href="motion.txt.html#is" class="d">is</a> the current line number. If the function returns <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a>
    that becomes the text of the corresponding buffer line. Default <a href="cmdline.txt.html#%5Brange%5D" class="s">[range]</a> <a href="motion.txt.html#is" class="d">is</a>
    the whole file: "1,$"<a href="repeat.txt.html#." class="d">.</a>

    Examples: 
<span class="e">        :luado return string.format("%s\t%d", line:reverse(), #line)</span>
<span class="e"></span>
<span class="e">        :lua require"lpeg"</span>
<span class="e">        :lua -- balanced parenthesis grammar:</span>
<span class="e">        :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }</span>
<span class="e">        :luado if bp:match(line) then return "=&gt;\t" .. line end</span>

                                                                    <span id="%3Aluafile" class="t">:luafile</span>
<a href="lua.txt.html#%3Aluafile" class="d">:luafile</a> <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>
    Execute <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="usr_41.txt.html#script" class="d">script</a> in <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>.
    The whole argument <a href="motion.txt.html#is" class="d">is</a> used <a href="motion.txt.html#as" class="d">as</a> the filename (like <a href="editing.txt.html#%3Aedit" class="l">:edit</a>), spaces <a href="diff.txt.html#do" class="d">do</a> not
    need to be escaped. Alternatively you can <a href="repeat.txt.html#%3Asource" class="l">:source</a> <a href="lua.txt.html#Lua" class="d">Lua</a> files.

    Examples: 
<span class="e">        :luafile script.lua</span>
<span class="e">        :luafile %</span>


<span class="h">==============================================================================</span>
<a href="vimfn.txt.html#luaeval%28%29" class="d">luaeval()</a>                                                 <span id="lua-eval" class="t">lua-eval</span>

The (dual) equivalent of "vim.eval" <a href="luaref.txt.html#for" class="d">for</a> passing <a href="lua.txt.html#Lua" class="d">Lua</a> values to Nvim <a href="motion.txt.html#is" class="d">is</a>
"luaeval"<a href="repeat.txt.html#." class="d">.</a> "luaeval" takes an <a href="vimeval.txt.html#expression" class="d">expression</a> <a href="vimeval.txt.html#string" class="d">string</a> and an optional argument used
<a href="luaref.txt.html#for" class="d">for</a> _A inside <a href="vimeval.txt.html#expression" class="d">expression</a> and returns the result of the expression. It <a href="motion.txt.html#is" class="d">is</a>
semantically equivalent in <a href="lua.txt.html#Lua" class="d">Lua</a> to: 
<span class="e"></span>
<span class="e">    local chunkheader = "local _A = select(1, ...) return "</span>
<span class="e">    function luaeval (expstr, arg)</span>
<span class="e">        local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))</span>
<span class="e">        return chunk(arg) -- return typval</span>
<span class="e">    end</span>

<a href="lua.txt.html#Lua" class="d">Lua</a> nils, numbers, strings, tables and booleans are converted to their
respective Vimscript types. If <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#string" class="d">string</a> contains <a href="insert.txt.html#a" class="d">a</a> NUL byte, <a href="motion.txt.html#it" class="d">it</a> will be
converted to <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#Blob" class="l">Blob</a><a href="repeat.txt.html#." class="d">.</a> Conversion of other <a href="lua.txt.html#Lua" class="d">Lua</a> types <a href="motion.txt.html#is" class="d">is</a> an error.

The magic global "_A" contains the second argument to luaeval().

Example: 
<span class="e">    :echo luaeval('_A[1] + _A[2]', [40, 2])</span>
<span class="e">    " 42</span>
<span class="e">    :echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')</span>
<span class="e">    " foo</span>

                                                         <span id="lua-table-ambiguous" class="t">lua-table-ambiguous</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> tables are used <a href="motion.txt.html#as" class="d">as</a> both dictionaries and lists, so <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> impossible to
decide whether empty table <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> or <a href="insert.txt.html#a" class="d">a</a> dict. Also <a href="lua.txt.html#Lua" class="d">Lua</a> does not have integer
numbers. To disambiguate these cases, we define:
                                                                    <span id="lua-list" class="t">lua-list</span>
0. Empty table <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> list. Use <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a> to represent empty dict.
1. Table with <a href="pattern.txt.html#N" class="d">N</a> consecutive (no <span class="e">nil</span> values, aka "holes"<a href="motion.txt.html#%29" class="d">)</a> integer keys 1…<a href="pattern.txt.html#N" class="d">N</a> <a href="motion.txt.html#is" class="d">is</a>
   <a href="insert.txt.html#a" class="d">a</a> list. See also <a href="lua.txt.html#list-iterator" class="l">list-iterator</a><a href="repeat.txt.html#." class="d">.</a>
                                                                    <span id="lua-dict" class="t">lua-dict</span>
2. Table with <a href="vimeval.txt.html#string" class="d">string</a> keys, none of which contains NUL byte, <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> dict.
3. Table with <a href="vimeval.txt.html#string" class="d">string</a> keys, <a href="motion.txt.html#at" class="d">at</a> least one of which contains NUL byte, <a href="motion.txt.html#is" class="d">is</a> also
   considered to be <a href="insert.txt.html#a" class="d">a</a> dictionary, but this time <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> converted to
   <a href="insert.txt.html#a" class="d">a</a> <a href="vimfn.txt.html#msgpack-special-map" class="l">msgpack-special-map</a><a href="repeat.txt.html#." class="d">.</a>
                                                             <span id="lua-special-tbl" class="t">lua-special-tbl</span>
4. Table with <span class="e">vim.type_idx</span> key may be <a href="insert.txt.html#a" class="d">a</a> dictionary, <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> or floating-point
   value:
   <a href="motion.txt.html#-" class="d">-</a> `{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}` <a href="motion.txt.html#is" class="d">is</a> converted to
     <a href="insert.txt.html#a" class="d">a</a> floating-point 1.0. <span class="n">Note</span> that by default integral <a href="lua.txt.html#Lua" class="d">Lua</a> numbers are
     converted to <a href="vimeval.txt.html#Number" class="l">Number</a>s, non-integral are converted to <a href="vimeval.txt.html#Float" class="l">Float</a>s. This
     variant allows integral <a href="vimeval.txt.html#Float" class="l">Float</a>s.
   <a href="motion.txt.html#-" class="d">-</a> <span class="e">{[vim.type_idx]=vim.types.dictionary}</span> <a href="motion.txt.html#is" class="d">is</a> converted to an empty
     dictionary, `{[vim.type_idx]=vim.types.dictionary, <span class="s">[42]</span>=1, a=2}` <a href="motion.txt.html#is" class="d">is</a>
     converted to <a href="insert.txt.html#a" class="d">a</a> dictionary `{'a': 42}`: non-string keys are ignored.
     Without <span class="e">vim.type_idx</span> key tables with keys not fitting in 1., 2. or 3.
     are errors.
   <a href="motion.txt.html#-" class="d">-</a> <span class="e">{[vim.type_idx]=vim.types.array}</span> <a href="motion.txt.html#is" class="d">is</a> converted to an empty list. As well
     <a href="motion.txt.html#as" class="d">as</a> `{[vim.type_idx]=vim.types.array, <span class="s">[42]</span>=1}`: integral keys that <a href="diff.txt.html#do" class="d">do</a> not
     form <a href="insert.txt.html#a" class="d">a</a> 1-step sequence from 1 to <a href="pattern.txt.html#N" class="d">N</a> are ignored, <a href="motion.txt.html#as" class="d">as</a> well <a href="motion.txt.html#as" class="d">as</a> all
     non-integral keys.

Examples: 
<span class="e"></span>
<span class="e">    :echo luaeval('math.pi')</span>
<span class="e">    :function Rand(x,y) " random uniform between x and y</span>
<span class="e">    :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})</span>
<span class="e">    :  endfunction</span>
<span class="e">    :echo Rand(1,10)</span>

<span class="n">Note:</span> Second argument to <span class="e">luaeval</span> <a href="motion.txt.html#is" class="d">is</a> converted <a href="motion.txt.html#%28" class="d">(</a>"marshalled"<a href="motion.txt.html#%29" class="d">)</a> from Vimscript
to Lua, so changes to <a href="lua.txt.html#Lua" class="d">Lua</a> containers <a href="diff.txt.html#do" class="d">do</a> not affect values in Vimscript. Return
value <a href="motion.txt.html#is" class="d">is</a> also always converted. When converting, <a href="vimfn.txt.html#msgpack-special-dict" class="l">msgpack-special-dict</a><a href="change.txt.html#s" class="d">s</a> are
treated specially.

<span class="h">==============================================================================</span>
Vimscript <a href="vvars.txt.html#v%3Alua" class="d">v:lua</a> interface                                         <span id="v%3Alua-call" class="t">v:lua-call</span>

From Vimscript the special <span class="e">v:lua</span> prefix can be used to call <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#functions" class="d">functions</a>
which are global or accessible from global tables. The <a href="vimeval.txt.html#expression" class="d">expression</a> 
<span class="e">    call v:lua.func(arg1, arg2)</span>
<a href="motion.txt.html#is" class="d">is</a> equivalent to the <a href="lua.txt.html#Lua" class="d">Lua</a> chunk 
<span class="e">    return func(...)</span>
where the args are converted to <a href="lua.txt.html#Lua" class="d">Lua</a> values. The <a href="vimeval.txt.html#expression" class="d">expression</a> 
<span class="e">    call v:lua.somemod.func(args)</span>
<a href="motion.txt.html#is" class="d">is</a> equivalent to the <a href="lua.txt.html#Lua" class="d">Lua</a> chunk 
<span class="e">    return somemod.func(...)</span>
<span class="e"></span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module <a href="vimeval.txt.html#functions" class="d">functions</a> can be accessed like: 
<span class="e">    call v:lua.require'mypack'.func(arg1, arg2)</span>
<span class="e">    call v:lua.require'mypack.submod'.func(arg1, arg2)</span>
<span class="n">Note:</span> Only single <a href="change.txt.html#quote" class="d">quote</a> form without parens <a href="motion.txt.html#is" class="d">is</a> allowed. Using
<span class="e">require"mypack"</span> or <span class="e">require('mypack')</span> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> prefix does NOT work.

You can use <span class="e">v:lua</span> in "func" <a href="options.txt.html#options" class="d">options</a> like <a href="options.txt.html#%27tagfunc%27" class="o">'tagfunc'</a>, <a href="options.txt.html#%27omnifunc%27" class="o">'omnifunc'</a>, etc.
For example consider the following <a href="lua.txt.html#Lua" class="d">Lua</a> omnifunc handler: 
<span class="e"></span>
<span class="e">    function mymod.omnifunc(findstart, base)</span>
<span class="e">      if findstart == 1 then</span>
<span class="e">        return 0</span>
<span class="e">      else</span>
<span class="e">        return {'stuff', 'steam', 'strange things'}</span>
<span class="e">      end</span>
<span class="e">    end</span>
<span class="e">    -- Note: The module ("mymod") must be a Lua global, or use require() as</span>
<span class="e">    -- shown above to access it from a package.</span>
<span class="e">    vim.bo[buf].omnifunc = 'v:lua.mymod.omnifunc'</span>
<span class="e"></span>
You can also use <span class="e">v:lua</span> to call <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#functions" class="d">functions</a> <a href="motion.txt.html#as" class="d">as</a> Vimscript <a href="vimeval.txt.html#method" class="l">method</a>s: 
<span class="e">    :eval arg1-&gt;v:lua.somemod.func(arg2)</span>

<span class="n">Note:</span> <span class="e">v:lua</span> without <a href="insert.txt.html#a" class="d">a</a> call <a href="motion.txt.html#is" class="d">is</a> not allowed in <a href="insert.txt.html#a" class="d">a</a> Vimscript expression:
<a href="vimeval.txt.html#Funcref" class="l">Funcref</a><a href="change.txt.html#s" class="d">s</a> cannot represent <a href="lua.txt.html#Lua" class="d">Lua</a> functions. The following are errors: 
<span class="e"></span>
<span class="e">    let g:Myvar = v:lua.myfunc        " Error</span>
<span class="e">    call SomeFunc(v:lua.mycallback)   " Error</span>
<span class="e">    let g:foo = v:lua                 " Error</span>
<span class="e">    let g:foo = v:['lua']             " Error</span>

<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> standard modules                                              <span id="lua-stdlib" class="t">lua-stdlib</span>

The Nvim <a href="lua.txt.html#Lua" class="d">Lua</a> "standard library" (stdlib) <a href="motion.txt.html#is" class="d">is</a> the <span class="e">vim</span> module, which exposes
<a href="various.txt.html#various" class="d">various</a> <a href="vimeval.txt.html#functions" class="d">functions</a> and sub-modules. It <a href="motion.txt.html#is" class="d">is</a> always loaded, thus <span class="e">require("vim")</span>
<a href="motion.txt.html#is" class="d">is</a> unnecessary.

You can peek <a href="motion.txt.html#at" class="d">at</a> the module properties: 
<span class="e"></span>
<span class="e">    :lua vim.print(vim)</span>
<span class="e"></span>
Result <a href="motion.txt.html#is" class="d">is</a> something like this: 
<span class="e"></span>
<span class="e">    {</span>
<span class="e">      _os_proc_children = &lt;function 1&gt;,</span>
<span class="e">      _os_proc_info = &lt;function 2&gt;,</span>
<span class="e">      ...</span>
<span class="e">      api = {</span>
<span class="e">        nvim__id = &lt;function 5&gt;,</span>
<span class="e">        nvim__id_array = &lt;function 6&gt;,</span>
<span class="e">        ...</span>
<span class="e">      },</span>
<span class="e">      deepcopy = &lt;function 106&gt;,</span>
<span class="e">      gsplit = &lt;function 107&gt;,</span>
<span class="e">      ...</span>
<span class="e">    }</span>
<span class="e"></span>
To find documentation on e.g. the "deepcopy" function: 
<span class="e"></span>
<span class="e">    :help vim.deepcopy()</span>
<span class="e"></span>
<span class="n">Note</span> that underscore-prefixed <a href="vimeval.txt.html#functions" class="d">functions</a> (e.g. "_os_proc_children"<a href="motion.txt.html#%29" class="d">)</a> are
internal/private and must not be used by plugins.

<span class="h">------------------------------------------------------------------------------</span>
<span class="c">VIM.UV</span>                                                   <span id="lua-loop" class="t">lua-loop</span> <span id="vim.uv" class="t">vim.uv</span>

<span class="e">vim.uv</span> exposes the "<a href="luvref.txt.html#luv" class="d">luv</a>" <a href="lua.txt.html#Lua" class="d">Lua</a> bindings <a href="luaref.txt.html#for" class="d">for</a> the libUV library that Nvim uses
<a href="luaref.txt.html#for" class="d">for</a> networking, filesystem, and process management, see <a href="luvref.txt.html#luvref.txt" class="l">luvref.txt</a><a href="repeat.txt.html#." class="d">.</a>
In particular, <a href="motion.txt.html#it" class="d">it</a> allows interacting with the main Nvim <a href="luvref.txt.html#luv-event-loop" class="l">luv-event-loop</a><a href="repeat.txt.html#." class="d">.</a>

                                                    <span id="E5560" class="t">E5560</span> <span id="lua-loop-callbacks" class="t">lua-loop-callbacks</span>
It <a href="motion.txt.html#is" class="d">is</a> an error to directly invoke <span class="e">vim.api</span> <a href="vimeval.txt.html#functions" class="d">functions</a> (except <a href="api.txt.html#api-fast" class="l">api-fast</a><a href="motion.txt.html#%29" class="d">)</a> in
<span class="e">vim.uv</span> callbacks. For example, this <a href="motion.txt.html#is" class="d">is</a> an error: 
<span class="e"></span>
<span class="e">    local timer = vim.uv.new_timer()</span>
<span class="e">    timer:start(1000, 0, function()</span>
<span class="e">      vim.api.nvim_command('echomsg "test"')</span>
<span class="e">    end)</span>

To avoid the error use <a href="lua.txt.html#vim.schedule_wrap%28%29" class="l">vim.schedule_wrap()</a> to defer the callback: 
<span class="e"></span>
<span class="e">    local timer = vim.uv.new_timer()</span>
<span class="e">    timer:start(1000, 0, vim.schedule_wrap(function()</span>
<span class="e">      vim.api.nvim_command('echomsg "test"')</span>
<span class="e">    end))</span>

(For one-shot timers, see <a href="lua.txt.html#vim.defer_fn%28%29" class="l">vim.defer_fn()</a><a href="motion.txt.html#%2C" class="d">,</a> which automatically adds the
wrapping.)

Example: <a href="repeat.txt.html#repeating" class="d">repeating</a> <a href="vimfn.txt.html#timer" class="d">timer</a>
    1. Save this code to <a href="insert.txt.html#a" class="d">a</a> file.
    2. Execute <a href="motion.txt.html#it" class="d">it</a> with "<a href="lua.txt.html#%3Aluafile" class="d">:luafile</a> <a href="motion.txt.html#%25" class="d">%</a>"<a href="repeat.txt.html#." class="d">.</a> 
<span class="e"></span>
<span class="e">    -- Create a timer handle (implementation detail: uv_timer_t).</span>
<span class="e">    local timer = vim.uv.new_timer()</span>
<span class="e">    local i = 0</span>
<span class="e">    -- Waits 1000ms, then repeats every 750ms until timer:close().</span>
<span class="e">    timer:start(1000, 750, function()</span>
<span class="e">      print('timer invoked! i='..tostring(i))</span>
<span class="e">      if i &gt; 4 then</span>
<span class="e">        timer:close()  -- Always close handles to avoid leaks.</span>
<span class="e">      end</span>
<span class="e">      i = i + 1</span>
<span class="e">    end)</span>
<span class="e">    print('sleeping');</span>

Example: File-change detection                                    <span id="watch-file" class="t">watch-file</span>
    1. Save this code to <a href="insert.txt.html#a" class="d">a</a> file.
    2. Execute <a href="motion.txt.html#it" class="d">it</a> with "<a href="lua.txt.html#%3Aluafile" class="d">:luafile</a> <a href="motion.txt.html#%25" class="d">%</a>"<a href="repeat.txt.html#." class="d">.</a>
    3. Use ":Watch <a href="motion.txt.html#%25" class="d">%</a>" to watch any file.
    4. Try editing the file from another text editor.
    5. Observe that the file reloads in Nvim (because on_change() calls
       <a href="editing.txt.html#%3Achecktime" class="l">:checktime</a>). 
<span class="e"></span>
<span class="e">    local w = vim.uv.new_fs_event()</span>
<span class="e">    local function on_change(err, fname, status)</span>
<span class="e">      -- Do work...</span>
<span class="e">      vim.api.nvim_command('checktime')</span>
<span class="e">      -- Debounce: stop/start.</span>
<span class="e">      w:stop()</span>
<span class="e">      watch_file(fname)</span>
<span class="e">    end</span>
<span class="e">    function watch_file(fname)</span>
<span class="e">      local fullpath = vim.api.nvim_call_function(</span>
<span class="e">        'fnamemodify', {fname, ':p'})</span>
<span class="e">      w:start(fullpath, {}, vim.schedule_wrap(function(...)</span>
<span class="e">        on_change(...) end))</span>
<span class="e">    end</span>
<span class="e">    vim.api.nvim_command(</span>
<span class="e">      "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('&lt;args&gt;'))")</span>

                                                         <span id="inotify-limitations" class="t">inotify-limitations</span>
When on Linux you may need to increase the maximum number of <span class="e">inotify</span> watches
and queued <a href="autocmd.txt.html#events" class="d">events</a> <a href="motion.txt.html#as" class="d">as</a> the default limit can be too low. To increase the limit,
run: &gt;bash
    sysctl fs.inotify.max_user_watches=494462
<a href="change.txt.html#%3C" class="d">&lt;</a>
This will increase the limit to 494462 watches and queued events. These lines
can be added to <span class="e">/etc/sysctl.conf</span> to make the changes persistent.

<span class="n">Note</span> that each watch <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> structure in the Kernel, thus available memory <a href="motion.txt.html#is" class="d">is</a>
also <a href="insert.txt.html#a" class="d">a</a> bottleneck <a href="luaref.txt.html#for" class="d">for</a> using inotify. In fact, <a href="insert.txt.html#a" class="d">a</a> watch can take up to 1KB of
space. This means <a href="insert.txt.html#a" class="d">a</a> million watches could result in 1GB of extra RAM usage.

Example: TCP echo-server                                          <span id="tcp-server" class="t">tcp-server</span>
    1. Save this code to <a href="insert.txt.html#a" class="d">a</a> file.
    2. Execute <a href="motion.txt.html#it" class="d">it</a> with "<a href="lua.txt.html#%3Aluafile" class="d">:luafile</a> <a href="motion.txt.html#%25" class="d">%</a>"<a href="repeat.txt.html#." class="d">.</a>
    3. <span class="n">Note</span> the port number.
    4. Connect from any TCP client (e.g. "nc 0.0.0.0 36795"): 
<span class="e"></span>
<span class="e">    local function create_server(host, port, on_connect)</span>
<span class="e">      local server = vim.uv.new_tcp()</span>
<span class="e">      server:bind(host, port)</span>
<span class="e">      server:listen(128, function(err)</span>
<span class="e">        assert(not err, err)  -- Check for errors.</span>
<span class="e">        local sock = vim.uv.new_tcp()</span>
<span class="e">        server:accept(sock)  -- Accept client connection.</span>
<span class="e">        on_connect(sock)  -- Start reading messages.</span>
<span class="e">      end)</span>
<span class="e">      return server</span>
<span class="e">    end</span>
<span class="e">    local server = create_server('0.0.0.0', 0, function(sock)</span>
<span class="e">      sock:read_start(function(err, chunk)</span>
<span class="e">        assert(not err, err)  -- Check for errors.</span>
<span class="e">        if chunk then</span>
<span class="e">          sock:write(chunk)  -- Echo received messages to the channel.</span>
<span class="e">        else  -- EOF (stream closed).</span>
<span class="e">          sock:close()  -- Always close handles to avoid leaks.</span>
<span class="e">        end</span>
<span class="e">      end)</span>
<span class="e">    end)</span>
<span class="e">    print('TCP echo-server listening on port: '..server:getsockname().port)</span>

Multithreading                                            <span id="lua-loop-threading" class="t">lua-loop-threading</span>

Plugins can perform work in separate (os-level) threads using the threading
APIs in luv, <a href="luaref.txt.html#for" class="d">for</a> instance <span class="e">vim.uv.new_thread</span>. Each thread has its own
separate <a href="lua.txt.html#Lua" class="d">Lua</a> interpreter state, with no access to <a href="lua.txt.html#Lua" class="d">Lua</a> globals on the main
thread. Neither can the editor state (buffers, windows, etc) be directly
accessed from threads.

<a href="insert.txt.html#A" class="d">A</a> subset of the <span class="e">vim.*</span> stdlib <a href="motion.txt.html#is" class="d">is</a> available in threads, including:

<a href="motion.txt.html#-" class="d">-</a> <span class="e">vim.uv</span> with <a href="insert.txt.html#a" class="d">a</a> separate event loop per thread.
<a href="motion.txt.html#-" class="d">-</a> <span class="e">vim.mpack</span> and <span class="e">vim.json</span> (useful <a href="luaref.txt.html#for" class="d">for</a> serializing <a href="message.txt.html#messages" class="d">messages</a> between threads)
<a href="motion.txt.html#-" class="d">-</a> <span class="e">require</span> in threads can use <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="repeat.txt.html#packages" class="d">packages</a> from the global <a href="luaref.txt.html#package.path" class="l">package.path</a>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">print()</span> and <span class="e">vim.inspect</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">vim.diff</span>
<a href="motion.txt.html#-" class="d">-</a> Most utility <a href="vimeval.txt.html#functions" class="d">functions</a> in <span class="e">vim.*</span> that work with pure <a href="lua.txt.html#Lua" class="d">Lua</a> values, like
  <span class="e">vim.split</span>, <span class="e">vim.tbl_*</span>, <span class="e">vim.list_*</span>, etc.
<a href="motion.txt.html#-" class="d">-</a> <span class="e">vim.is_thread()</span> returns true from <a href="insert.txt.html#a" class="d">a</a> non-main thread.


<span class="h">==============================================================================</span>
<span class="c">VIM.HL</span>                                                                <span id="vim.hl" class="t">vim.hl</span>

vim.hl.on_yank({opts})                                      <span id="vim.hl.on_yank%28%29" class="t">vim.hl.on_yank()</span>
    Highlight the yanked text during <a href="insert.txt.html#a" class="d">a</a> <a href="autocmd.txt.html#TextYankPost" class="l">TextYankPost</a> event.

    Add the following to your <span class="e">init.vim</span>: 
<span class="e">        autocmd TextYankPost * silent! lua vim.hl.on_yank {higroup='Visual', timeout=300}</span>


<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table?`) Optional parameters
                • higroup highlight group <a href="luaref.txt.html#for" class="d">for</a> yanked region (default
                  "IncSearch"<a href="motion.txt.html#%29" class="d">)</a>
                • timeout time in ms before highlight <a href="motion.txt.html#is" class="d">is</a> cleared (default 150)
                • on_macro highlight when executing <a href="repeat.txt.html#macro" class="d">macro</a> (default false)
                • on_visual highlight when yanking visual selection (default
                  true)
                • event event structure (default vim.v.event)
                • priority integer priority (default
                  <a href="lua.txt.html#vim.hl.priorities" class="l">vim.hl.priorities</a><span class="e">.user</span>)

<a href="lua.txt.html#vim.hl.priorities" class="d">vim.hl.priorities</a>                                          <span id="vim.hl.priorities" class="t">vim.hl.priorities</span>
    Table with default priorities used <a href="luaref.txt.html#for" class="d">for</a> highlighting:
    • <span class="e">syntax</span>: <span class="e">50</span>, used <a href="luaref.txt.html#for" class="d">for</a> standard <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighting
    • <span class="e">treesitter</span>: <span class="e">100</span>, used <a href="luaref.txt.html#for" class="d">for</a> treesitter-based highlighting
    • <span class="e">semantic_tokens</span>: <span class="e">125</span>, used <a href="luaref.txt.html#for" class="d">for</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> semantic token highlighting
    • <span class="e">diagnostics</span>: <span class="e">150</span>, used <a href="luaref.txt.html#for" class="d">for</a> code analysis such <a href="motion.txt.html#as" class="d">as</a> diagnostics
    • <span class="e">user</span>: <span class="e">200</span>, used <a href="luaref.txt.html#for" class="d">for</a> user-triggered highlights such <a href="motion.txt.html#as" class="d">as</a> <a href="lsp.txt.html#LSP" class="d">LSP</a> document
      symbols or <span class="e">on_yank</span> autocommands

                                                              <span id="vim.hl.range%28%29" class="t">vim.hl.range()</span>
vim.hl.range({bufnr}, <span class="s">{ns}</span>, <span class="s">{higroup}</span>, <span class="s">{start}</span>, <span class="s">{finish}</span>, <span class="s">{opts}</span>)
    Apply highlight group to range of text.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>    (`integer`) Buffer number to apply highlighting to
      • <span class="s">{ns}</span>       (`integer`) Namespace to add highlight to
      • <span class="s">{higroup}</span>  (`string`) Highlight group to use <a href="luaref.txt.html#for" class="d">for</a> highlighting
      • <span class="s">{start}</span>    (`integer[]|string`) Start of region <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> (line, column)
                   tuple or <a href="vimeval.txt.html#string" class="d">string</a> accepted by <a href="vimfn.txt.html#getpos%28%29" class="l">getpos()</a>
      • <span class="s">{finish}</span>   (`integer[]|string`) End of region <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> (line, column)
                   tuple or <a href="vimeval.txt.html#string" class="d">string</a> accepted by <a href="vimfn.txt.html#getpos%28%29" class="l">getpos()</a>
      • <span class="s">{opts}</span>     (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                   • <span class="s">{regtype}</span>? (`string`, default: <span class="e">'v'</span> i.e. charwise) Type
                     of range. See <a href="vimfn.txt.html#getregtype%28%29" class="l">getregtype()</a>
                   • <span class="s">{inclusive}</span>? (`boolean`, default: <span class="e">false</span>) Indicates
                     whether the range <a href="motion.txt.html#is" class="d">is</a> end-inclusive
                   • <span class="s">{priority}</span>? (`integer`, default:
                     <span class="e">vim.hl.priorities.user</span>) Highlight priority
                   • <span class="s">{timeout}</span>? (`integer`, default: -1 no timeout) Time in ms
                     before highlight <a href="motion.txt.html#is" class="d">is</a> cleared

<span class="h">    Return (multiple): </span>
        (`uv.uv_timer_t?`) range_timer <a href="insert.txt.html#A" class="d">A</a> <a href="vimfn.txt.html#timer" class="d">timer</a> which manages how much time the
        highlight has left
        (`fun()?`) range_clear <a href="insert.txt.html#A" class="d">A</a> function which allows clearing the highlight
        manually. nil <a href="motion.txt.html#is" class="d">is</a> returned if timeout <a href="motion.txt.html#is" class="d">is</a> not specified


<span class="h">==============================================================================</span>
<span class="c">VIM.DIFF</span>                                                            <span id="vim.diff" class="t">vim.diff</span>

vim.diff({a}, <span class="s">{b}</span>, <span class="s">{opts}</span>)                                        <span id="vim.diff%28%29" class="t">vim.diff()</span>
    Run <a href="diff.txt.html#diff" class="d">diff</a> on strings <span class="s">{a}</span> and <span class="s">{b}</span>. Any indices returned by this function,
    either directly or via callback arguments, are 1-based.

    Examples: 
<span class="e">        vim.diff('a\n', 'b\nc\n')</span>
<span class="e">        -- =&gt;</span>
<span class="e">        -- @@ -1 +1,2 @@</span>
<span class="e">        -- -a</span>
<span class="e">        -- +b</span>
<span class="e">        -- +c</span>
<span class="e"></span>
<span class="e">        vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})</span>
<span class="e">        -- =&gt;</span>
<span class="e">        -- {</span>
<span class="e">        --   {1, 1, 1, 2}</span>
<span class="e">        -- }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{a}</span>     (`string`) First <a href="vimeval.txt.html#string" class="d">string</a> to compare
      • <span class="s">{b}</span>     (`string`) Second <a href="vimeval.txt.html#string" class="d">string</a> to compare
      • <span class="s">{opts}</span>  (`table?`) Optional parameters:
                • <span class="s">{on_hunk}</span>?
                  (`fun(start_a: integer, count_a: integer, start_b: integer, count_b: integer): integer?`)
                  Invoked <a href="luaref.txt.html#for" class="d">for</a> each hunk in the diff. Return <a href="insert.txt.html#a" class="d">a</a> negative number
                  to cancel the callback <a href="luaref.txt.html#for" class="d">for</a> any remaining hunks. Arguments:
                  • <span class="e">start_a</span> (`integer`): Start line of hunk in <span class="s">{a}</span>.
                  • <span class="e">count_a</span> (`integer`): Hunk size in <span class="s">{a}</span>.
                  • <span class="e">start_b</span> (`integer`): Start line of hunk in <span class="s">{b}</span>.
                  • <span class="e">count_b</span> (`integer`): Hunk size in <span class="s">{b}</span>.
                • <span class="s">{result_type}</span>? (`'unified'|<span class="o">'indices'</span>`, default: <span class="e">'unified'</span>)
                  Form of the returned diff:
                  • <span class="e">unified</span>: <a href="vimeval.txt.html#String" class="d">String</a> in unified format.
                  • <span class="e">indices</span>: Array of hunk locations. <span class="n">Note:</span> This option <a href="motion.txt.html#is" class="d">is</a>
                    ignored if <span class="e">on_hunk</span> <a href="motion.txt.html#is" class="d">is</a> used.
                • <span class="s">{linematch}</span>? (`boolean|integer`) Run linematch on the
                  resulting hunks from xdiff. When integer, only hunks upto
                  this size in lines are run through linematch. Requires
                  `result_type <a href="change.txt.html#%3D" class="d">=</a> indices`, ignored otherwise.
                • <span class="s">{algorithm}</span>? (`'myers'<span class="l">'minimal'</span><span class="o">'patience'</span>|<span class="o">'histogram'</span>`,
                  default: <span class="e">'myers'</span>) Diff algorithm to use. Values:
                  • <span class="e">myers</span>: the default algorithm
                  • <span class="e">minimal</span>: spend extra time to generate the smallest
                    possible <a href="diff.txt.html#diff" class="d">diff</a>
                  • <span class="e">patience</span>: patience <a href="diff.txt.html#diff" class="d">diff</a> algorithm
                  • <span class="e">histogram</span>: histogram <a href="diff.txt.html#diff" class="d">diff</a> algorithm
                • <span class="s">{ctxlen}</span>? (`integer`) <a href="repeat.txt.html#Context" class="d">Context</a> length
                • <span class="s">{interhunkctxlen}</span>? (`integer`) Inter hunk <a href="repeat.txt.html#context" class="d">context</a> length
                • <span class="s">{ignore_whitespace}</span>? (`boolean`) Ignore <a href="pattern.txt.html#whitespace" class="d">whitespace</a>
                • <span class="s">{ignore_whitespace_change}</span>? (`boolean`) Ignore <a href="pattern.txt.html#whitespace" class="d">whitespace</a>
                  change
                • <span class="s">{ignore_whitespace_change_at_eol}</span>? (`boolean`) Ignore
                  <a href="pattern.txt.html#whitespace" class="d">whitespace</a> change <a href="motion.txt.html#at" class="d">at</a> end-of-line.
                • <span class="s">{ignore_cr_at_eol}</span>? (`boolean`) Ignore carriage return <a href="motion.txt.html#at" class="d">at</a>
                  end-of-line
                • <span class="s">{ignore_blank_lines}</span>? (`boolean`) Ignore blank lines
                • <span class="s">{indent_heuristic}</span>? (`boolean`) Use the indent heuristic <a href="luaref.txt.html#for" class="d">for</a>
                  the internal <a href="diff.txt.html#diff" class="d">diff</a> library.

<span class="h">    Return: </span>
        (`string|integer[][]?`) See <span class="s">{opts.result_type}</span>. <span class="e">nil</span> if
        <span class="s">{opts.on_hunk}</span> <a href="motion.txt.html#is" class="d">is</a> given.


<span class="h">==============================================================================</span>
<span class="c">VIM.MPACK</span>                                                          <span id="vim.mpack" class="t">vim.mpack</span>

This module provides encoding and decoding of <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="index.txt.html#objects" class="d">objects</a> to and from
msgpack-encoded strings. Supports <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a> and <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a><a href="repeat.txt.html#." class="d">.</a>


vim.mpack.decode({str})                                   <span id="vim.mpack.decode%28%29" class="t">vim.mpack.decode()</span>
    Decodes (or "unpacks"<a href="motion.txt.html#%29" class="d">)</a> the msgpack-encoded <span class="s">{str}</span> to <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> object.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`)

<span class="h">    Return: </span>
        (`any`)

vim.mpack.encode({obj})                                   <span id="vim.mpack.encode%28%29" class="t">vim.mpack.encode()</span>
    Encodes (or "packs"<a href="motion.txt.html#%29" class="d">)</a> <a href="lua.txt.html#Lua" class="d">Lua</a> object <span class="s">{obj}</span> <a href="motion.txt.html#as" class="d">as</a> msgpack in <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> string.

<span class="h">    Parameters: </span>
      • <span class="s">{obj}</span>  (`any`)

<span class="h">    Return: </span>
        (`string`)


<span class="h">==============================================================================</span>
<span class="c">VIM.JSON</span>                                                            <span id="vim.json" class="t">vim.json</span>

This module provides encoding and decoding of <a href="lua.txt.html#Lua" class="d">Lua</a> <a href="index.txt.html#objects" class="d">objects</a> to and from
JSON-encoded strings. Supports <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a> and <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a><a href="repeat.txt.html#." class="d">.</a>


vim.json.decode({str}, <span class="s">{opts}</span>)                             <span id="vim.json.decode%28%29" class="t">vim.json.decode()</span>
    Decodes (or "unpacks"<a href="motion.txt.html#%29" class="d">)</a> the JSON-encoded <span class="s">{str}</span> to <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> object.
    • Decodes JSON "null" <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a> (controllable by <span class="s">{opts}</span>, see below).
    • Decodes empty object <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a><a href="repeat.txt.html#." class="d">.</a>
    • Decodes empty array <a href="motion.txt.html#as" class="d">as</a> <span class="e">{}</span> (empty <a href="lua.txt.html#Lua" class="d">Lua</a> table).

    Example: 
<span class="e">        vim.print(vim.json.decode('{"bar":[],"foo":{},"zub":null}'))</span>
<span class="e">        -- { bar = {}, foo = vim.empty_dict(), zub = vim.NIL }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>   (`string`) Stringified JSON data.
      • <span class="s">{opts}</span>  (`table&lt;string,any&gt;?`) Options table with keys:
                • luanil: (table) Table with keys:
                  • object: (boolean) When true, converts <span class="e">null</span> in JSON
                    <a href="index.txt.html#objects" class="d">objects</a> to <a href="lua.txt.html#Lua" class="d">Lua</a> <span class="e">nil</span> instead of <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a><a href="repeat.txt.html#." class="d">.</a>
                  • array: (boolean) When true, converts <span class="e">null</span> in JSON arrays
                    to <a href="lua.txt.html#Lua" class="d">Lua</a> <span class="e">nil</span> instead of <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return: </span>
        (`any`)

vim.json.encode({obj}, <span class="s">{opts}</span>)                             <span id="vim.json.encode%28%29" class="t">vim.json.encode()</span>
    Encodes (or "packs"<a href="motion.txt.html#%29" class="d">)</a> <a href="lua.txt.html#Lua" class="d">Lua</a> object <span class="s">{obj}</span> <a href="motion.txt.html#as" class="d">as</a> JSON in <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> string.

<span class="h">    Parameters: </span>
      • <span class="s">{obj}</span>   (`any`)
      • <span class="s">{opts}</span>  (`table&lt;string,any&gt;?`) Options table with keys:
                • escape_slash: (boolean) (default false) Escape slash
                  characters "<a href="pattern.txt.html#%2F" class="d">/</a>" in <a href="vimeval.txt.html#string" class="d">string</a> values.

<span class="h">    Return: </span>
        (`string`)


<span class="h">==============================================================================</span>
<span class="c">VIM.BASE64</span>                                                        <span id="vim.base64" class="t">vim.base64</span>

vim.base64.decode({str})                                 <span id="vim.base64.decode%28%29" class="t">vim.base64.decode()</span>
    Decode <a href="insert.txt.html#a" class="d">a</a> Base64 encoded string.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) Base64 encoded <a href="vimeval.txt.html#string" class="d">string</a>

<span class="h">    Return: </span>
        (`string`) Decoded <a href="vimeval.txt.html#string" class="d">string</a>

vim.base64.encode({str})                                 <span id="vim.base64.encode%28%29" class="t">vim.base64.encode()</span>
    Encode <span class="s">{str}</span> using Base64.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to encode

<span class="h">    Return: </span>
        (`string`) Encoded <a href="vimeval.txt.html#string" class="d">string</a>


<span class="h">==============================================================================</span>
<span class="c">VIM.SPELL</span>                                                          <span id="vim.spell" class="t">vim.spell</span>

vim.spell.check({str})                                     <span id="vim.spell.check%28%29" class="t">vim.spell.check()</span>
    Check <span class="s">{str}</span> <a href="luaref.txt.html#for" class="d">for</a> spelling errors. Similar to the Vimscript function
    <a href="vimfn.txt.html#spellbadword%28%29" class="l">spellbadword()</a><a href="repeat.txt.html#." class="d">.</a>

    <span class="n">Note:</span> The behaviour of this function <a href="motion.txt.html#is" class="d">is</a> dependent on: <a href="options.txt.html#%27spelllang%27" class="o">'spelllang'</a>,
    <a href="options.txt.html#%27spellfile%27" class="o">'spellfile'</a>, <a href="options.txt.html#%27spellcapcheck%27" class="o">'spellcapcheck'</a> and <a href="options.txt.html#%27spelloptions%27" class="o">'spelloptions'</a> which can all be local to
    the buffer. Consider calling this with <a href="api.txt.html#nvim_buf_call%28%29" class="l">nvim_buf_call()</a><a href="repeat.txt.html#." class="d">.</a>

    Example: 
<span class="e">        vim.spell.check("the quik brown fox")</span>
<span class="e">        -- =&gt;</span>
<span class="e">        -- {</span>
<span class="e">        --     {'quik', 'bad', 5}</span>
<span class="e">        -- }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`)

<span class="h">    Return: </span>
        (`[string, <span class="o">'bad'</span><span class="l">'rare'</span><span class="o">'local'</span>|<span class="o">'caps'</span>, integer][]`) <a href="vimeval.txt.html#List" class="d">List</a> of tuples
        with three items:
        • The badly spelled word.
        • The type of the spelling error: "bad" spelling mistake "rare" rare
          <a href="motion.txt.html#word" class="d">word</a> "local" <a href="motion.txt.html#word" class="d">word</a> only valid in another region "caps" <a href="motion.txt.html#word" class="d">word</a> should
          start with Capital
        • The position in <span class="s">{str}</span> where the <a href="motion.txt.html#word" class="d">word</a> begins.


<span class="h">==============================================================================</span>
<span class="c">VIM</span>                                                              <span id="vim.builtin" class="t">vim.builtin</span>


vim.api.{func}({...})                                                <span id="vim.api" class="t">vim.api</span>
    Invokes Nvim <a href="api.txt.html#API" class="l">API</a> function <span class="s">{func}</span> with arguments <span class="s">{...}</span>.
    Example: call the "<a href="api.txt.html#nvim_get_current_line%28%29" class="d">nvim_get_current_line()</a>" <a href="api.txt.html#API" class="d">API</a> function: 
<span class="e">        print(tostring(vim.api.nvim_get_current_line()))</span>
<span class="e"></span>
<a href="lua.txt.html#vim.NIL" class="d">vim.NIL</a>                                                              <span id="vim.NIL" class="t">vim.NIL</span>
    Special value representing NIL in <a href="api.txt.html#RPC" class="l">RPC</a> and <a href="vvars.txt.html#v%3Anull" class="l">v:null</a> in Vimscript
    conversion, and similar cases. <a href="lua.txt.html#Lua" class="d">Lua</a> <span class="e">nil</span> cannot be used <a href="motion.txt.html#as" class="d">as</a> part of <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a>
    table representing <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#Dictionary" class="d">Dictionary</a> or Array, because <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> treated <a href="motion.txt.html#as" class="d">as</a>
    missing: <a href="motion.txt.html#%60%7B" class="d">`{</a>"foo"<a href="motion.txt.html#%2C" class="d">,</a> nil}` <a href="motion.txt.html#is" class="d">is</a> the same <a href="motion.txt.html#as" class="d">as</a> <span class="e">{"foo"}</span>.

<a href="lua.txt.html#vim.type_idx" class="d">vim.type_idx</a>                                                    <span id="vim.type_idx" class="t">vim.type_idx</span>
    Type <a href="index.txt.html#index" class="d">index</a> <a href="luaref.txt.html#for" class="d">for</a> use in <a href="lua.txt.html#lua-special-tbl" class="l">lua-special-tbl</a><a href="repeat.txt.html#." class="d">.</a> Specifying one of the values from
    <a href="lua.txt.html#vim.types" class="l">vim.types</a> allows typing the empty table (it <a href="motion.txt.html#is" class="d">is</a> unclear whether empty <a href="lua.txt.html#Lua" class="d">Lua</a>
    table represents empty <a href="vimeval.txt.html#list" class="d">list</a> or empty array) and forcing integral numbers
    to be <a href="vimeval.txt.html#Float" class="l">Float</a><a href="repeat.txt.html#." class="d">.</a> See <a href="lua.txt.html#lua-special-tbl" class="l">lua-special-tbl</a> <a href="luaref.txt.html#for" class="d">for</a> more details.

<a href="lua.txt.html#vim.val_idx" class="d">vim.val_idx</a>                                                      <span id="vim.val_idx" class="t">vim.val_idx</span>
    Value <a href="index.txt.html#index" class="d">index</a> <a href="luaref.txt.html#for" class="d">for</a> tables representing <a href="vimeval.txt.html#Float" class="l">Float</a>s. <a href="insert.txt.html#A" class="d">A</a> table representing
    floating-point value 1.0 looks like this: 
<span class="e">        {</span>
<span class="e">          [vim.type_idx] = vim.types.float,</span>
<span class="e">          [vim.val_idx] = 1.0,</span>
<span class="e">        }</span>
    See also <a href="lua.txt.html#vim.type_idx" class="l">vim.type_idx</a> and <a href="lua.txt.html#lua-special-tbl" class="l">lua-special-tbl</a><a href="repeat.txt.html#." class="d">.</a>

<a href="lua.txt.html#vim.types" class="d">vim.types</a>                                                          <span id="vim.types" class="t">vim.types</span>
    Table with possible values <a href="luaref.txt.html#for" class="d">for</a> <a href="lua.txt.html#vim.type_idx" class="l">vim.type_idx</a><a href="repeat.txt.html#." class="d">.</a> Contains two sets of
    key-value pairs: first maps possible values <a href="luaref.txt.html#for" class="d">for</a> <a href="lua.txt.html#vim.type_idx" class="l">vim.type_idx</a> to
    human-readable strings, second maps human-readable type names to values
    <a href="luaref.txt.html#for" class="d">for</a> <a href="lua.txt.html#vim.type_idx" class="l">vim.type_idx</a><a href="repeat.txt.html#." class="d">.</a> Currently contains pairs <a href="luaref.txt.html#for" class="d">for</a> <span class="e">float</span>, <span class="e">array</span> and
        <span class="e">dictionary</span> types.

    <span class="n">Note:</span> One must expect that values corresponding to <span class="e">vim.types.float</span>,
    <span class="e">vim.types.array</span> and <span class="e">vim.types.dictionary</span> fall under only two following
    assumptions:
    1. Value may serve both <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> key and <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> value in <a href="insert.txt.html#a" class="d">a</a> table. Given the
       properties of <a href="lua.txt.html#Lua" class="d">Lua</a> tables this basically means “value <a href="motion.txt.html#is" class="d">is</a> not <span class="e">nil</span>”<a href="repeat.txt.html#." class="d">.</a>
    2. For each value in <span class="e">vim.types</span> table <span class="e">vim.types[vim.types[value]]</span> <a href="motion.txt.html#is" class="d">is</a> the
       same <a href="motion.txt.html#as" class="d">as</a> <span class="e">value</span>.
    No other restrictions are <a href="change.txt.html#put" class="d">put</a> on types, and <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> not guaranteed that
    values corresponding to <span class="e">vim.types.float</span>, <span class="e">vim.types.array</span> and
    <span class="e">vim.types.dictionary</span> will not change or that <span class="e">vim.types</span> table will only
    contain values <a href="luaref.txt.html#for" class="d">for</a> these three types.

                                                   <span id="log_levels" class="t">log_levels</span> <span id="vim.log.levels" class="t">vim.log.levels</span>
Log levels are one of the values defined in <span class="e">vim.log.levels</span>:

    vim.log.levels.DEBUG
    vim.log.levels.ERROR
    vim.log.levels.INFO
    vim.log.levels.TRACE
    vim.log.levels.WARN
    vim.log.levels.OFF



<a href="lua.txt.html#vim.empty_dict%28%29" class="d">vim.empty_dict()</a>                                            <span id="vim.empty_dict%28%29" class="t">vim.empty_dict()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> special empty table (marked with <a href="insert.txt.html#a" class="d">a</a> metatable), which Nvim
    converts to an empty dictionary when translating <a href="lua.txt.html#Lua" class="d">Lua</a> values to Vimscript
    or <a href="api.txt.html#API" class="d">API</a> types. Nvim by default converts an empty table <span class="e">{}</span> without this
    <a href="luaref.txt.html#metatable" class="d">metatable</a> to an list/array.

    <span class="n">Note:</span> If numeric keys are present in the table, Nvim ignores the <a href="luaref.txt.html#metatable" class="d">metatable</a>
    marker and converts the <a href="vimeval.txt.html#dict" class="d">dict</a> to <a href="insert.txt.html#a" class="d">a</a> list/array anyway.

<span class="h">    Return: </span>
        (`table`)

vim.iconv({str}, <span class="s">{from}</span>, <span class="s">{to}</span>)                                   <span id="vim.iconv%28%29" class="t">vim.iconv()</span>
    The result <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> String, which <a href="motion.txt.html#is" class="d">is</a> the text <span class="s">{str}</span> converted from encoding
    <span class="s">{from}</span> to encoding <span class="s">{to}</span>. When the conversion fails <span class="e">nil</span> <a href="motion.txt.html#is" class="d">is</a> returned. When
    some characters could not be converted they are replaced with "<a href="pattern.txt.html#%3F" class="d">?</a>"<a href="repeat.txt.html#." class="d">.</a> The
    encoding names are whatever the <a href="vimfn.txt.html#iconv%28%29" class="d">iconv()</a> library function can accept, see
    "<a href="filetype.txt.html#%3AMan" class="d">:Man</a> 3 iconv"<a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>   (`string`) Text to convert
      • <span class="s">{from}</span>  (`string`) Encoding of <span class="s">{str}</span>
      • <span class="s">{to}</span>    (`string`) Target encoding

<span class="h">    Return: </span>
        (`string?`) Converted <a href="vimeval.txt.html#string" class="d">string</a> if conversion succeeds, <span class="e">nil</span> otherwise.

<a href="lua.txt.html#vim.in_fast_event%28%29" class="d">vim.in_fast_event()</a>                                      <span id="vim.in_fast_event%28%29" class="t">vim.in_fast_event()</span>
    Returns true if the code <a href="motion.txt.html#is" class="d">is</a> executing <a href="motion.txt.html#as" class="d">as</a> part of <a href="insert.txt.html#a" class="d">a</a> "fast" event handler,
    where most of the <a href="api.txt.html#API" class="d">API</a> <a href="motion.txt.html#is" class="d">is</a> disabled. These are low-level <a href="autocmd.txt.html#events" class="d">events</a> (e.g.
    <a href="lua.txt.html#lua-loop-callbacks" class="l">lua-loop-callbacks</a><a href="motion.txt.html#%29" class="d">)</a> which can be invoked whenever Nvim polls <a href="luaref.txt.html#for" class="d">for</a> input.
    When this <a href="motion.txt.html#is" class="d">is</a> <span class="e">false</span> most <a href="api.txt.html#API" class="d">API</a> <a href="vimeval.txt.html#functions" class="d">functions</a> are callable (but may be subject
    to other restrictions such <a href="motion.txt.html#as" class="d">as</a> <a href="vimeval.txt.html#textlock" class="l">textlock</a>).

vim.rpcnotify({channel}, <span class="s">{method}</span>, <span class="s">{...}</span>)                    <span id="vim.rpcnotify%28%29" class="t">vim.rpcnotify()</span>
    Sends <a href="autocmd.txt.html#%7Bevent%7D" class="s">{event}</a> to <span class="s">{channel}</span> via <a href="api.txt.html#RPC" class="l">RPC</a> and returns immediately. If <span class="s">{channel}</span>
    <a href="motion.txt.html#is" class="d">is</a> 0, the event <a href="motion.txt.html#is" class="d">is</a> broadcast to all channels.

    This function also works in <a href="insert.txt.html#a" class="d">a</a> fast callback <a href="lua.txt.html#lua-loop-callbacks" class="l">lua-loop-callbacks</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{channel}</span>  (`integer`)
      • <span class="s">{method}</span>   (`string`)
      • <span class="s">{...}</span>      (`any?`)

vim.rpcrequest({channel}, <span class="s">{method}</span>, <span class="s">{...}</span>)                  <span id="vim.rpcrequest%28%29" class="t">vim.rpcrequest()</span>
    Sends <a href="insert.txt.html#a" class="d">a</a> request to <span class="s">{channel}</span> to invoke <span class="s">{method}</span> via <a href="api.txt.html#RPC" class="l">RPC</a> and blocks until
    <a href="insert.txt.html#a" class="d">a</a> response <a href="motion.txt.html#is" class="d">is</a> received.

    <span class="n">Note:</span> NIL values <a href="motion.txt.html#as" class="d">as</a> part of the return value <a href="motion.txt.html#is" class="d">is</a> represented <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a>
    special value

<span class="h">    Parameters: </span>
      • <span class="s">{channel}</span>  (`integer`)
      • <span class="s">{method}</span>   (`string`)
      • <span class="s">{...}</span>      (`any?`)

vim.schedule({fn})                                            <span id="vim.schedule%28%29" class="t">vim.schedule()</span>
    Schedules <span class="s">{fn}</span> to be invoked soon by the main event-loop. Useful to avoid
    <a href="vimeval.txt.html#textlock" class="l">textlock</a> or other temporary restrictions.

<span class="h">    Parameters: </span>
      • <span class="s">{fn}</span>  (`fun()`)

vim.str_utf_end({str}, <span class="s">{index}</span>)                            <span id="vim.str_utf_end%28%29" class="t">vim.str_utf_end()</span>
    Gets the distance (in bytes) from the last byte of the codepoint
    (character) that <span class="s">{index}</span> points to.

    Examples: 
<span class="e">        -- The character 'æ' is stored as the bytes '\xc3\xa6' (using UTF-8)</span>
<span class="e"></span>
<span class="e">        -- Returns 0 because the index is pointing at the last byte of a character</span>
<span class="e">        vim.str_utf_end('æ', 2)</span>
<span class="e"></span>
<span class="e">        -- Returns 1 because the index is pointing at the penultimate byte of a character</span>
<span class="e">        vim.str_utf_end('æ', 1)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>    (`string`)
      • <span class="s">{index}</span>  (`integer`)

<span class="h">    Return: </span>
        (`integer`)

vim.str_utf_pos({str})                                     <span id="vim.str_utf_pos%28%29" class="t">vim.str_utf_pos()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of the <a href="starting.txt.html#starting" class="d">starting</a> byte positions of each <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> codepoint in the
    given string.

    Embedded NUL bytes are treated <a href="motion.txt.html#as" class="d">as</a> terminating the string.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`)

<span class="h">    Return: </span>
        (`integer[]`)

vim.str_utf_start({str}, <span class="s">{index}</span>)                        <span id="vim.str_utf_start%28%29" class="t">vim.str_utf_start()</span>
    Gets the distance (in bytes) from the <a href="starting.txt.html#starting" class="d">starting</a> byte of the codepoint
    (character) that <span class="s">{index}</span> points to.

    The result can be added to <span class="s">{index}</span> to get the <a href="starting.txt.html#starting" class="d">starting</a> byte of <a href="insert.txt.html#a" class="d">a</a>
    character.

    Examples: 
<span class="e">        -- The character 'æ' is stored as the bytes '\xc3\xa6' (using UTF-8)</span>
<span class="e"></span>
<span class="e">        -- Returns 0 because the index is pointing at the first byte of a character</span>
<span class="e">        vim.str_utf_start('æ', 1)</span>
<span class="e"></span>
<span class="e">        -- Returns -1 because the index is pointing at the second byte of a character</span>
<span class="e">        vim.str_utf_start('æ', 2)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>    (`string`)
      • <span class="s">{index}</span>  (`integer`)

<span class="h">    Return: </span>
        (`integer`)

vim.stricmp({a}, <span class="s">{b}</span>)                                          <span id="vim.stricmp%28%29" class="t">vim.stricmp()</span>
    Compares strings case-insensitively.

<span class="h">    Parameters: </span>
      • <span class="s">{a}</span>  (`string`)
      • <span class="s">{b}</span>  (`string`)

<span class="h">    Return: </span>
        (`0<span class="l">1</span>-1`) if strings are equal, <span class="s">{a}</span> <a href="motion.txt.html#is" class="d">is</a> greater than <span class="s">{b}</span> or <span class="s">{a}</span> <a href="motion.txt.html#is" class="d">is</a>
        lesser than <span class="s">{b}</span>, respectively.

vim.ui_attach({ns}, <span class="s">{options}</span>, <span class="s">{callback}</span>)                   <span id="vim.ui_attach%28%29" class="t">vim.ui_attach()</span>
    WARNING: This feature <a href="motion.txt.html#is" class="d">is</a> experimental/unstable.

    Subscribe to <a href="ui.txt.html#ui-events" class="l">ui-events</a><a href="motion.txt.html#%2C" class="d">,</a> similar to <a href="api.txt.html#nvim_ui_attach%28%29" class="l">nvim_ui_attach()</a> but receive <a href="autocmd.txt.html#events" class="d">events</a>
    in <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> callback. Used to implement screen elements like popupmenu or
    message handling in Lua.

    <span class="s">{options}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#dict" class="d">dict</a> with one or more <span class="e">ext_…</span> <a href="ui.txt.html#ui-option" class="l">ui-option</a><a href="change.txt.html#s" class="d">s</a> set to true to
    enable <a href="autocmd.txt.html#events" class="d">events</a> <a href="luaref.txt.html#for" class="d">for</a> the respective <a href="ui.txt.html#UI" class="d">UI</a> element.

    <span class="s">{callback}</span> receives event name plus additional parameters. See
    <a href="ui.txt.html#ui-popupmenu" class="l">ui-popupmenu</a> and the sections below <a href="luaref.txt.html#for" class="d">for</a> event format <a href="luaref.txt.html#for" class="d">for</a> respective
    events.

    Callbacks <a href="luaref.txt.html#for" class="d">for</a> <span class="e">msg_show</span> <a href="autocmd.txt.html#events" class="d">events</a> are executed in <a href="api.txt.html#api-fast" class="l">api-fast</a> context;
    showing the message should be scheduled.

    Excessive <a href="message.txt.html#errors" class="d">errors</a> inside the callback will result in forced detachment.

    WARNING: This <a href="api.txt.html#api" class="d">api</a> <a href="motion.txt.html#is" class="d">is</a> considered experimental. Usability will vary <a href="luaref.txt.html#for" class="d">for</a>
    different screen elements. In particular <span class="e">ext_messages</span> behavior <a href="motion.txt.html#is" class="d">is</a>
    subject to further changes and usability improvements. This <a href="motion.txt.html#is" class="d">is</a> expected to
    be used to handle <a href="message.txt.html#messages" class="d">messages</a> when setting <a href="options.txt.html#%27cmdheight%27" class="o">'cmdheight'</a> to zero (which <a href="motion.txt.html#is" class="d">is</a>
    likewise experimental).

    Example (stub <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> <a href="ui.txt.html#ui-popupmenu" class="l">ui-popupmenu</a> implementation): 
<span class="e">        ns = vim.api.nvim_create_namespace('my_fancy_pum')</span>
<span class="e"></span>
<span class="e">        vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)</span>
<span class="e">          if event == 'popupmenu_show' then</span>
<span class="e">            local items, selected, row, col, grid = ...</span>
<span class="e">            print('display pum ', #items)</span>
<span class="e">          elseif event == 'popupmenu_select' then</span>
<span class="e">            local selected = ...</span>
<span class="e">            print('selected', selected)</span>
<span class="e">          elseif event == 'popupmenu_hide' then</span>
<span class="e">            print('FIN')</span>
<span class="e">          end</span>
<span class="e">        end)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{ns}</span>        (`integer`)
      • <span class="s">{options}</span>   (`table&lt;string, any&gt;`)
      • <span class="s">{callback}</span>  (`fun()`)

vim.ui_detach({ns})                                          <span id="vim.ui_detach%28%29" class="t">vim.ui_detach()</span>
    Detach <a href="insert.txt.html#a" class="d">a</a> callback previously attached with <a href="lua.txt.html#vim.ui_attach%28%29" class="l">vim.ui_attach()</a> <a href="luaref.txt.html#for" class="d">for</a> the given
    <a href="api.txt.html#namespace" class="d">namespace</a> <span class="s">{ns}</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{ns}</span>  (`integer`)

vim.wait({time}, <span class="s">{callback}</span>, <span class="s">{interval}</span>, <span class="s">{fast_only}</span>)             <span id="vim.wait%28%29" class="t">vim.wait()</span>
    Wait <a href="luaref.txt.html#for" class="d">for</a> <span class="s">{time}</span> in milliseconds until <span class="s">{callback}</span> returns <span class="e">true</span>.

    Executes <span class="s">{callback}</span> immediately and <a href="motion.txt.html#at" class="d">at</a> approximately <span class="s">{interval}</span>
    milliseconds (default 200). Nvim still processes other <a href="autocmd.txt.html#events" class="d">events</a> during this
    time.

    Cannot be called while in an <a href="api.txt.html#api-fast" class="l">api-fast</a> event.

    Examples: 
<span class="e">        ---</span>
<span class="e">        -- Wait for 100 ms, allowing other events to process</span>
<span class="e">        vim.wait(100, function() end)</span>
<span class="e"></span>
<span class="e">        ---</span>
<span class="e">        -- Wait for 100 ms or until global variable set.</span>
<span class="e">        vim.wait(100, function() return vim.g.waiting_for_var end)</span>
<span class="e"></span>
<span class="e">        ---</span>
<span class="e">        -- Wait for 1 second or until global variable set, checking every ~500 ms</span>
<span class="e">        vim.wait(1000, function() return vim.g.waiting_for_var end, 500)</span>
<span class="e"></span>
<span class="e">        ---</span>
<span class="e">        -- Schedule a function to set a value in 100ms</span>
<span class="e">        vim.defer_fn(function() vim.g.timer_result = true end, 100)</span>
<span class="e"></span>
<span class="e">        -- Would wait ten seconds if results blocked. Actually only waits  100 ms</span>
<span class="e">        if vim.wait(10000, function() return vim.g.timer_result end) then</span>
<span class="e">          print('Only waiting a little bit of time!')</span>
<span class="e">        end</span>


<span class="h">    Parameters: </span>
      • <span class="s">{time}</span>       (`integer`) <a href="vimeval.txt.html#Number" class="d">Number</a> of milliseconds to wait
      • <span class="s">{callback}</span>   (`fun(): boolean?`) Optional callback. Waits until
                     <span class="s">{callback}</span> returns true
      • <span class="s">{interval}</span>   (`integer?`) (Approximate) number of milliseconds to wait
                     between polls
      • <span class="s">{fast_only}</span>  (`boolean?`) If true, only <a href="api.txt.html#api-fast" class="l">api-fast</a> <a href="autocmd.txt.html#events" class="d">events</a> will be
                     processed.

<span class="h">    Return (multiple): </span>
        (`boolean`)
        (`-1|-2?`)
        • If <span class="s">{callback}</span> returns <span class="e">true</span> during the <span class="s">{time}</span>: `true, nil`
        • If <span class="s">{callback}</span> never returns <span class="e">true</span> during the <span class="s">{time}</span>: `false, -1`
        • If <span class="s">{callback}</span> <a href="motion.txt.html#is" class="d">is</a> interrupted during the <span class="s">{time}</span>: `false, -2`
        • If <span class="s">{callback}</span> errors, the error <a href="motion.txt.html#is" class="d">is</a> raised.


<span class="h">==============================================================================</span>
<span class="c">LUA-VIMSCRIPT BRIDGE</span>                                           <span id="lua-vimscript" class="t">lua-vimscript</span>

Nvim <a href="lua.txt.html#Lua" class="d">Lua</a> provides an interface or "bridge" to Vimscript <a href="vimeval.txt.html#variables" class="d">variables</a> and
functions, and editor commands and options.

Objects passed over this bridge are COPIED (marshalled): there are no
"references"<a href="repeat.txt.html#." class="d">.</a> <a href="lua-guide.txt.html#lua-guide-variables" class="l">lua-guide-variables</a> For example, using <span class="e">vim.fn.remove()</span> on <a href="insert.txt.html#a" class="d">a</a>
<a href="lua.txt.html#Lua" class="d">Lua</a> <a href="vimeval.txt.html#list" class="d">list</a> copies the <a href="vimeval.txt.html#list" class="d">list</a> object to Vimscript and does NOT modify the <a href="lua.txt.html#Lua" class="d">Lua</a> list: 
<span class="e">    local list = { 1, 2, 3 }</span>
<span class="e">    vim.fn.remove(list, 0)</span>
<span class="e">    vim.print(list)  --&gt; "{ 1, 2, 3 }"</span>



vim.call({func}, <span class="s">{...}</span>)                                           <span id="vim.call%28%29" class="t">vim.call()</span>
    Invokes <a href="vimeval.txt.html#vim-function" class="l">vim-function</a> or <a href="vimeval.txt.html#user-function" class="l">user-function</a> <span class="s">{func}</span> with arguments <span class="s">{...}</span>.
    See also <a href="lua.txt.html#vim.fn" class="l">vim.fn</a><a href="repeat.txt.html#." class="d">.</a>
    Equivalent to: 
<span class="e">        vim.fn[func]({...})</span>

vim.cmd({command})
    See <a href="lua.txt.html#vim.cmd%28%29" class="l">vim.cmd()</a><a href="repeat.txt.html#." class="d">.</a>

vim.fn.{func}({...})                                                  <span id="vim.fn" class="t">vim.fn</span>
    Invokes <a href="vimeval.txt.html#vim-function" class="l">vim-function</a> or <a href="vimeval.txt.html#user-function" class="l">user-function</a> <span class="s">{func}</span> with arguments <span class="s">{...}</span>.
    To call <a href="userfunc.txt.html#autoload" class="d">autoload</a> functions, use the syntax: 
<span class="e">        vim.fn['some#function']({...})</span>

    Unlike vim.api.<a href="api.txt.html#nvim_call_function%28%29" class="l">nvim_call_function()</a> this converts directly between Vim
    <a href="index.txt.html#objects" class="d">objects</a> and <a href="lua.txt.html#Lua" class="d">Lua</a> objects. If the Vim function returns <a href="insert.txt.html#a" class="d">a</a> float, <a href="motion.txt.html#it" class="d">it</a> will be
    represented directly <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> number. Empty lists and dictionaries both
    are represented by an empty table.

    <span class="n">Note:</span> <a href="vvars.txt.html#v%3Anull" class="l">v:null</a> values <a href="motion.txt.html#as" class="d">as</a> part of the return value <a href="motion.txt.html#is" class="d">is</a> represented <a href="motion.txt.html#as" class="d">as</a>
    <a href="lua.txt.html#vim.NIL" class="l">vim.NIL</a> special value

    <span class="n">Note:</span> <a href="lua.txt.html#vim.fn" class="d">vim.fn</a> keys are generated lazily, thus <span class="e">pairs(vim.fn)</span> only
    enumerates <a href="vimeval.txt.html#functions" class="d">functions</a> that were called <a href="motion.txt.html#at" class="d">at</a> least once.

    <span class="n">Note:</span> The majority of <a href="vimeval.txt.html#functions" class="d">functions</a> cannot run in <a href="api.txt.html#api-fast" class="l">api-fast</a> callbacks with some
    undocumented exceptions which are allowed.

                                                           <span id="lua-vim-variables" class="t">lua-vim-variables</span>
The Vim editor global dictionaries <a href="vimeval.txt.html#g%3A" class="l">g:</a> <a href="vimeval.txt.html#w%3A" class="l">w:</a> <a href="vimeval.txt.html#b%3A" class="l">b:</a> <a href="vimeval.txt.html#t%3A" class="l">t:</a> <a href="vimeval.txt.html#v%3A" class="l">v:</a> can be accessed
from <a href="lua.txt.html#Lua" class="d">Lua</a> conveniently and idiomatically by referencing the <span class="e">vim.*</span> <a href="lua.txt.html#Lua" class="d">Lua</a> tables
described below. In this way you can easily read and modify global Vimscript
<a href="vimeval.txt.html#variables" class="d">variables</a> from Lua.

Example: 
<span class="e"></span>
<span class="e">    vim.g.foo = 5     -- Set the g:foo Vimscript variable.</span>
<span class="e">    print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.</span>
<span class="e">    vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.</span>
<span class="e">    vim.b[2].foo = 6  -- Set b:foo for buffer 2</span>


<span class="n">Note</span> that setting dictionary fields directly will not write them back into
Nvim. This <a href="motion.txt.html#is" class="d">is</a> because the <a href="index.txt.html#index" class="d">index</a> into the <a href="api.txt.html#namespace" class="d">namespace</a> simply returns <a href="insert.txt.html#a" class="d">a</a> copy.
Instead the whole dictionary must be written <a href="motion.txt.html#as" class="d">as</a> one. This can be achieved by
creating <a href="insert.txt.html#a" class="d">a</a> short-lived temporary.

Example: 
<span class="e"></span>
<span class="e">    vim.g.my_dict.field1 = 'value'  -- Does not work</span>
<span class="e"></span>
<span class="e">    local my_dict = vim.g.my_dict   --</span>
<span class="e">    my_dict.field1 = 'value'        -- Instead do</span>
<span class="e">    vim.g.my_dict = my_dict         --</span>
<span class="e"></span>
<a href="lua.txt.html#vim.g" class="d">vim.g</a>                                                                  <span id="vim.g" class="t">vim.g</span>
    Global <a href="motion.txt.html#%28" class="d">(</a><a href="vimeval.txt.html#g%3A" class="l">g:</a><a href="motion.txt.html#%29" class="d">)</a> editor variables.
    Key with no value returns <span class="e">nil</span>.

<a href="lua.txt.html#vim.b" class="d">vim.b</a>                                                                  <span id="vim.b" class="t">vim.b</span>
    Buffer-scoped <a href="motion.txt.html#%28" class="d">(</a><a href="vimeval.txt.html#b%3A" class="l">b:</a><a href="motion.txt.html#%29" class="d">)</a> <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> the current buffer.
    Invalid or unset key returns <span class="e">nil</span>. Can be indexed with
    an integer to access <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific buffer.

<a href="lua.txt.html#vim.w" class="d">vim.w</a>                                                                  <span id="vim.w" class="t">vim.w</span>
    Window-scoped <a href="motion.txt.html#%28" class="d">(</a><a href="vimeval.txt.html#w%3A" class="l">w:</a><a href="motion.txt.html#%29" class="d">)</a> <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> the current window.
    Invalid or unset key returns <span class="e">nil</span>. Can be indexed with
    an integer to access <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific window.

<a href="lua.txt.html#vim.t" class="d">vim.t</a>                                                                  <span id="vim.t" class="t">vim.t</span>
    Tabpage-scoped <a href="motion.txt.html#%28" class="d">(</a><a href="vimeval.txt.html#t%3A" class="l">t:</a><a href="motion.txt.html#%29" class="d">)</a> <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> the current tabpage.
    Invalid or unset key returns <span class="e">nil</span>. Can be indexed with
    an integer to access <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> specific tabpage.

<a href="lua.txt.html#vim.v" class="d">vim.v</a>                                                                  <span id="vim.v" class="t">vim.v</span>
    <a href="vimeval.txt.html#v%3A" class="l">v:</a> variables.
    Invalid or unset key returns <span class="e">nil</span>.


                                                                 <span id="lua-options" class="t">lua-options</span>
                                                             <span id="lua-vim-options" class="t">lua-vim-options</span>
                                                                 <span id="lua-vim-set" class="t">lua-vim-set</span>
                                                            <span id="lua-vim-setlocal" class="t">lua-vim-setlocal</span>

Vim <a href="options.txt.html#options" class="d">options</a> can be accessed through <a href="lua.txt.html#vim.o" class="l">vim.o</a><a href="motion.txt.html#%2C" class="d">,</a> which behaves like Vimscript
<a href="options.txt.html#%3Aset" class="l">:set</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Examples: </span>

    To set <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#boolean" class="d">boolean</a> toggle:
        Vimscript: `set number`
        Lua:       `vim.o.number <a href="change.txt.html#%3D" class="d">=</a> true`

    To set <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> value:
        Vimscript: `set wildignore=*.o,*.a,__pycache__`
        Lua:       `vim.o.wildignore <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%27" class="d">'</a>*.o,*.a,__pycache__'`

Similarly, there <a href="motion.txt.html#is" class="d">is</a> <a href="lua.txt.html#vim.bo" class="l">vim.bo</a> and <a href="lua.txt.html#vim.wo" class="l">vim.wo</a> <a href="luaref.txt.html#for" class="d">for</a> setting buffer-scoped and
window-scoped options. <span class="n">Note</span> that this must NOT be confused with
<a href="options.txt.html#local-options" class="l">local-options</a> and <a href="options.txt.html#%3Asetlocal" class="l">:setlocal</a><a href="repeat.txt.html#." class="d">.</a> There <a href="motion.txt.html#is" class="d">is</a> also <a href="lua.txt.html#vim.go" class="l">vim.go</a> that only accesses the
global value of <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#global-local" class="l">global-local</a> option, see <a href="options.txt.html#%3Asetglobal" class="l">:setglobal</a><a href="repeat.txt.html#." class="d">.</a>


                                                               <span id="vim.opt_local" class="t">vim.opt_local</span>
                                                              <span id="vim.opt_global" class="t">vim.opt_global</span>
                                                                     <span id="vim.opt" class="t">vim.opt</span>


<a href="insert.txt.html#A" class="d">A</a> special interface <a href="lua.txt.html#vim.opt" class="l">vim.opt</a> exists <a href="luaref.txt.html#for" class="d">for</a> conveniently interacting with list-
and map-style <a href="options.txt.html#options" class="d">options</a> from Lua: It allows accessing them <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#Lua" class="d">Lua</a> tables and
offers object-oriented <a href="vimeval.txt.html#method" class="d">method</a> <a href="luaref.txt.html#for" class="d">for</a> adding and removing entries.

<span class="h">    Examples: </span>

    The following methods of setting <a href="insert.txt.html#a" class="d">a</a> list-style option are equivalent:
        In Vimscript: 
<span class="e">            set wildignore=*.o,*.a,__pycache__</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.o</span>: 
<span class="e">            vim.o.wildignore = '*.o,*.a,__pycache__'</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.opt</span>: 
<span class="e">            vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }</span>

    To replicate the behavior of <a href="options.txt.html#%3Aset%2B%3D" class="l">:set+=</a><a href="motion.txt.html#%2C" class="d">,</a> use: 
<span class="e"></span>
<span class="e">        vim.opt.wildignore:append { "*.pyc", "node_modules" }</span>

    To replicate the behavior of <a href="options.txt.html#%3Aset%5E%3D" class="l">:set^=</a><a href="motion.txt.html#%2C" class="d">,</a> use: 
<span class="e"></span>
<span class="e">        vim.opt.wildignore:prepend { "new_first_value" }</span>

    To replicate the behavior of <a href="options.txt.html#%3Aset-%3D" class="l">:set-=</a><a href="motion.txt.html#%2C" class="d">,</a> use: 
<span class="e"></span>
<span class="e">        vim.opt.wildignore:remove { "node_modules" }</span>

    The following methods of setting <a href="insert.txt.html#a" class="d">a</a> map-style option are equivalent:
        In Vimscript: 
<span class="e">            set listchars=space:_,tab:&gt;~</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.o</span>: 
<span class="e">            vim.o.listchars = 'space:_,tab:&gt;~'</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.opt</span>: 
<span class="e">            vim.opt.listchars = { space = '_', tab = '&gt;~' }</span>


<span class="n">Note</span> that <a href="lua.txt.html#vim.opt" class="l">vim.opt</a> returns an <span class="e">Option</span> object, not the value of the option,
which <a href="motion.txt.html#is" class="d">is</a> accessed through <a href="lua.txt.html#vim.opt%3Aget%28%29" class="l">vim.opt:get()</a><a href="cmdline.txt.html#%3A" class="d">:</a>

<span class="h">    Examples: </span>

    The following methods of getting <a href="insert.txt.html#a" class="d">a</a> list-style option are equivalent:
        In Vimscript: 
<span class="e">            echo wildignore</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.o</span>: 
<span class="e">            print(vim.o.wildignore)</span>

        In <a href="lua.txt.html#Lua" class="d">Lua</a> using <span class="e">vim.opt</span>: 
<span class="e">            vim.print(vim.opt.wildignore:get())</span>


In any of the above examples, to replicate the behavior <a href="options.txt.html#%3Asetlocal" class="l">:setlocal</a><a href="motion.txt.html#%2C" class="d">,</a> use
<span class="e">vim.opt_local</span>. Additionally, to replicate the behavior of <a href="options.txt.html#%3Asetglobal" class="l">:setglobal</a><a href="motion.txt.html#%2C" class="d">,</a> use
<span class="e">vim.opt_global</span>.


Option:append({value})                                      <span id="vim.opt%3Aappend%28%29" class="t">vim.opt:append()</span>
    Append <a href="insert.txt.html#a" class="d">a</a> value to string-style options. See <a href="options.txt.html#%3Aset%2B%3D" class="l">:set+=</a>

    These are equivalent: 
<span class="e">        vim.opt.formatoptions:append('j')</span>
<span class="e">        vim.opt.formatoptions = vim.opt.formatoptions + 'j'</span>


<span class="h">    Parameters: </span>
      • <span class="s">{value}</span>  (`string`) Value to append

Option:get()                                                   <span id="vim.opt%3Aget%28%29" class="t">vim.opt:get()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> Lua-representation of the option. Boolean, number and <a href="vimeval.txt.html#string" class="d">string</a>
    values will be returned in exactly the same fashion.

    For values that are comma-separated lists, an array will be returned with
    the values <a href="motion.txt.html#as" class="d">as</a> entries in the array: 
<span class="e">        vim.cmd [[set wildignore=*.pyc,*.o]]</span>
<span class="e"></span>
<span class="e">        vim.print(vim.opt.wildignore:get())</span>
<span class="e">        -- { "*.pyc", "*.o", }</span>
<span class="e"></span>
<span class="e">        for _, ignore_pattern in ipairs(vim.opt.wildignore:get()) do</span>
<span class="e">            print("Will ignore:", ignore_pattern)</span>
<span class="e">        end</span>
<span class="e">        -- Will ignore: *.pyc</span>
<span class="e">        -- Will ignore: *.o</span>


    For values that are comma-separated maps, <a href="insert.txt.html#a" class="d">a</a> table will be returned with
    the names <a href="motion.txt.html#as" class="d">as</a> keys and the values <a href="motion.txt.html#as" class="d">as</a> entries: 
<span class="e">        vim.cmd [[set listchars=space:_,tab:&gt;~]]</span>
<span class="e"></span>
<span class="e">        vim.print(vim.opt.listchars:get())</span>
<span class="e">        --  { space = "_", tab = "&gt;~", }</span>
<span class="e"></span>
<span class="e">        for char, representation in pairs(vim.opt.listchars:get()) do</span>
<span class="e">            print(char, "=&gt;", representation)</span>
<span class="e">        end</span>


    For values that are lists of flags, <a href="insert.txt.html#a" class="d">a</a> set will be returned with the flags
    <a href="motion.txt.html#as" class="d">as</a> keys and <span class="e">true</span> <a href="motion.txt.html#as" class="d">as</a> entries. 
<span class="e">        vim.cmd [[set formatoptions=njtcroql]]</span>
<span class="e"></span>
<span class="e">        vim.print(vim.opt.formatoptions:get())</span>
<span class="e">        -- { n = true, j = true, c = true, ... }</span>
<span class="e"></span>
<span class="e">        local format_opts = vim.opt.formatoptions:get()</span>
<span class="e">        if format_opts.j then</span>
<span class="e">            print("J is enabled!")</span>
<span class="e">        end</span>


<span class="h">    Return: </span>
        (`string<span class="l">integer</span>boolean?`) value of option

Option:prepend({value})                                    <span id="vim.opt%3Aprepend%28%29" class="t">vim.opt:prepend()</span>
    Prepend <a href="insert.txt.html#a" class="d">a</a> value to string-style options. See <a href="options.txt.html#%3Aset%5E%3D" class="l">:set^=</a>

    These are equivalent: 
<span class="e">        vim.opt.wildignore:prepend('*.o')</span>
<span class="e">        vim.opt.wildignore = vim.opt.wildignore ^ '*.o'</span>


<span class="h">    Parameters: </span>
      • <span class="s">{value}</span>  (`string`) Value to prepend

Option:remove({value})                                      <span id="vim.opt%3Aremove%28%29" class="t">vim.opt:remove()</span>
    Remove <a href="insert.txt.html#a" class="d">a</a> value from string-style options. See <a href="options.txt.html#%3Aset-%3D" class="l">:set-=</a>

    These are equivalent: 
<span class="e">        vim.opt.wildignore:remove('*.pyc')</span>
<span class="e">        vim.opt.wildignore = vim.opt.wildignore - '*.pyc'</span>


<span class="h">    Parameters: </span>
      • <span class="s">{value}</span>  (`string`) Value to remove

vim.bo[{bufnr}]                                                       <span id="vim.bo" class="t">vim.bo</span>
    Get or set buffer-scoped <a href="options.txt.html#options" class="l">options</a> <a href="luaref.txt.html#for" class="d">for</a> the buffer with number <span class="s">{bufnr}</span>.
    Like <span class="e">:setlocal</span>. If <span class="s">{bufnr}</span> <a href="motion.txt.html#is" class="d">is</a> omitted then the current buffer <a href="motion.txt.html#is" class="d">is</a> used.
    Invalid <span class="s">{bufnr}</span> or key <a href="motion.txt.html#is" class="d">is</a> an error.

    Example: 
<span class="e">        local bufnr = vim.api.nvim_get_current_buf()</span>
<span class="e">        vim.bo[bufnr].buflisted = true    -- same as vim.bo.buflisted = true</span>
<span class="e">        print(vim.bo.comments)</span>
<span class="e">        print(vim.bo.baz)                 -- error: invalid key</span>


<a href="lua.txt.html#vim.env" class="d">vim.env</a>                                                              <span id="vim.env" class="t">vim.env</span>
    Environment <a href="vimeval.txt.html#variables" class="d">variables</a> defined in the editor session. See <a href="options.txt.html#expand-env" class="l">expand-env</a> and
    <a href="vimeval.txt.html#%3Alet-environment" class="l">:let-environment</a> <a href="luaref.txt.html#for" class="d">for</a> the Vimscript behavior. Invalid or unset key
    returns <span class="e">nil</span>.

    Example: 
<span class="e">        vim.env.FOO = 'bar'</span>
<span class="e">        print(vim.env.TERM)</span>


<a href="lua.txt.html#vim.go" class="d">vim.go</a>                                                                <span id="vim.go" class="t">vim.go</span>
    Get or set global <a href="options.txt.html#options" class="l">options</a><a href="repeat.txt.html#." class="d">.</a> Like <span class="e">:setglobal</span>. Invalid key <a href="motion.txt.html#is" class="d">is</a> an error.

    <span class="n">Note:</span> this <a href="motion.txt.html#is" class="d">is</a> different from <a href="lua.txt.html#vim.o" class="l">vim.o</a> because this accesses the global
    option value and thus <a href="motion.txt.html#is" class="d">is</a> mostly useful <a href="luaref.txt.html#for" class="d">for</a> use with <a href="options.txt.html#global-local" class="l">global-local</a>
    options.

    Example: 
<span class="e">        vim.go.cmdheight = 4</span>
<span class="e">        print(vim.go.columns)</span>
<span class="e">        print(vim.go.bar)     -- error: invalid key</span>


<a href="lua.txt.html#vim.o" class="d">vim.o</a>                                                                  <span id="vim.o" class="t">vim.o</span>
    Get or set <a href="options.txt.html#options" class="l">options</a><a href="repeat.txt.html#." class="d">.</a> Works like <span class="e">:set</span>, so buffer/window-scoped <a href="options.txt.html#options" class="d">options</a>
    target the current buffer/window. Invalid key <a href="motion.txt.html#is" class="d">is</a> an error.

    Example: 
<span class="e">        vim.o.cmdheight = 4</span>
<span class="e">        print(vim.o.columns)</span>
<span class="e">        print(vim.o.foo)     -- error: invalid key</span>


vim.wo[{winid}][{bufnr}]                                              <span id="vim.wo" class="t">vim.wo</span>
    Get or set window-scoped <a href="options.txt.html#options" class="l">options</a> <a href="luaref.txt.html#for" class="d">for</a> the <a href="windows.txt.html#window" class="d">window</a> with handle <span class="s">{winid}</span> and
    buffer with number <span class="s">{bufnr}</span>. Like <span class="e">:setlocal</span> if setting <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#global-local" class="l">global-local</a>
    option or if <span class="s">{bufnr}</span> <a href="motion.txt.html#is" class="d">is</a> provided, like <span class="e">:set</span> otherwise. If <span class="s">{winid}</span> <a href="motion.txt.html#is" class="d">is</a>
    omitted then the current <a href="windows.txt.html#window" class="d">window</a> <a href="motion.txt.html#is" class="d">is</a> used. Invalid <span class="s">{winid}</span>, <span class="s">{bufnr}</span> or key
    <a href="motion.txt.html#is" class="d">is</a> an error.

    <span class="n">Note:</span> only <span class="s">{bufnr}</span> with value <span class="e">0</span> (the current buffer in the window) <a href="motion.txt.html#is" class="d">is</a>
    supported.

    Example: 
<span class="e">        local winid = vim.api.nvim_get_current_win()</span>
<span class="e">        vim.wo[winid].number = true    -- same as vim.wo.number = true</span>
<span class="e">        print(vim.wo.foldmarker)</span>
<span class="e">        print(vim.wo.quux)             -- error: invalid key</span>
<span class="e">        vim.wo[winid][0].spell = false -- like ':setlocal nospell'</span>



<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: vim                                                      <span id="lua-vim" class="t">lua-vim</span>

vim.cmd({command})                                                 <span id="vim.cmd%28%29" class="t">vim.cmd()</span>
    Executes Vimscript <a href="motion.txt.html#%28" class="d">(</a><a href="index.txt.html#Ex-commands" class="l">Ex-commands</a>).

    Can be indexed with <a href="insert.txt.html#a" class="d">a</a> command name to get <a href="insert.txt.html#a" class="d">a</a> function, thus you can write
    <span class="e">vim.cmd.echo(…)</span> instead of <span class="e">vim.cmd{cmd='echo',…}</span>.

    Examples: 
<span class="e">        -- Single command:</span>
<span class="e">        vim.cmd('echo 42')</span>
<span class="e">        -- Multiline script:</span>
<span class="e">        vim.cmd([[</span>
<span class="e">          augroup my.group</span>
<span class="e">            autocmd!</span>
<span class="e">            autocmd FileType c setlocal cindent</span>
<span class="e">          augroup END</span>
<span class="e">        ]])</span>
<span class="e"></span>
<span class="e">        -- Ex command :echo "foo". Note: string literals must be double-quoted.</span>
<span class="e">        vim.cmd('echo "foo"')</span>
<span class="e">        vim.cmd { cmd = 'echo', args = { '"foo"' } }</span>
<span class="e">        vim.cmd.echo({ args = { '"foo"' } })</span>
<span class="e">        vim.cmd.echo('"foo"')</span>
<span class="e"></span>
<span class="e">        -- Ex command :write! myfile.txt</span>
<span class="e">        vim.cmd('write! myfile.txt')</span>
<span class="e">        vim.cmd { cmd = 'write', args = { 'myfile.txt' }, bang = true }</span>
<span class="e">        vim.cmd.write { args = { 'myfile.txt' }, bang = true }</span>
<span class="e">        vim.cmd.write { 'myfile.txt', bang = true }</span>
<span class="e"></span>
<span class="e">        -- Ex command :vertical resize +2</span>
<span class="e">        vim.cmd.resize({ '+2', mods = { vertical = true } })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{command}</span>  (`string|table`) Command(s) to execute.
                   • The <a href="vimeval.txt.html#string" class="d">string</a> form supports multiline Vimscript (alias to
                     <a href="api.txt.html#nvim_exec2%28%29" class="l">nvim_exec2()</a><a href="motion.txt.html#%2C" class="d">,</a> behaves like <a href="repeat.txt.html#%3Asource" class="l">:source</a>).
                   • The table form executes <a href="insert.txt.html#a" class="d">a</a> single command (alias to
                     <a href="api.txt.html#nvim_cmd%28%29" class="l">nvim_cmd()</a>).

<span class="h">    See also: </span>
      • <a href="index.txt.html#ex-cmd-index" class="l">ex-cmd-index</a>

vim.defer_fn({fn}, <span class="s">{timeout}</span>)                                 <span id="vim.defer_fn%28%29" class="t">vim.defer_fn()</span>
    Defers calling <span class="s">{fn}</span> until <span class="s">{timeout}</span> ms passes.

    Use to <a href="diff.txt.html#do" class="d">do</a> <a href="insert.txt.html#a" class="d">a</a> one-shot <a href="vimfn.txt.html#timer" class="d">timer</a> that calls <span class="s">{fn}</span> <span class="n">Note:</span> The <span class="s">{fn}</span> <a href="motion.txt.html#is" class="d">is</a>
    <a href="lua.txt.html#vim.schedule_wrap%28%29" class="l">vim.schedule_wrap()</a>ped automatically, so <a href="api.txt.html#API" class="d">API</a> <a href="vimeval.txt.html#functions" class="d">functions</a> are safe to call.

<span class="h">    Parameters: </span>
      • <span class="s">{fn}</span>       (`function`) Callback to call once <span class="e">timeout</span> expires
      • <span class="s">{timeout}</span>  (`integer`) <a href="vimeval.txt.html#Number" class="d">Number</a> of milliseconds to wait before calling
                   <span class="e">fn</span>

<span class="h">    Return: </span>
        (`table`) <a href="vimfn.txt.html#timer" class="d">timer</a> <a href="luvref.txt.html#luv" class="d">luv</a> <a href="vimfn.txt.html#timer" class="d">timer</a> object

                                                             <span id="vim.deprecate%28%29" class="t">vim.deprecate()</span>
vim.deprecate({name}, <span class="s">{alternative}</span>, <span class="s">{version}</span>, <span class="s">{plugin}</span>, <span class="s">{backtrace}</span>)
    Shows <a href="insert.txt.html#a" class="d">a</a> deprecation message to the user.

<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>         (`string`) Deprecated feature (function, API, etc.).
      • <span class="s">{alternative}</span>  (`string?`) Suggested alternative feature.
      • <span class="s">{version}</span>      (`string`) Version when the <a href="deprecated.txt.html#deprecated" class="d">deprecated</a> function will be
                       removed.
      • <span class="s">{plugin}</span>       (`string?`) Name of the <a href="usr_05.txt.html#plugin" class="d">plugin</a> that owns the <a href="deprecated.txt.html#deprecated" class="d">deprecated</a>
                       feature. Defaults to "Nvim"<a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{backtrace}</span>    (`boolean?`) Prints backtrace. Defaults to true.

<span class="h">    Return: </span>
        (`string?`) Deprecated message, or nil if no message was shown.

<a href="lua.txt.html#vim.inspect%28%29" class="d">vim.inspect()</a>                                                  <span id="vim.inspect%28%29" class="t">vim.inspect()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> human-readable representation of the given object.

<span class="h">    Return: </span>
        (`string`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.print%28%29" class="l">vim.print()</a>
      • <a class="u" href="https://github.com/kikito/inspect.lua">https://github.com/kikito/inspect.lua</a>
      • <a class="u" href="https://github.com/mpeterv/vinspect">https://github.com/mpeterv/vinspect</a>

vim.keycode({str})                                             <span id="vim.keycode%28%29" class="t">vim.keycode()</span>
    Translates keycodes.

    Example: 
<span class="e">        local k = vim.keycode</span>
<span class="e">        vim.g.mapleader = k'&lt;bs&gt;'</span>


<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to be converted.

<span class="h">    Return: </span>
        (`string`)

<span class="h">    See also: </span>
      • <a href="api.txt.html#nvim_replace_termcodes%28%29" class="l">nvim_replace_termcodes()</a>

vim.lua_omnifunc({find_start})                            <span id="vim.lua_omnifunc%28%29" class="t">vim.lua_omnifunc()</span>
    Omnifunc <a href="luaref.txt.html#for" class="d">for</a> completing <a href="lua.txt.html#Lua" class="d">Lua</a> values from the runtime <a href="lua.txt.html#Lua" class="d">Lua</a> interpreter,
    similar to the builtin completion <a href="luaref.txt.html#for" class="d">for</a> the <span class="e">:lua</span> command.

    Activate using `set omnifunc=v:lua.vim.lua_omnifunc` in <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> buffer.

<span class="h">    Parameters: </span>
      • <span class="s">{find_start}</span>  (`1|0`)

vim.notify({msg}, <span class="s">{level}</span>, <span class="s">{opts}</span>)                              <span id="vim.notify%28%29" class="t">vim.notify()</span>
    Displays <a href="insert.txt.html#a" class="d">a</a> notification to the user.

    This function can be overridden by plugins to display notifications using
    <a href="insert.txt.html#a" class="d">a</a> custom <a href="provider.txt.html#provider" class="d">provider</a> (such <a href="motion.txt.html#as" class="d">as</a> the system notification provider). By default,
    writes to <a href="message.txt.html#%3Amessages" class="l">:messages</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{msg}</span>    (`string`) Content of the notification to show to the user.
      • <span class="s">{level}</span>  (`integer?`) One of the values from <a href="lua.txt.html#vim.log.levels" class="l">vim.log.levels</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{opts}</span>   (`table?`) Optional parameters. Unused by default.

vim.notify_once({msg}, <span class="s">{level}</span>, <span class="s">{opts}</span>)                    <span id="vim.notify_once%28%29" class="t">vim.notify_once()</span>
    Displays <a href="insert.txt.html#a" class="d">a</a> notification only one time.

    Like <a href="lua.txt.html#vim.notify%28%29" class="l">vim.notify()</a><a href="motion.txt.html#%2C" class="d">,</a> but subsequent calls with the same message will not
    display <a href="insert.txt.html#a" class="d">a</a> notification.

<span class="h">    Parameters: </span>
      • <span class="s">{msg}</span>    (`string`) Content of the notification to show to the user.
      • <span class="s">{level}</span>  (`integer?`) One of the values from <a href="lua.txt.html#vim.log.levels" class="l">vim.log.levels</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{opts}</span>   (`table?`) Optional parameters. Unused by default.

<span class="h">    Return: </span>
        (`boolean`) true if message was displayed, else false

vim.on_key({fn}, <span class="s">{ns_id}</span>, <span class="s">{opts}</span>)                               <span id="vim.on_key%28%29" class="t">vim.on_key()</span>
    Adds <a href="lua.txt.html#Lua" class="d">Lua</a> function <span class="s">{fn}</span> with <a href="api.txt.html#namespace" class="d">namespace</a> id <span class="s">{ns_id}</span> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> listener to every,
    yes every, input key.

    The Nvim command-line option <a href="starting.txt.html#-w" class="l">-w</a> <a href="motion.txt.html#is" class="d">is</a> related but does not <a href="support.txt.html#support" class="d">support</a>
    callbacks and cannot be toggled dynamically.

<span class="h">    Note: </span>
      • <span class="s">{fn}</span> will be removed on error.
      • <span class="s">{fn}</span> won't be invoked recursively, i.e. if <span class="s">{fn}</span> itself consumes input,
        <a href="motion.txt.html#it" class="d">it</a> won't be invoked <a href="luaref.txt.html#for" class="d">for</a> those keys.
      • <span class="s">{fn}</span> will not be cleared by <a href="api.txt.html#nvim_buf_clear_namespace%28%29" class="l">nvim_buf_clear_namespace()</a>

<span class="h">    Parameters: </span>
      • <span class="s">{fn}</span>     (`fun(key: string, typed: string): string??`) Function
                 invoked <a href="luaref.txt.html#for" class="d">for</a> every input key, after mappings have been applied
                 but before further processing. Arguments <span class="s">{key}</span> and <span class="s">{typed}</span>
                 are raw keycodes, where <span class="s">{key}</span> <a href="motion.txt.html#is" class="d">is</a> the key after mappings are
                 applied, and <span class="s">{typed}</span> <a href="motion.txt.html#is" class="d">is</a> the key(s) before mappings are
                 applied. <span class="s">{typed}</span> may be empty if <span class="s">{key}</span> <a href="motion.txt.html#is" class="d">is</a> produced by
                 non-typed key(s) or by the same typed key(s) that produced <a href="insert.txt.html#a" class="d">a</a>
                 previous <span class="s">{key}</span>. If <span class="s">{fn}</span> returns an empty string, <span class="s">{key}</span> <a href="motion.txt.html#is" class="d">is</a>
                 discarded/ignored. When <span class="s">{fn}</span> <a href="motion.txt.html#is" class="d">is</a> <span class="e">nil</span>, the callback
                 associated with <a href="api.txt.html#namespace" class="d">namespace</a> <span class="s">{ns_id}</span> <a href="motion.txt.html#is" class="d">is</a> removed.
      • <span class="s">{ns_id}</span>  (`integer?`) Namespace ID. If nil or 0, generates and returns
                 <a href="insert.txt.html#a" class="d">a</a> new <a href="api.txt.html#nvim_create_namespace%28%29" class="l">nvim_create_namespace()</a> id.
      • <span class="s">{opts}</span>   (`table?`) Optional parameters

<span class="h">    Return: </span>
        (`integer`) Namespace id associated with <span class="s">{fn}</span>. Or <a href="intro.txt.html#count" class="d">count</a> of all
        callbacks if on_key() <a href="motion.txt.html#is" class="d">is</a> called without arguments.

<span class="h">    See also: </span>
      • <a href="vimfn.txt.html#keytrans%28%29" class="l">keytrans()</a>

vim.paste({lines}, <span class="s">{phase}</span>)                                      <span id="vim.paste%28%29" class="t">vim.paste()</span>
    Paste handler, invoked by <a href="api.txt.html#nvim_paste%28%29" class="l">nvim_paste()</a><a href="repeat.txt.html#." class="d">.</a>

    <span class="n">Note:</span> This <a href="motion.txt.html#is" class="d">is</a> provided only <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> "hook"<a href="motion.txt.html#%2C" class="d">,</a> don't call <a href="motion.txt.html#it" class="d">it</a> directly; call
    <a href="api.txt.html#nvim_paste%28%29" class="l">nvim_paste()</a> instead, which arranges <a href="undo.txt.html#redo" class="d">redo</a> (dot-repeat) and invokes
    <span class="e">vim.paste</span>.

    Example: To remove ANSI color codes when pasting: 
<span class="e">        vim.paste = (function(overridden)</span>
<span class="e">          return function(lines, phase)</span>
<span class="e">            for i,line in ipairs(lines) do</span>
<span class="e">              -- Scrub ANSI color codes from paste input.</span>
<span class="e">              lines[i] = line:gsub('\27%[[0-9;mK]+', '')</span>
<span class="e">            end</span>
<span class="e">            return overridden(lines, phase)</span>
<span class="e">          end</span>
<span class="e">        end)(vim.paste)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{lines}</span>  (`string[]`) <a href="vimfn.txt.html#readfile%28%29" class="l">readfile()</a>-style <a href="vimeval.txt.html#list" class="d">list</a> of lines to paste.
                 <a href="channel.txt.html#channel-lines" class="l">channel-lines</a>
      • <span class="s">{phase}</span>  (`-1<span class="l">1</span>2|3`) -1: "non-streaming" paste: the call contains all
                 lines. If <a href="provider.txt.html#paste" class="d">paste</a> <a href="motion.txt.html#is" class="d">is</a> "streamed"<a href="motion.txt.html#%2C" class="d">,</a> <span class="e">phase</span> indicates the stream
                 state:
                 • 1: starts the <a href="provider.txt.html#paste" class="d">paste</a> (exactly once)
                 • 2: continues the <a href="provider.txt.html#paste" class="d">paste</a> (zero or more times)
                 • 3: ends the <a href="provider.txt.html#paste" class="d">paste</a> (exactly once)

<span class="h">    Return: </span>
        (`boolean`) result false if client should cancel the paste.

<span class="h">    See also: </span>
      • <a href="provider.txt.html#paste" class="l">paste</a>

vim.print({...})                                                 <span id="vim.print%28%29" class="t">vim.print()</span>
    "Pretty prints" the given arguments and returns them unmodified.

    Example: 
<span class="e">        local hl_normal = vim.print(vim.api.nvim_get_hl(0, { name = 'Normal' }))</span>


<span class="h">    Parameters: </span>
      • <span class="s">{...}</span>  (`any`)

<span class="h">    Return: </span>
        (`any`) given arguments.

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.inspect%28%29" class="l">vim.inspect()</a>
      • <a href="various.txt.html#%3A%3D" class="l">:=</a>

vim.schedule_wrap({fn})                                  <span id="vim.schedule_wrap%28%29" class="t">vim.schedule_wrap()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> function which calls <span class="s">{fn}</span> via <a href="lua.txt.html#vim.schedule%28%29" class="l">vim.schedule()</a><a href="repeat.txt.html#." class="d">.</a>

    The returned function passes all arguments to <span class="s">{fn}</span>.

    Example: 
<span class="e">        function notify_readable(_err, readable)</span>
<span class="e">          vim.notify("readable? " .. tostring(readable))</span>
<span class="e">        end</span>
<span class="e">        vim.uv.fs_access(vim.fn.stdpath("config"), "R", vim.schedule_wrap(notify_readable))</span>


<span class="h">    Parameters: </span>
      • <span class="s">{fn}</span>  (`function`)

<span class="h">    Return: </span>
        (`function`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#lua-loop-callbacks" class="l">lua-loop-callbacks</a>
      • <a href="lua.txt.html#vim.schedule%28%29" class="l">vim.schedule()</a>
      • <a href="lua.txt.html#vim.in_fast_event%28%29" class="l">vim.in_fast_event()</a>

                                                         <span id="vim.str_byteindex%28%29" class="t">vim.str_byteindex()</span>
vim.str_byteindex({s}, <span class="s">{encoding}</span>, <span class="s">{index}</span>, <span class="s">{strict_indexing}</span>)
    Convert UTF-32, UTF-16 or <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> <span class="s">{index}</span> to byte index. If
    <span class="s">{strict_indexing}</span> <a href="motion.txt.html#is" class="d">is</a> false then then an out of range <a href="index.txt.html#index" class="d">index</a> will return
    byte length instead of throwing an error.

    Invalid <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> and NUL <a href="motion.txt.html#is" class="d">is</a> treated like in <a href="lua.txt.html#vim.str_utfindex%28%29" class="l">vim.str_utfindex()</a><a href="repeat.txt.html#." class="d">.</a> An <span class="s">{index}</span>
    in the middle of <a href="insert.txt.html#a" class="d">a</a> UTF-16 sequence <a href="motion.txt.html#is" class="d">is</a> rounded upwards to the <a href="intro.txt.html#end" class="d">end</a> of that
    sequence.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>                (`string`)
      • <span class="s">{encoding}</span>         (`"<a href="mbyte.txt.html#utf-8" class="d">utf-8</a>"|"utf-16"|"utf-32"<a href="motion.txt.html#%60%29" class="d">`)</a>
      • <span class="s">{index}</span>            (`integer`)
      • <span class="s">{strict_indexing}</span>  (`boolean?`) default: true

<span class="h">    Return: </span>
        (`integer`)

                                                          <span id="vim.str_utfindex%28%29" class="t">vim.str_utfindex()</span>
vim.str_utfindex({s}, <span class="s">{encoding}</span>, <span class="s">{index}</span>, <span class="s">{strict_indexing}</span>)
    Convert byte <a href="index.txt.html#index" class="d">index</a> to UTF-32, UTF-16 or <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> indices. If <span class="s">{index}</span> <a href="motion.txt.html#is" class="d">is</a> not
    supplied, the length of the <a href="vimeval.txt.html#string" class="d">string</a> <a href="motion.txt.html#is" class="d">is</a> used. All indices are zero-based.

    If <span class="s">{strict_indexing}</span> <a href="motion.txt.html#is" class="d">is</a> false then an out of range <a href="index.txt.html#index" class="d">index</a> will return
    <a href="vimeval.txt.html#string" class="d">string</a> length instead of throwing an error. Invalid <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> bytes, and
    embedded surrogates are counted <a href="motion.txt.html#as" class="d">as</a> one code point each. An <span class="s">{index}</span> in the
    middle of <a href="insert.txt.html#a" class="d">a</a> <a href="mbyte.txt.html#UTF-8" class="d">UTF-8</a> sequence <a href="motion.txt.html#is" class="d">is</a> rounded upwards to the <a href="intro.txt.html#end" class="d">end</a> of that sequence.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>                (`string`)
      • <span class="s">{encoding}</span>         (`"<a href="mbyte.txt.html#utf-8" class="d">utf-8</a>"|"utf-16"|"utf-32"<a href="motion.txt.html#%60%29" class="d">`)</a>
      • <span class="s">{index}</span>            (`integer?`)
      • <span class="s">{strict_indexing}</span>  (`boolean?`) default: true

<span class="h">    Return: </span>
        (`integer`)

vim.system({cmd}, <span class="s">{opts}</span>, <span class="s">{on_exit}</span>)                            <span id="vim.system%28%29" class="t">vim.system()</span>
    Runs <a href="insert.txt.html#a" class="d">a</a> system command or throws an error if <span class="s">{cmd}</span> cannot be run.

    Examples: 
<span class="e">        local on_exit = function(obj)</span>
<span class="e">          print(obj.code)</span>
<span class="e">          print(obj.signal)</span>
<span class="e">          print(obj.stdout)</span>
<span class="e">          print(obj.stderr)</span>
<span class="e">        end</span>
<span class="e"></span>
<span class="e">        -- Runs asynchronously:</span>
<span class="e">        vim.system({'echo', 'hello'}, { text = true }, on_exit)</span>
<span class="e"></span>
<span class="e">        -- Runs synchronously:</span>
<span class="e">        local obj = vim.system({'echo', 'hello'}, { text = true }):wait()</span>
<span class="e">        -- { code = 0, signal = 0, stdout = 'hello\n', stderr = '' }</span>


    See <a href="luvref.txt.html#uv.spawn%28%29" class="l">uv.spawn()</a> <a href="luaref.txt.html#for" class="d">for</a> more details. <span class="n">Note:</span> unlike <a href="luvref.txt.html#uv.spawn%28%29" class="l">uv.spawn()</a><a href="motion.txt.html#%2C" class="d">,</a> vim.system
    throws an error if <span class="s">{cmd}</span> cannot be run.

<span class="h">    Parameters: </span>
      • <span class="s">{cmd}</span>      (`string[]`) Command to execute
      • <span class="s">{opts}</span>     (`vim.SystemOpts?`) Options:
                   • cwd: (string) Set the current working directory <a href="luaref.txt.html#for" class="d">for</a> the
                     sub-process.
                   • env: table&lt;string,string&gt; Set environment <a href="vimeval.txt.html#variables" class="d">variables</a> <a href="luaref.txt.html#for" class="d">for</a>
                     the new process. Inherits the current environment with
                     <span class="e">NVIM</span> set to <a href="vvars.txt.html#v%3Aservername" class="l">v:servername</a><a href="repeat.txt.html#." class="d">.</a>
                   • clear_env: (boolean) <span class="e">env</span> defines the <a href="job_control.txt.html#job" class="d">job</a> environment
                     exactly, instead of merging current environment. <span class="n">Note:</span> if
                     <span class="e">env</span> <a href="motion.txt.html#is" class="d">is</a> <span class="e">nil</span>, the current environment <a href="motion.txt.html#is" class="d">is</a> used but
                     without <span class="e">NVIM</span> set.
                   • stdin: (string<span class="l">string[]</span>boolean) If <span class="e">true</span>, then <a href="insert.txt.html#a" class="d">a</a> pipe
                     to stdin <a href="motion.txt.html#is" class="d">is</a> opened and can be written to via the
                     <span class="e">write()</span> <a href="vimeval.txt.html#method" class="d">method</a> to SystemObj. If <a href="vimeval.txt.html#string" class="d">string</a> or string[] then
                     will be written to stdin and closed. Defaults to <span class="e">false</span>.
                   • stdout: (boolean|function) Handle output from stdout.
                     When passed <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> function must have the signature
                     `fun(err: string, data: string)`. Defaults to <span class="e">true</span>
                   • stderr: (boolean|function) Handle output from stderr.
                     When passed <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> function must have the signature
                     `fun(err: string, data: string)`. Defaults to <span class="e">true</span>.
                   • text: (boolean) Handle stdout and stderr <a href="motion.txt.html#as" class="d">as</a> text.
                     Replaces <span class="e">\r\n</span> with <span class="e">\n</span>.
                   • timeout: (integer) Run the command with <a href="insert.txt.html#a" class="d">a</a> time limit.
                     Upon timeout the process <a href="motion.txt.html#is" class="d">is</a> sent the TERM signal (15) and
                     the exit code <a href="motion.txt.html#is" class="d">is</a> set to 124.
                   • detach: (boolean) If true, spawn the child process in <a href="insert.txt.html#a" class="d">a</a>
                     detached state <a href="motion.txt.html#-" class="d">-</a> this will make <a href="motion.txt.html#it" class="d">it</a> <a href="insert.txt.html#a" class="d">a</a> process group
                     leader, and will effectively enable the child to keep
                     running after the parent exits. <span class="n">Note</span> that the child
                     process will still keep the parent's event loop alive
                     unless the parent process calls <a href="luvref.txt.html#uv.unref%28%29" class="l">uv.unref()</a> on the
                     child's process handle.
      • <span class="s">{on_exit}</span>  (`fun(out: vim.SystemCompleted)?`) Called when subprocess
                   exits. When provided, the command runs asynchronously.
                   Receives SystemCompleted object, see return of
                   SystemObj:wait().

<span class="h">    Return: </span>
        (`vim.SystemObj`) Object with the fields:
        • cmd (string[]) Command name and args
        • pid (integer) Process ID
        • wait (fun(timeout: integer|nil): SystemCompleted) Wait <a href="luaref.txt.html#for" class="d">for</a> the
          process to complete. Upon timeout the process <a href="motion.txt.html#is" class="d">is</a> sent the KILL
          signal (9) and the exit code <a href="motion.txt.html#is" class="d">is</a> set to 124. Cannot be called in
          <a href="api.txt.html#api-fast" class="l">api-fast</a><a href="repeat.txt.html#." class="d">.</a>
          • SystemCompleted <a href="motion.txt.html#is" class="d">is</a> an object with the fields:
            • code: (integer)
            • signal: (integer)
            • stdout: (string), nil if stdout argument <a href="motion.txt.html#is" class="d">is</a> passed
            • stderr: (string), nil if stderr argument <a href="motion.txt.html#is" class="d">is</a> passed
        • kill (fun(signal: integer|string))
        • write (fun(data: <a href="vimeval.txt.html#string" class="d">string</a>|nil)) Requires <span class="e">stdin=true</span>. Pass <span class="e">nil</span> to
          close the stream.
        • is_closing (fun(): boolean)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.inspector" class="d">vim.inspector</a>                                      <span id="vim.inspector" class="t">vim.inspector</span>

vim.inspect_pos({bufnr}, <span class="s">{row}</span>, <span class="s">{col}</span>, <span class="s">{filter}</span>)           <span id="vim.inspect_pos%28%29" class="t">vim.inspect_pos()</span>
    Get all the items <a href="motion.txt.html#at" class="d">at</a> <a href="insert.txt.html#a" class="d">a</a> given buffer position.

    Can also be pretty-printed with <span class="e">:Inspect!</span>.                   <span id="%3AInspect%21" class="t">:Inspect!</span>

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>   (`integer?`) <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to the current buffer
      • <span class="s">{row}</span>     (`integer?`) row to inspect, 0-based. Defaults to the row of
                  the current cursor
      • <span class="s">{col}</span>     (`integer?`) col to inspect, 0-based. Defaults to the col of
                  the current cursor
      • <span class="s">{filter}</span>  (`table?`) Table with key-value pairs to <a href="change.txt.html#filter" class="d">filter</a> the items
                  • <span class="s">{syntax}</span> (`boolean`, default: <span class="e">true</span>) Include <a href="syntax.txt.html#syntax" class="d">syntax</a> based
                    highlight groups.
                  • <span class="s">{treesitter}</span> (`boolean`, default: <span class="e">true</span>) Include
                    <a href="treesitter.txt.html#treesitter" class="d">treesitter</a> based highlight groups.
                  • <span class="s">{extmarks}</span> (`boolean|"all"`, default: true) Include
                    extmarks. When <span class="e">all</span>, then <a href="api.txt.html#extmarks" class="d">extmarks</a> without <a href="insert.txt.html#a" class="d">a</a> <span class="e">hl_group</span>
                    will also be included.
                  • <span class="s">{semantic_tokens}</span> (`boolean`, default: true) Include
                    semantic token highlights.

<span class="h">    Return: </span>
        (`table`) <a href="insert.txt.html#a" class="d">a</a> table with the following key-value pairs. Items are in
        "traversal order"<a href="cmdline.txt.html#%3A" class="d">:</a>
        • treesitter: <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="treesitter.txt.html#treesitter" class="d">treesitter</a> captures
        • syntax: <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="syntax.txt.html#syntax" class="d">syntax</a> groups
        • semantic_tokens: <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of semantic tokens
        • extmarks: <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="api.txt.html#extmarks" class="d">extmarks</a>
        • buffer: the buffer used to get the items
        • row: the row used to get the items
        • col: the col used to get the items

vim.show_pos({bufnr}, <span class="s">{row}</span>, <span class="s">{col}</span>, <span class="s">{filter}</span>)                 <span id="vim.show_pos%28%29" class="t">vim.show_pos()</span>
    Show all the items <a href="motion.txt.html#at" class="d">at</a> <a href="insert.txt.html#a" class="d">a</a> given buffer position.

    Can also be shown with <span class="e">:Inspect</span>.                              <span id="%3AInspect" class="t">:Inspect</span>

    Example: To bind this function to the vim-scriptease inspired <span class="e">zS</span> in
    <a href="intro.txt.html#Normal" class="d">Normal</a> mode: 
<span class="e">        vim.keymap.set('n', 'zS', vim.show_pos)</span>


<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>   (`integer?`) <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to the current buffer
      • <span class="s">{row}</span>     (`integer?`) row to inspect, 0-based. Defaults to the row of
                  the current cursor
      • <span class="s">{col}</span>     (`integer?`) col to inspect, 0-based. Defaults to the col of
                  the current cursor
      • <span class="s">{filter}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                  • <span class="s">{syntax}</span> (`boolean`, default: <span class="e">true</span>) Include <a href="syntax.txt.html#syntax" class="d">syntax</a> based
                    highlight groups.
                  • <span class="s">{treesitter}</span> (`boolean`, default: <span class="e">true</span>) Include
                    <a href="treesitter.txt.html#treesitter" class="d">treesitter</a> based highlight groups.
                  • <span class="s">{extmarks}</span> (`boolean|"all"`, default: true) Include
                    extmarks. When <span class="e">all</span>, then <a href="api.txt.html#extmarks" class="d">extmarks</a> without <a href="insert.txt.html#a" class="d">a</a> <span class="e">hl_group</span>
                    will also be included.
                  • <span class="s">{semantic_tokens}</span> (`boolean`, default: true) Include
                    semantic token highlights.




<span id="vim.Ringbuf" class="t">vim.Ringbuf</span>

<span class="h">    Fields: </span>
      • <span class="s">{clear}</span>  (`fun()`) See <a href="lua.txt.html#Ringbuf%3Aclear%28%29" class="l">Ringbuf:clear()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{push}</span>   (`fun(item: T)`) See <a href="lua.txt.html#Ringbuf%3Apush%28%29" class="l">Ringbuf:push()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{pop}</span>    (`fun(): T?`) See <a href="lua.txt.html#Ringbuf%3Apop%28%29" class="l">Ringbuf:pop()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{peek}</span>   (`fun(): T?`) See <a href="lua.txt.html#Ringbuf%3Apeek%28%29" class="l">Ringbuf:peek()</a><a href="repeat.txt.html#." class="d">.</a>


<a href="lua.txt.html#Ringbuf%3Aclear%28%29" class="d">Ringbuf:clear()</a>                                              <span id="Ringbuf%3Aclear%28%29" class="t">Ringbuf:clear()</span>
    Clear all items

<a href="lua.txt.html#Ringbuf%3Apeek%28%29" class="d">Ringbuf:peek()</a>                                                <span id="Ringbuf%3Apeek%28%29" class="t">Ringbuf:peek()</span>
    Returns the first unread item without removing <a href="motion.txt.html#it" class="d">it</a>

<span class="h">    Return: </span>
        (`any?`)

<a href="lua.txt.html#Ringbuf%3Apop%28%29" class="d">Ringbuf:pop()</a>                                                  <span id="Ringbuf%3Apop%28%29" class="t">Ringbuf:pop()</span>
    Removes and returns the first unread item

<span class="h">    Return: </span>
        (`any?`)

Ringbuf:push({item})                                          <span id="Ringbuf%3Apush%28%29" class="t">Ringbuf:push()</span>
    Adds an item, overriding the oldest item if the buffer <a href="motion.txt.html#is" class="d">is</a> full.

<span class="h">    Parameters: </span>
      • <span class="s">{item}</span>  (`any`)

vim.deep_equal({a}, <span class="s">{b}</span>)                                    <span id="vim.deep_equal%28%29" class="t">vim.deep_equal()</span>
    Deep compare values <a href="luaref.txt.html#for" class="d">for</a> equality

    Tables are compared recursively unless they both provide the <span class="e">eq</span>
    metamethod. All other types are compared using the equality <span class="e">==</span> operator.

<span class="h">    Parameters: </span>
      • <span class="s">{a}</span>  (`any`) First value
      • <span class="s">{b}</span>  (`any`) Second value

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if values are equals, else <span class="e">false</span>

vim.deepcopy({orig}, <span class="s">{noref}</span>)                                 <span id="vim.deepcopy%28%29" class="t">vim.deepcopy()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> deep copy of the given object. Non-table <a href="index.txt.html#objects" class="d">objects</a> are copied <a href="motion.txt.html#as" class="d">as</a>
    in <a href="insert.txt.html#a" class="d">a</a> typical <a href="lua.txt.html#Lua" class="d">Lua</a> assignment, whereas table <a href="index.txt.html#objects" class="d">objects</a> are copied recursively.
    Functions are naively copied, so <a href="vimeval.txt.html#functions" class="d">functions</a> in the copied table point to
    the same <a href="vimeval.txt.html#functions" class="d">functions</a> <a href="motion.txt.html#as" class="d">as</a> those in the input table. Userdata and threads are
    not copied and will throw an error.

    <span class="n">Note:</span> <span class="e">noref=true</span> <a href="motion.txt.html#is" class="d">is</a> much more performant on tables with unique table
    fields, while <span class="e">noref=false</span> <a href="motion.txt.html#is" class="d">is</a> more performant on tables that reuse table
    fields.

<span class="h">    Parameters: </span>
      • <span class="s">{orig}</span>   (`table`) Table to copy
      • <span class="s">{noref}</span>  (`boolean?`) When <span class="e">false</span> (default) <a href="insert.txt.html#a" class="d">a</a> contained table <a href="motion.txt.html#is" class="d">is</a> only
                 copied once and all references point to this single copy.
                 When <span class="e">true</span> every occurrence of <a href="insert.txt.html#a" class="d">a</a> table results in <a href="insert.txt.html#a" class="d">a</a> new
                 copy. This also means that <a href="insert.txt.html#a" class="d">a</a> cyclic <a href="intro.txt.html#reference" class="d">reference</a> can cause
                 <span class="e">deepcopy()</span> to fail.

<span class="h">    Return: </span>
        (`table`) Table of copied keys and (nested) values.

vim.defaulttable({createfn})                              <span id="vim.defaulttable%28%29" class="t">vim.defaulttable()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> table whose missing keys are provided by <span class="s">{createfn}</span> (like
    Python's "defaultdict").

    If <span class="s">{createfn}</span> <a href="motion.txt.html#is" class="d">is</a> <span class="e">nil</span> <a href="motion.txt.html#it" class="d">it</a> <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to defaulttable() itself, so accessing
    nested keys creates nested tables: 
<span class="e">        local a = vim.defaulttable()</span>
<span class="e">        a.b.c = 1</span>


<span class="h">    Parameters: </span>
      • <span class="s">{createfn}</span>  (`fun(key:any):any?`) Provides the value <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> missing
                    <span class="e">key</span>.

<span class="h">    Return: </span>
        (`table`) Empty table with <span class="e">__index</span> metamethod.

vim.endswith({s}, <span class="s">{suffix}</span>)                                   <span id="vim.endswith%28%29" class="t">vim.endswith()</span>
    Tests if <span class="e">s</span> ends with <span class="e">suffix</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>       (`string`) <a href="vimeval.txt.html#String" class="d">String</a>
      • <span class="s">{suffix}</span>  (`string`) Suffix to match

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">suffix</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> suffix of <span class="e">s</span>

vim.gsplit({s}, <span class="s">{sep}</span>, <span class="s">{opts}</span>)                                  <span id="vim.gsplit%28%29" class="t">vim.gsplit()</span>
    Gets an <a href="lua.txt.html#iterator" class="l">iterator</a> that splits <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> <a href="motion.txt.html#at" class="d">at</a> each instance of <a href="insert.txt.html#a" class="d">a</a> separator,
    in "lazy" fashion (as opposed to <a href="lua.txt.html#vim.split%28%29" class="l">vim.split()</a> which <a href="motion.txt.html#is" class="d">is</a> "eager").

    Example: 
<span class="e">        for s in vim.gsplit(':aa::b:', ':', {plain=true}) do</span>
<span class="e">          print(s)</span>
<span class="e">        end</span>


    If you want to also inspect the separator itself (instead of discarding
    it), use <a href="luaref.txt.html#string.gmatch%28%29" class="l">string.gmatch()</a><a href="repeat.txt.html#." class="d">.</a> Example: 
<span class="e">        for word, num in ('foo111bar222'):gmatch('([^0-9]*)(%d*)') do</span>
<span class="e">          print(('word: %s num: %s'):format(word, num))</span>
<span class="e">        end</span>


<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>     (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to split
      • <span class="s">{sep}</span>   (`string`) Separator or <a href="pattern.txt.html#pattern" class="d">pattern</a>
      • <span class="s">{opts}</span>  (`table?`) Keyword arguments <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="cmdline.txt.html#%3A" class="d">:</a>
                • <span class="s">{plain}</span>? (`boolean`) Use <span class="e">sep</span> literally (as in
                  string.find).
                • <span class="s">{trimempty}</span>? (`boolean`) Discard empty segments <a href="motion.txt.html#at" class="d">at</a> start and
                  <a href="intro.txt.html#end" class="d">end</a> of the sequence.

<span class="h">    Return: </span>
        (`fun():string?`) Iterator over the split components

<span class="h">    See also: </span>
      • <a href="luaref.txt.html#string.gmatch%28%29" class="l">string.gmatch()</a>
      • <a href="lua.txt.html#vim.split%28%29" class="l">vim.split()</a>
      • <a href="luaref.txt.html#lua-pattern" class="l">lua-pattern</a><a href="change.txt.html#s" class="d">s</a>
      • <a class="u" href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>
      • <a class="u" href="http://lua-users.org/wiki/StringLibraryTutorial">http://lua-users.org/wiki/StringLibraryTutorial</a>

vim.is_callable({f})                                       <span id="vim.is_callable%28%29" class="t">vim.is_callable()</span>
    Returns true if object <span class="e">f</span> can be called <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> function.

<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`any`) Any object

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">f</span> <a href="motion.txt.html#is" class="d">is</a> callable, else <span class="e">false</span>

vim.isarray({t})                                               <span id="vim.isarray%28%29" class="t">vim.isarray()</span>
    Tests if <span class="e">t</span> <a href="motion.txt.html#is" class="d">is</a> an "array"<a href="cmdline.txt.html#%3A" class="d">:</a> <a href="insert.txt.html#a" class="d">a</a> table indexed only by integers (potentially
    non-contiguous).

    If the indexes start from 1 and are contiguous then the array <a href="motion.txt.html#is" class="d">is</a> also <a href="insert.txt.html#a" class="d">a</a>
    list. <a href="lua.txt.html#vim.islist%28%29" class="l">vim.islist()</a>

    Empty table <span class="e">{}</span> <a href="motion.txt.html#is" class="d">is</a> an array, unless <a href="motion.txt.html#it" class="d">it</a> was created by <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a>
    or returned <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> dict-like <a href="api.txt.html#API" class="l">API</a> or Vimscript result, <a href="luaref.txt.html#for" class="d">for</a> example from
    <a href="vimfn.txt.html#rpcrequest%28%29" class="l">rpcrequest()</a> or <a href="lua.txt.html#vim.fn" class="l">vim.fn</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table?`)

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if array-like table, else <span class="e">false</span>.

<span class="h">    See also: </span>
      • <a class="u" href="https://github.com/openresty/luajit2#tableisarray">https://github.com/openresty/luajit2#tableisarray</a>

vim.islist({t})                                                 <span id="vim.islist%28%29" class="t">vim.islist()</span>
    Tests if <span class="e">t</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> "<a href="vimeval.txt.html#list" class="d">list</a>"<a href="cmdline.txt.html#%3A" class="d">:</a> <a href="insert.txt.html#a" class="d">a</a> table indexed only by contiguous integers
    <a href="starting.txt.html#starting" class="d">starting</a> from 1 (what <a href="luaref.txt.html#lua-length" class="l">lua-length</a> calls <a href="insert.txt.html#a" class="d">a</a> "regular array").

    Empty table <span class="e">{}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> list, unless <a href="motion.txt.html#it" class="d">it</a> was created by <a href="lua.txt.html#vim.empty_dict%28%29" class="l">vim.empty_dict()</a> or
    returned <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> dict-like <a href="api.txt.html#API" class="l">API</a> or Vimscript result, <a href="luaref.txt.html#for" class="d">for</a> example from
    <a href="vimfn.txt.html#rpcrequest%28%29" class="l">rpcrequest()</a> or <a href="lua.txt.html#vim.fn" class="l">vim.fn</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table?`)

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if list-like table, else <span class="e">false</span>.

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.isarray%28%29" class="l">vim.isarray()</a>

vim.list_contains({t}, <span class="s">{value}</span>)                          <span id="vim.list_contains%28%29" class="t">vim.list_contains()</span>
    Checks if <a href="insert.txt.html#a" class="d">a</a> list-like table (integer keys without gaps) contains <span class="e">value</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>      (`table`) Table to check (must be list-like, not validated)
      • <span class="s">{value}</span>  (`any`) Value to compare

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">t</span> contains <span class="e">value</span>

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.tbl_contains%28%29" class="l">vim.tbl_contains()</a> <a href="luaref.txt.html#for" class="d">for</a> checking values in general tables

vim.list_extend({dst}, <span class="s">{src}</span>, <span class="s">{start}</span>, <span class="s">{finish}</span>)           <span id="vim.list_extend%28%29" class="t">vim.list_extend()</span>
    Extends <a href="insert.txt.html#a" class="d">a</a> list-like table with the values of another list-like table.

    <span class="n">NOTE:</span> This mutates dst!

<span class="h">    Parameters: </span>
      • <span class="s">{dst}</span>     (`table`) <a href="vimeval.txt.html#List" class="d">List</a> which will be modified and appended to
      • <span class="s">{src}</span>     (`table`) <a href="vimeval.txt.html#List" class="d">List</a> from which values will be inserted
      • <span class="s">{start}</span>   (`integer?`) Start <a href="index.txt.html#index" class="d">index</a> on src. Defaults to 1
      • <span class="s">{finish}</span>  (`integer?`) Final <a href="index.txt.html#index" class="d">index</a> on src. Defaults to <span class="e">#src</span>

<span class="h">    Return: </span>
        (`table`) dst

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.tbl_extend%28%29" class="l">vim.tbl_extend()</a>

vim.list_slice({list}, <span class="s">{start}</span>, <span class="s">{finish}</span>)                   <span id="vim.list_slice%28%29" class="t">vim.list_slice()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> copy of <a href="insert.txt.html#a" class="d">a</a> table containing only elements from start to <a href="intro.txt.html#end" class="d">end</a>
    (inclusive)

<span class="h">    Parameters: </span>
      • <span class="s">{list}</span>    (`any[]`) Table
      • <span class="s">{start}</span>   (`integer?`) Start range of <a href="vimeval.txt.html#slice" class="d">slice</a>
      • <span class="s">{finish}</span>  (`integer?`) End range of <a href="vimeval.txt.html#slice" class="d">slice</a>

<span class="h">    Return: </span>
        (`any[]`) Copy of table sliced from start to finish (inclusive)

vim.pesc({s})                                                     <span id="vim.pesc%28%29" class="t">vim.pesc()</span>
    Escapes magic chars in <a href="luaref.txt.html#lua-pattern" class="l">lua-pattern</a>s.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to <a href="intro.txt.html#escape" class="d">escape</a>

<span class="h">    Return: </span>
        (`string`) %-escaped <a href="pattern.txt.html#pattern" class="d">pattern</a> <a href="vimeval.txt.html#string" class="d">string</a>

<span class="h">    See also: </span>
      • <a class="u" href="https://github.com/rxi/lume">https://github.com/rxi/lume</a>

vim.ringbuf({size})                                            <span id="vim.ringbuf%28%29" class="t">vim.ringbuf()</span>
    Create <a href="insert.txt.html#a" class="d">a</a> ring buffer limited to <a href="insert.txt.html#a" class="d">a</a> maximal number of items. Once the buffer
    <a href="motion.txt.html#is" class="d">is</a> full, adding <a href="insert.txt.html#a" class="d">a</a> new entry overrides the oldest entry. 
<span class="e">        local ringbuf = vim.ringbuf(4)</span>
<span class="e">        ringbuf:push("a")</span>
<span class="e">        ringbuf:push("b")</span>
<span class="e">        ringbuf:push("c")</span>
<span class="e">        ringbuf:push("d")</span>
<span class="e">        ringbuf:push("e")    -- overrides "a"</span>
<span class="e">        print(ringbuf:pop()) -- returns "b"</span>
<span class="e">        print(ringbuf:pop()) -- returns "c"</span>
<span class="e"></span>
<span class="e">        -- Can be used as iterator. Pops remaining items:</span>
<span class="e">        for val in ringbuf do</span>
<span class="e">          print(val)</span>
<span class="e">        end</span>


    Returns <a href="insert.txt.html#a" class="d">a</a> Ringbuf instance with the following methods:
    • <a href="lua.txt.html#Ringbuf%3Apush%28%29" class="l">Ringbuf:push()</a>
    • <a href="lua.txt.html#Ringbuf%3Apop%28%29" class="l">Ringbuf:pop()</a>
    • <a href="lua.txt.html#Ringbuf%3Apeek%28%29" class="l">Ringbuf:peek()</a>
    • <a href="lua.txt.html#Ringbuf%3Aclear%28%29" class="l">Ringbuf:clear()</a>

<span class="h">    Parameters: </span>
      • <span class="s">{size}</span>  (`integer`)

<span class="h">    Return: </span>
        (`vim.Ringbuf`) ringbuf See <a href="lua.txt.html#vim.Ringbuf" class="l">vim.Ringbuf</a><a href="repeat.txt.html#." class="d">.</a>

vim.spairs({t})                                                 <span id="vim.spairs%28%29" class="t">vim.spairs()</span>
    Enumerates key-value pairs of <a href="insert.txt.html#a" class="d">a</a> table, ordered by key.

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table`) Dict-like table

<span class="h">    Return (multiple): </span>
        (`fun(table: table&lt;K, V&gt;, index?: K):K, V`) <a href="luaref.txt.html#for-in" class="l">for-in</a> <a href="lua.txt.html#iterator" class="d">iterator</a> over
        sorted keys and their values
        (`table`)

<span class="h">    See also: </span>
      • Based on
        <a class="u" href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>

vim.split({s}, <span class="s">{sep}</span>, <span class="s">{opts}</span>)                                    <span id="vim.split%28%29" class="t">vim.split()</span>
    Splits <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> <a href="motion.txt.html#at" class="d">at</a> each instance of <a href="insert.txt.html#a" class="d">a</a> separator and returns the result <a href="motion.txt.html#as" class="d">as</a>
    <a href="insert.txt.html#a" class="d">a</a> table (unlike <a href="lua.txt.html#vim.gsplit%28%29" class="l">vim.gsplit()</a>).

    Examples: 
<span class="e">        split(":aa::b:", ":")                   --&gt; {'','aa','','b',''}</span>
<span class="e">        split("axaby", "ab?")                   --&gt; {'','x','y'}</span>
<span class="e">        split("x*yz*o", "*", {plain=true})      --&gt; {'x','yz','o'}</span>
<span class="e">        split("|x|y|z|", "|", {trimempty=true}) --&gt; {'x', 'y', 'z'}</span>


<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>     (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to split
      • <span class="s">{sep}</span>   (`string`) Separator or <a href="pattern.txt.html#pattern" class="d">pattern</a>
      • <span class="s">{opts}</span>  (`table?`) Keyword arguments <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="cmdline.txt.html#%3A" class="d">:</a>
                • <span class="s">{plain}</span>? (`boolean`) Use <span class="e">sep</span> literally (as in
                  string.find).
                • <span class="s">{trimempty}</span>? (`boolean`) Discard empty segments <a href="motion.txt.html#at" class="d">at</a> start and
                  <a href="intro.txt.html#end" class="d">end</a> of the sequence.

<span class="h">    Return: </span>
        (`string[]`) <a href="vimeval.txt.html#List" class="d">List</a> of split components

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.gsplit%28%29" class="l">vim.gsplit()</a>
      • <a href="luaref.txt.html#string.gmatch%28%29" class="l">string.gmatch()</a>

vim.startswith({s}, <span class="s">{prefix}</span>)                               <span id="vim.startswith%28%29" class="t">vim.startswith()</span>
    Tests if <span class="e">s</span> starts with <span class="e">prefix</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>       (`string`) <a href="vimeval.txt.html#String" class="d">String</a>
      • <span class="s">{prefix}</span>  (`string`) Prefix to match

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">prefix</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> prefix of <span class="e">s</span>

vim.tbl_contains({t}, <span class="s">{value}</span>, <span class="s">{opts}</span>)                    <span id="vim.tbl_contains%28%29" class="t">vim.tbl_contains()</span>
    Checks if <a href="insert.txt.html#a" class="d">a</a> table contains <a href="insert.txt.html#a" class="d">a</a> given value, specified either directly or via
    <a href="insert.txt.html#a" class="d">a</a> predicate that <a href="motion.txt.html#is" class="d">is</a> checked <a href="luaref.txt.html#for" class="d">for</a> each value.

    Example: 
<span class="e">        vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)</span>
<span class="e">          return vim.deep_equal(v, { 'b', 'c' })</span>
<span class="e">        end, { predicate = true })</span>
<span class="e">        -- true</span>


<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>      (`table`) Table to check
      • <span class="s">{value}</span>  (`any`) Value to compare or predicate function <a href="intro.txt.html#reference" class="d">reference</a>
      • <span class="s">{opts}</span>   (`table?`) Keyword arguments <a href="lua.txt.html#kwargs" class="l">kwargs</a><a href="cmdline.txt.html#%3A" class="d">:</a>
                 • <span class="s">{predicate}</span>? (`boolean`) <span class="e">value</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function <a href="intro.txt.html#reference" class="d">reference</a> to
                   be checked (default false)

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">t</span> contains <span class="e">value</span>

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.list_contains%28%29" class="l">vim.list_contains()</a> <a href="luaref.txt.html#for" class="d">for</a> checking values in list-like tables

vim.tbl_count({t})                                           <span id="vim.tbl_count%28%29" class="t">vim.tbl_count()</span>
    Counts the number of non-nil values in table <span class="e">t</span>. 
<span class="e">        vim.tbl_count({ a=1, b=2 })  --&gt; 2</span>
<span class="e">        vim.tbl_count({ 1, 2 })      --&gt; 2</span>


<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table`) Table

<span class="h">    Return: </span>
        (`integer`) <a href="vimeval.txt.html#Number" class="d">Number</a> of non-nil values in table

<span class="h">    See also: </span>
      • <a class="u" href="https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua">https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua</a>

vim.tbl_deep_extend({behavior}, <span class="s">{...}</span>)                 <span id="vim.tbl_deep_extend%28%29" class="t">vim.tbl_deep_extend()</span>
    Merges recursively two or more tables.

    Only values that are empty tables or tables that are not <a href="lua.txt.html#lua-list" class="l">lua-list</a><a href="change.txt.html#s" class="d">s</a>
    (indexed by consecutive integers <a href="starting.txt.html#starting" class="d">starting</a> from 1) are merged recursively.
    This <a href="motion.txt.html#is" class="d">is</a> useful <a href="luaref.txt.html#for" class="d">for</a> merging nested tables like default and user
    configurations where lists should be treated <a href="motion.txt.html#as" class="d">as</a> literals (i.e., are
    overwritten instead of merged).

<span class="h">    Parameters: </span>
      • <span class="s">{behavior}</span>  (`'error'<span class="l">'keep'</span><span class="o">'force'</span>`) Decides what to <a href="diff.txt.html#do" class="d">do</a> if <a href="insert.txt.html#a" class="d">a</a> key <a href="motion.txt.html#is" class="d">is</a>
                    found in more than one map:
                    • "error"<a href="cmdline.txt.html#%3A" class="d">:</a> raise an error
                    • "keep"<a href="cmdline.txt.html#%3A" class="d">:</a> use value from the leftmost map
                    • "force"<a href="cmdline.txt.html#%3A" class="d">:</a> use value from the rightmost map
      • <span class="s">{...}</span>       (`table`) Two or more tables

<span class="h">    Return: </span>
        (`table`) Merged table

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.tbl_extend%28%29" class="l">vim.tbl_extend()</a>

vim.tbl_extend({behavior}, <span class="s">{...}</span>)                           <span id="vim.tbl_extend%28%29" class="t">vim.tbl_extend()</span>
    Merges two or more tables.

<span class="h">    Parameters: </span>
      • <span class="s">{behavior}</span>  (`'error'<span class="l">'keep'</span><span class="o">'force'</span>`) Decides what to <a href="diff.txt.html#do" class="d">do</a> if <a href="insert.txt.html#a" class="d">a</a> key <a href="motion.txt.html#is" class="d">is</a>
                    found in more than one map:
                    • "error"<a href="cmdline.txt.html#%3A" class="d">:</a> raise an error
                    • "keep"<a href="cmdline.txt.html#%3A" class="d">:</a> use value from the leftmost map
                    • "force"<a href="cmdline.txt.html#%3A" class="d">:</a> use value from the rightmost map
      • <span class="s">{...}</span>       (`table`) Two or more tables

<span class="h">    Return: </span>
        (`table`) Merged table

<span class="h">    See also: </span>
      • <a href="vimfn.txt.html#extend%28%29" class="l">extend()</a>

vim.tbl_filter({func}, <span class="s">{t}</span>)                                 <span id="vim.tbl_filter%28%29" class="t">vim.tbl_filter()</span>
    Filter <a href="insert.txt.html#a" class="d">a</a> table using <a href="insert.txt.html#a" class="d">a</a> predicate function

<span class="h">    Parameters: </span>
      • <span class="s">{func}</span>  (`function`) Function
      • <span class="s">{t}</span>     (`table`) Table

<span class="h">    Return: </span>
        (`any[]`) Table of filtered values

vim.tbl_get({o}, <span class="s">{...}</span>)                                        <span id="vim.tbl_get%28%29" class="t">vim.tbl_get()</span>
    Index into <a href="insert.txt.html#a" class="d">a</a> table (first argument) via <a href="vimeval.txt.html#string" class="d">string</a> keys passed <a href="motion.txt.html#as" class="d">as</a> subsequent
    arguments. Return <span class="e">nil</span> if the key does not exist.

    Examples: 
<span class="e">        vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true</span>
<span class="e">        vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil</span>


<span class="h">    Parameters: </span>
      • <span class="s">{o}</span>    (`table`) Table to <a href="index.txt.html#index" class="d">index</a>
      • <span class="s">{...}</span>  (`any`) Optional keys (0 or more, variadic) via which to <a href="index.txt.html#index" class="d">index</a>
               the table

<span class="h">    Return: </span>
        (`any`) Nested value indexed by key (if <a href="motion.txt.html#it" class="d">it</a> exists), else nil

vim.tbl_isempty({t})                                       <span id="vim.tbl_isempty%28%29" class="t">vim.tbl_isempty()</span>
    Checks if <a href="insert.txt.html#a" class="d">a</a> table <a href="motion.txt.html#is" class="d">is</a> empty.

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table`) Table to check

<span class="h">    Return: </span>
        (`boolean`) <span class="e">true</span> if <span class="e">t</span> <a href="motion.txt.html#is" class="d">is</a> empty

<span class="h">    See also: </span>
      • <a class="u" href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>

vim.tbl_keys({t})                                             <span id="vim.tbl_keys%28%29" class="t">vim.tbl_keys()</span>
    Return <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of all keys used in <a href="insert.txt.html#a" class="d">a</a> table. However, the order of the
    return table of keys <a href="motion.txt.html#is" class="d">is</a> not guaranteed.

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table`) Table

<span class="h">    Return: </span>
        (`any[]`) <a href="vimeval.txt.html#List" class="d">List</a> of keys

<span class="h">    See also: </span>
      • From
        <a class="u" href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>

vim.tbl_map({func}, <span class="s">{t}</span>)                                       <span id="vim.tbl_map%28%29" class="t">vim.tbl_map()</span>
    Apply <a href="insert.txt.html#a" class="d">a</a> function to all values of <a href="insert.txt.html#a" class="d">a</a> table.

<span class="h">    Parameters: </span>
      • <span class="s">{func}</span>  (`fun(value: T): any`) Function
      • <span class="s">{t}</span>     (`table&lt;any, T&gt;`) Table

<span class="h">    Return: </span>
        (`table`) Table of transformed values

vim.tbl_values({t})                                         <span id="vim.tbl_values%28%29" class="t">vim.tbl_values()</span>
    Return <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of all values used in <a href="insert.txt.html#a" class="d">a</a> table. However, the order of the
    return table of values <a href="motion.txt.html#is" class="d">is</a> not guaranteed.

<span class="h">    Parameters: </span>
      • <span class="s">{t}</span>  (`table`) Table

<span class="h">    Return: </span>
        (`any[]`) <a href="vimeval.txt.html#List" class="d">List</a> of values

vim.trim({s})                                                     <span id="vim.trim%28%29" class="t">vim.trim()</span>
    Trim <a href="pattern.txt.html#whitespace" class="d">whitespace</a> (Lua <a href="pattern.txt.html#pattern" class="d">pattern</a> "%s"<a href="motion.txt.html#%29" class="d">)</a> from both sides of <a href="insert.txt.html#a" class="d">a</a> string.

<span class="h">    Parameters: </span>
      • <span class="s">{s}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to trim

<span class="h">    Return: </span>
        (`string`) <a href="vimeval.txt.html#String" class="d">String</a> with <a href="pattern.txt.html#whitespace" class="d">whitespace</a> removed from its beginning and <a href="intro.txt.html#end" class="d">end</a>

<span class="h">    See also: </span>
      • <a href="luaref.txt.html#lua-pattern" class="l">lua-pattern</a><a href="change.txt.html#s" class="d">s</a>
      • <a class="u" href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>

                                                              <span id="vim.validate%28%29" class="t">vim.validate()</span>
vim.validate({name}, <span class="s">{value}</span>, <span class="s">{validator}</span>, <span class="s">{optional}</span>, <span class="s">{message}</span>)
    Validate function arguments.

    This function has two valid forms:
    1. `vim.validate(name, value, validator[, optional][, message])`
       Validates that argument <span class="s">{name}</span> with value <span class="s">{value}</span> satisfies
       <span class="s">{validator}</span>. If <span class="s">{optional}</span> <a href="motion.txt.html#is" class="d">is</a> given and <a href="motion.txt.html#is" class="d">is</a> <span class="e">true</span>, then <span class="s">{value}</span> may be
       <span class="e">nil</span>. If <span class="s">{message}</span> <a href="motion.txt.html#is" class="d">is</a> given, then <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> used <a href="motion.txt.html#as" class="d">as</a> the expected type in
       the error message.
       Example: 
<span class="e">         function vim.startswith(s, prefix)</span>
<span class="e">          vim.validate('s', s, 'string')</span>
<span class="e">          vim.validate('prefix', prefix, 'string')</span>
<span class="e">          -- ...</span>
<span class="e">        end</span>

    2. <span class="e">vim.validate(spec)</span> (deprecated) where <span class="e">spec</span> <a href="motion.txt.html#is" class="d">is</a> of type
       `table&lt;string,[value:any, validator: vim.validate.Validator, optional_or_msg? <a href="cmdline.txt.html#%3A" class="d">:</a> <a href="options.txt.html#boolean" class="d">boolean</a>|string]&gt;)`
       Validates <a href="insert.txt.html#a" class="d">a</a> argument specification. Specs are evaluated in alphanumeric
       order, until the first failure.
       Example: 
<span class="e">         function user.new(name, age, hobbies)</span>
<span class="e">          vim.validate{</span>
<span class="e">            name={name, 'string'},</span>
<span class="e">            age={age, 'number'},</span>
<span class="e">            hobbies={hobbies, 'table'},</span>
<span class="e">          }</span>
<span class="e">          -- ...</span>
<span class="e">        end</span>


    Examples with explicit argument values (can be run directly): 
<span class="e">        vim.validate('arg1', {'foo'}, 'table')</span>
<span class="e">           --&gt; NOP (success)</span>
<span class="e">        vim.validate('arg2', 'foo', 'string')</span>
<span class="e">           --&gt; NOP (success)</span>
<span class="e"></span>
<span class="e">        vim.validate('arg1', 1, 'table')</span>
<span class="e">           --&gt; error('arg1: expected table, got number')</span>
<span class="e"></span>
<span class="e">        vim.validate('arg1', 3, function(a) return (a % 2) == 0 end, 'even number')</span>
<span class="e">           --&gt; error('arg1: expected even number, got 3')</span>


    If multiple types are valid they can be given <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> list. 
<span class="e">        vim.validate('arg1', {'foo'}, {'table', 'string'})</span>
<span class="e">        vim.validate('arg2', 'foo', {'table', 'string'})</span>
<span class="e">        -- NOP (success)</span>
<span class="e"></span>
<span class="e">        vim.validate('arg1', 1, {'string', 'table'})</span>
<span class="e">        -- error('arg1: expected string|table, got number')</span>


<span class="h">    Note: </span>
      • <span class="e">validator</span> set to <a href="insert.txt.html#a" class="d">a</a> value returned by <a href="luaref.txt.html#lua-type%28%29" class="l">lua-type()</a> provides the best
        performance.

<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>       (`string`) Argument name
      • <span class="s">{value}</span>      (`any`) Argument value
      • <span class="s">{validator}</span>  (`vim.validate.Validator`)
                     • (`string|string[]`): Any value that can be returned
                       from <a href="luaref.txt.html#lua-type%28%29" class="l">lua-type()</a> in addition to <span class="e">'callable'</span>:
                       <span class="e">'boolean'</span>, <span class="e">'callable'</span>, <span class="e">'function'</span>, <span class="e">'nil'</span>,
                       <span class="e">'number'</span>, <span class="e">'string'</span>, <span class="e">'table'</span>, <span class="e">'thread'</span>,
                       <span class="e">'userdata'</span>.
                     • (`fun(val:any): boolean, string?`) <a href="insert.txt.html#A" class="d">A</a> function that
                       returns <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#boolean" class="d">boolean</a> and an optional <a href="vimeval.txt.html#string" class="d">string</a> message.
      • <span class="s">{optional}</span>   (`boolean?`) Argument <a href="motion.txt.html#is" class="d">is</a> optional (may be omitted)
      • <span class="s">{message}</span>    (`string?`) message when validation fails


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.loader" class="d">vim.loader</a>                                            <span id="vim.loader" class="t">vim.loader</span>

vim.loader.enable({enable})                              <span id="vim.loader.enable%28%29" class="t">vim.loader.enable()</span>
    WARNING: This feature <a href="motion.txt.html#is" class="d">is</a> experimental/unstable.

    Enables or disables the experimental <a href="lua.txt.html#Lua" class="d">Lua</a> module loader:

    Enable (`enable=true`):
    • overrides <a href="luaref.txt.html#loadfile%28%29" class="l">loadfile()</a>
    • adds the <a href="lua.txt.html#Lua" class="d">Lua</a> loader using the byte-compilation cache
    • adds the libs loader
    • removes the default Nvim loader

    Disable (`enable=false`):
    • removes the loaders
    • adds the default Nvim loader

<span class="h">    Parameters: </span>
      • <span class="s">{enable}</span>  (`boolean?`) true/nil to enable, false to disable

vim.loader.find({modname}, <span class="s">{opts}</span>)                         <span id="vim.loader.find%28%29" class="t">vim.loader.find()</span>
    WARNING: This feature <a href="motion.txt.html#is" class="d">is</a> experimental/unstable.

    Finds <a href="lua.txt.html#Lua" class="d">Lua</a> modules <a href="luaref.txt.html#for" class="d">for</a> the given module name.

<span class="h">    Parameters: </span>
      • <span class="s">{modname}</span>  (`string`) Module name, or <span class="e">"*"</span> to find the top-level
                   modules instead
      • <span class="s">{opts}</span>     (`table?`) Options <a href="luaref.txt.html#for" class="d">for</a> finding <a href="insert.txt.html#a" class="d">a</a> module:
                   • <span class="s">{rtp}</span>? (`boolean`, default: <span class="e">true</span>) Search <a href="luaref.txt.html#for" class="d">for</a> modname in
                     the runtime path.
                   • <span class="s">{paths}</span>? (`string[]`, default: <span class="e">{}</span>) Extra paths to
                     search <a href="luaref.txt.html#for" class="d">for</a> modname
                   • <span class="s">{patterns}</span>? (`string[]`, default:
                     <a href="motion.txt.html#%60%7B" class="d">`{</a>"/init.lua"<a href="motion.txt.html#%2C" class="d">,</a> ".lua"}`) <a href="vimeval.txt.html#List" class="d">List</a> of patterns to use when
                     searching <a href="luaref.txt.html#for" class="d">for</a> modules. <a href="insert.txt.html#A" class="d">A</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> added to the
                     basename of the <a href="lua.txt.html#Lua" class="d">Lua</a> module being searched.
                   • <span class="s">{all}</span>? (`boolean`, default: <span class="e">false</span>) Search <a href="luaref.txt.html#for" class="d">for</a> all
                     matches.

<span class="h">    Return: </span>
        (`table[]`) <a href="insert.txt.html#A" class="d">A</a> <a href="vimeval.txt.html#list" class="d">list</a> of <a href="index.txt.html#objects" class="d">objects</a> with the following fields:
        • <span class="s">{modpath}</span> (`string`) Path of the module
        • <span class="s">{modname}</span> (`string`) Name of the module
        • <span class="s">{stat}</span>? (`uv.fs_stat.result`) The fs_stat of the module path. Won't
          be returned <a href="luaref.txt.html#for" class="d">for</a> <span class="e">modname="*"</span>

vim.loader.reset({path})                                  <span id="vim.loader.reset%28%29" class="t">vim.loader.reset()</span>
    WARNING: This feature <a href="motion.txt.html#is" class="d">is</a> experimental/unstable.

    Resets the cache <a href="luaref.txt.html#for" class="d">for</a> the path, or all the paths if path <a href="motion.txt.html#is" class="d">is</a> nil.

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string?`) path to reset


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.uri" class="d">vim.uri</a>                                                  <span id="vim.uri" class="t">vim.uri</span>

vim.uri_decode({str})                                       <span id="vim.uri_decode%28%29" class="t">vim.uri_decode()</span>
    URI-decodes <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> containing percent escapes.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) <a href="vimeval.txt.html#string" class="d">string</a> to decode

<span class="h">    Return: </span>
        (`string`) decoded <a href="vimeval.txt.html#string" class="d">string</a>

vim.uri_encode({str}, <span class="s">{rfc}</span>)                                <span id="vim.uri_encode%28%29" class="t">vim.uri_encode()</span>
    URI-encodes <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> using percent escapes.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) <a href="vimeval.txt.html#string" class="d">string</a> to encode
      • <span class="s">{rfc}</span>  (`"rfc2396"|"rfc2732"|"rfc3986"?`)

<span class="h">    Return: </span>
        (`string`) encoded <a href="vimeval.txt.html#string" class="d">string</a>

vim.uri_from_bufnr({bufnr})                             <span id="vim.uri_from_bufnr%28%29" class="t">vim.uri_from_bufnr()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> URI from <a href="insert.txt.html#a" class="d">a</a> bufnr.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>  (`integer`)

<span class="h">    Return: </span>
        (`string`) URI

vim.uri_from_fname({path})                              <span id="vim.uri_from_fname%28%29" class="t">vim.uri_from_fname()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> URI from <a href="insert.txt.html#a" class="d">a</a> file path.

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path to file

<span class="h">    Return: </span>
        (`string`) URI

vim.uri_to_bufnr({uri})                                   <span id="vim.uri_to_bufnr%28%29" class="t">vim.uri_to_bufnr()</span>
    Gets the buffer <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> uri. Creates <a href="insert.txt.html#a" class="d">a</a> new unloaded buffer if no buffer <a href="luaref.txt.html#for" class="d">for</a>
    the uri already exists.

<span class="h">    Parameters: </span>
      • <span class="s">{uri}</span>  (`string`)

<span class="h">    Return: </span>
        (`integer`) bufnr

vim.uri_to_fname({uri})                                   <span id="vim.uri_to_fname%28%29" class="t">vim.uri_to_fname()</span>
    Gets <a href="insert.txt.html#a" class="d">a</a> filename from <a href="insert.txt.html#a" class="d">a</a> URI.

<span class="h">    Parameters: </span>
      • <span class="s">{uri}</span>  (`string`)

<span class="h">    Return: </span>
        (`string`) filename or unchanged URI <a href="luaref.txt.html#for" class="d">for</a> non-file URIs


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.ui" class="d">vim.ui</a>                                                    <span id="vim.ui" class="t">vim.ui</span>

vim.ui.input({opts}, <span class="s">{on_confirm}</span>)                            <span id="vim.ui.input%28%29" class="t">vim.ui.input()</span>
    Prompts the user <a href="luaref.txt.html#for" class="d">for</a> input, allowing arbitrary (potentially asynchronous)
    work until <span class="e">on_confirm</span>.

    Example: 
<span class="e">        vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)</span>
<span class="e">            vim.o.shiftwidth = tonumber(input)</span>
<span class="e">        end)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>        (`table?`) Additional options. See <a href="vimfn.txt.html#input%28%29" class="l">input()</a>
                      • prompt (string|nil) Text of the prompt
                      • default (string|nil) Default reply to the input
                      • completion (string|nil) Specifies type of completion
                        supported <a href="luaref.txt.html#for" class="d">for</a> input. Supported types are the same that
                        can be supplied to <a href="insert.txt.html#a" class="d">a</a> user-defined command using the
                        "-complete=" argument. See <a href="map.txt.html#%3Acommand-completion" class="l">:command-completion</a>
                      • highlight (function) Function that will be used <a href="luaref.txt.html#for" class="d">for</a>
                        highlighting user inputs.
      • <span class="s">{on_confirm}</span>  (`function`) ((input|nil) <a href="vimeval.txt.html#-%3E" class="d">-&gt;</a> ()) Called once the user
                      confirms or abort the input. <span class="e">input</span> <a href="motion.txt.html#is" class="d">is</a> what the user
                      typed (it might be an empty <a href="vimeval.txt.html#string" class="d">string</a> if nothing was
                      entered), or <span class="e">nil</span> if the user aborted the dialog.

vim.ui.open({path}, <span class="s">{opt}</span>)                                     <span id="vim.ui.open%28%29" class="t">vim.ui.open()</span>
    Opens <span class="e">path</span> with the system default handler (macOS <span class="e">open</span>, Windows
    <span class="e">explorer.exe</span>, Linux <span class="e">xdg-open</span>, …), or returns (but does not show) an
    error message on failure.

    Can also be invoked with <span class="e">:Open</span>.                                  <span id="%3AOpen" class="t">:Open</span>

    Expands "~/" and environment <a href="vimeval.txt.html#variables" class="d">variables</a> in filesystem paths.

    Examples: 
<span class="e">        -- Asynchronous.</span>
<span class="e">        vim.ui.open("https://neovim.io/")</span>
<span class="e">        vim.ui.open("~/path/to/file")</span>
<span class="e">        -- Use the "osurl" command to handle the path or URL.</span>
<span class="e">        vim.ui.open("gh#neovim/neovim!29490", { cmd = { 'osurl' } })</span>
<span class="e">        -- Synchronous (wait until the process exits).</span>
<span class="e">        local cmd, err = vim.ui.open("$VIMRUNTIME")</span>
<span class="e">        if cmd then</span>
<span class="e">          cmd:wait()</span>
<span class="e">        end</span>


<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path or URL to open
      • <span class="s">{opt}</span>   (`{ cmd?: string[] }?`) Options
                • cmd string[]|nil Command used to open the path or URL.

<span class="h">    Return (multiple): </span>
        (`vim.SystemObj?`) Command object, or nil if not found.
        (`string?`) Error message on failure, or nil on success.

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.system%28%29" class="l">vim.system()</a>

vim.ui.select({items}, <span class="s">{opts}</span>, <span class="s">{on_choice}</span>)                  <span id="vim.ui.select%28%29" class="t">vim.ui.select()</span>
    Prompts the user to pick from <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of items, allowing arbitrary
    (potentially asynchronous) work until <span class="e">on_choice</span>.

    Example: 
<span class="e">        vim.ui.select({ 'tabs', 'spaces' }, {</span>
<span class="e">            prompt = 'Select tabs or spaces:',</span>
<span class="e">            format_item = function(item)</span>
<span class="e">                return "I'd like to choose " .. item</span>
<span class="e">            end,</span>
<span class="e">        }, function(choice)</span>
<span class="e">            if choice == 'spaces' then</span>
<span class="e">                vim.o.expandtab = true</span>
<span class="e">            else</span>
<span class="e">                vim.o.expandtab = false</span>
<span class="e">            end</span>
<span class="e">        end)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{items}</span>      (`any[]`) Arbitrary items
      • <span class="s">{opts}</span>       (`table`) Additional <a href="options.txt.html#options" class="d">options</a>
                     • prompt (string|nil) Text of the prompt. Defaults to
                       `Select one of:`
                     • format_item (function item <a href="vimeval.txt.html#-%3E" class="d">-&gt;</a> text) Function to format
                       an individual item from <span class="e">items</span>. Defaults to
                       <span class="e">tostring</span>.
                     • kind (string|nil) Arbitrary hint <a href="vimeval.txt.html#string" class="d">string</a> indicating the
                       item shape. Plugins reimplementing <span class="e">vim.ui.select</span> may
                       wish to use this to infer the structure or semantics of
                       <span class="e">items</span>, or the <a href="repeat.txt.html#context" class="d">context</a> in which <a href="luaref.txt.html#select%28%29" class="d">select()</a> was called.
      • <span class="s">{on_choice}</span>  (`fun(item: T?, idx: integer?)`) Called once the user
                     made <a href="insert.txt.html#a" class="d">a</a> choice. <span class="e">idx</span> <a href="motion.txt.html#is" class="d">is</a> the 1-based <a href="index.txt.html#index" class="d">index</a> of <span class="e">item</span>
                     within <span class="e">items</span>. <span class="e">nil</span> if the user aborted the dialog.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.filetype" class="d">vim.filetype</a>                                        <span id="vim.filetype" class="t">vim.filetype</span>

vim.filetype.add({filetypes})                             <span id="vim.filetype.add%28%29" class="t">vim.filetype.add()</span>
    Add new <a href="filetype.txt.html#filetype" class="d">filetype</a> mappings.

    Filetype mappings can be added either by extension or by filename (either
    the "tail" or the full file path). The full file path <a href="motion.txt.html#is" class="d">is</a> checked first,
    followed by the file name. If <a href="insert.txt.html#a" class="d">a</a> match <a href="motion.txt.html#is" class="d">is</a> not found using the filename,
    then the filename <a href="motion.txt.html#is" class="d">is</a> matched against the <a href="vimeval.txt.html#list" class="d">list</a> of <a href="luaref.txt.html#lua-pattern" class="l">lua-pattern</a><a href="change.txt.html#s" class="d">s</a> (sorted by
    priority) until <a href="insert.txt.html#a" class="d">a</a> match <a href="motion.txt.html#is" class="d">is</a> found. Lastly, if <a href="pattern.txt.html#pattern" class="d">pattern</a> matching does not
    find <a href="insert.txt.html#a" class="d">a</a> filetype, then the file extension <a href="motion.txt.html#is" class="d">is</a> used.

    The <a href="filetype.txt.html#filetype" class="d">filetype</a> can be either <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> (in which <a href="change.txt.html#case" class="d">case</a> <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> used <a href="motion.txt.html#as" class="d">as</a> the
    <a href="filetype.txt.html#filetype" class="d">filetype</a> directly) or <a href="insert.txt.html#a" class="d">a</a> function. If <a href="insert.txt.html#a" class="d">a</a> function, <a href="motion.txt.html#it" class="d">it</a> takes the full path
    and buffer number of the file <a href="motion.txt.html#as" class="d">as</a> arguments (along with captures from the
    matched pattern, if any) and should return <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> that will be used <a href="motion.txt.html#as" class="d">as</a>
    the buffer's filetype. Optionally, the function can return <a href="insert.txt.html#a" class="d">a</a> second
    function value which, when called, modifies the state of the buffer. This
    can be used to, <a href="luaref.txt.html#for" class="d">for</a> example, set filetype-specific buffer variables. This
    function will be called by Nvim before setting the buffer's filetype.

    Filename patterns can specify an optional priority to resolve cases when <a href="insert.txt.html#a" class="d">a</a>
    file path matches multiple patterns. Higher priorities are matched first.
    When omitted, the priority <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to 0. <a href="insert.txt.html#A" class="d">A</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> can contain
    environment <a href="vimeval.txt.html#variables" class="d">variables</a> of the form "${SOME_VAR}" that will be automatically
    expanded. If the environment variable <a href="motion.txt.html#is" class="d">is</a> not set, the <a href="pattern.txt.html#pattern" class="d">pattern</a> won't be
    matched.

    See $VIMRUNTIME/lua/vim/filetype.lua <a href="luaref.txt.html#for" class="d">for</a> more examples.

    Example: 
<span class="e">        vim.filetype.add({</span>
<span class="e">          extension = {</span>
<span class="e">            foo = 'fooscript',</span>
<span class="e">            bar = function(path, bufnr)</span>
<span class="e">              if some_condition() then</span>
<span class="e">                return 'barscript', function(bufnr)</span>
<span class="e">                  -- Set a buffer variable</span>
<span class="e">                  vim.b[bufnr].barscript_version = 2</span>
<span class="e">                end</span>
<span class="e">              end</span>
<span class="e">              return 'bar'</span>
<span class="e">            end,</span>
<span class="e">          },</span>
<span class="e">          filename = {</span>
<span class="e">            ['.foorc'] = 'toml',</span>
<span class="e">            ['/etc/foo/config'] = 'toml',</span>
<span class="e">          },</span>
<span class="e">          pattern = {</span>
<span class="e">            ['.*/etc/foo/.*'] = 'fooscript',</span>
<span class="e">            -- Using an optional priority</span>
<span class="e">            ['.*/etc/foo/.*%.conf'] = { 'dosini', { priority = 10 } },</span>
<span class="e">            -- A pattern containing an environment variable</span>
<span class="e">            ['${XDG_CONFIG_HOME}/foo/git'] = 'git',</span>
<span class="e">            ['.*README.(%a+)'] = function(path, bufnr, ext)</span>
<span class="e">              if ext == 'md' then</span>
<span class="e">                return 'markdown'</span>
<span class="e">              elseif ext == 'rst' then</span>
<span class="e">                return 'rst'</span>
<span class="e">              end</span>
<span class="e">            end,</span>
<span class="e">          },</span>
<span class="e">        })</span>


    To add <a href="insert.txt.html#a" class="d">a</a> fallback match on contents, use 
<span class="e">        vim.filetype.add {</span>
<span class="e">          pattern = {</span>
<span class="e">            ['.*'] = {</span>
<span class="e">              function(path, bufnr)</span>
<span class="e">                local content = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)[1] or ''</span>
<span class="e">                if vim.regex([[^#!.*\\&lt;mine\\&gt;]]):match_str(content) ~= nil then</span>
<span class="e">                  return 'mine'</span>
<span class="e">                elseif vim.regex([[\\&lt;drawing\\&gt;]]):match_str(content) ~= nil then</span>
<span class="e">                  return 'drawing'</span>
<span class="e">                end</span>
<span class="e">              end,</span>
<span class="e">              { priority = -math.huge },</span>
<span class="e">            },</span>
<span class="e">          },</span>
<span class="e">        }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{filetypes}</span>  (`table`) <a href="insert.txt.html#A" class="d">A</a> table containing new <a href="filetype.txt.html#filetype" class="d">filetype</a> maps (see
                     example).
                     • <span class="s">{pattern}</span>? (`vim.filetype.mapping`)
                     • <span class="s">{extension}</span>? (`vim.filetype.mapping`)
                     • <span class="s">{filename}</span>? (`vim.filetype.mapping`)

                                                   <span id="vim.filetype.get_option%28%29" class="t">vim.filetype.get_option()</span>
vim.filetype.get_option({filetype}, <span class="s">{option}</span>)
    Get the default option value <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> <span class="s">{filetype}</span>.

    The returned value <a href="motion.txt.html#is" class="d">is</a> what would be set in <a href="insert.txt.html#a" class="d">a</a> new buffer after <a href="options.txt.html#%27filetype%27" class="o">'filetype'</a>
    <a href="motion.txt.html#is" class="d">is</a> set, meaning <a href="motion.txt.html#it" class="d">it</a> should respect all <a href="autocmd.txt.html#FileType" class="d">FileType</a> autocmds and <a href="usr_41.txt.html#ftplugin" class="d">ftplugin</a>
    files.

    Example: 
<span class="e">        vim.filetype.get_option('vim', 'commentstring')</span>


    <span class="n">Note:</span> this uses <a href="api.txt.html#nvim_get_option_value%28%29" class="l">nvim_get_option_value()</a> but caches the result. This
    means <a href="usr_41.txt.html#ftplugin" class="l">ftplugin</a> and <a href="autocmd.txt.html#FileType" class="l">FileType</a> autocommands are only triggered once and
    may not reflect later changes.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{filetype}</span>  (`string`) Filetype
      • <span class="s">{option}</span>    (`string`) Option name

<span class="h">    Return: </span>
        (`string<a href="options.txt.html#boolean" class="l">boolean</a>integer`) Option value

vim.filetype.match({args})                              <span id="vim.filetype.match%28%29" class="t">vim.filetype.match()</span>
    Perform <a href="filetype.txt.html#filetype" class="d">filetype</a> detection.

    The <a href="filetype.txt.html#filetype" class="d">filetype</a> can be detected using one of three methods:
    1. Using an existing buffer
    2. Using only <a href="insert.txt.html#a" class="d">a</a> file name
    3. Using only file contents

    Of these, option 1 provides the most accurate result <a href="motion.txt.html#as" class="d">as</a> <a href="motion.txt.html#it" class="d">it</a> uses both the
    buffer's filename and (optionally) the buffer contents. Options 2 and 3
    can be used without an existing buffer, but may not always provide <a href="insert.txt.html#a" class="d">a</a> match
    in cases where the filename (or contents) cannot unambiguously determine
    the filetype.

    Each of the three <a href="options.txt.html#options" class="d">options</a> <a href="motion.txt.html#is" class="d">is</a> specified using <a href="insert.txt.html#a" class="d">a</a> key to the single argument
    of this function. Example: 
<span class="e">        -- Using a buffer number</span>
<span class="e">        vim.filetype.match({ buf = 42 })</span>
<span class="e"></span>
<span class="e">        -- Override the filename of the given buffer</span>
<span class="e">        vim.filetype.match({ buf = 42, filename = 'foo.c' })</span>
<span class="e"></span>
<span class="e">        -- Using a filename without a buffer</span>
<span class="e">        vim.filetype.match({ filename = 'main.lua' })</span>
<span class="e"></span>
<span class="e">        -- Using file contents</span>
<span class="e">        vim.filetype.match({ contents = {'#!/usr/bin/env bash'} })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{args}</span>  (`table`) Table specifying which matching strategy to use.
                Accepted keys are:
                • <span class="s">{buf}</span>? (`integer`) Buffer number to use <a href="luaref.txt.html#for" class="d">for</a> matching.
                  Mutually <a href="motion.txt.html#exclusive" class="d">exclusive</a> with <span class="s">{contents}</span>
                • <span class="s">{filename}</span>? (`string`) Filename to use <a href="luaref.txt.html#for" class="d">for</a> matching. When
                  <span class="s">{buf}</span> <a href="motion.txt.html#is" class="d">is</a> given, <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to the filename of the given buffer
                  number. The file need not actually exist in the filesystem.
                  When used without <span class="s">{buf}</span> only the name of the file <a href="motion.txt.html#is" class="d">is</a> used
                  <a href="luaref.txt.html#for" class="d">for</a> <a href="filetype.txt.html#filetype" class="d">filetype</a> matching. This may result in failure to detect
                  the <a href="filetype.txt.html#filetype" class="d">filetype</a> in cases where the filename alone <a href="motion.txt.html#is" class="d">is</a> not enough
                  to disambiguate the filetype.
                • <span class="s">{contents}</span>? (`string[]`) An array of lines representing file
                  contents to use <a href="luaref.txt.html#for" class="d">for</a> matching. Can be used with <span class="s">{filename}</span>.
                  Mutually <a href="motion.txt.html#exclusive" class="d">exclusive</a> with <span class="s">{buf}</span>.

<span class="h">    Return (multiple): </span>
        (`string?`) If <a href="insert.txt.html#a" class="d">a</a> match was found, the matched filetype.
        (`function?`) <a href="insert.txt.html#A" class="d">A</a> function that modifies buffer state when called (for
        example, to set some <a href="filetype.txt.html#filetype" class="d">filetype</a> specific buffer variables). The function
        accepts <a href="insert.txt.html#a" class="d">a</a> buffer number <a href="motion.txt.html#as" class="d">as</a> its only argument.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.keymap" class="d">vim.keymap</a>                                            <span id="vim.keymap" class="t">vim.keymap</span>

vim.keymap.del({modes}, <a href="map.txt.html#%7Blhs%7D" class="s">{lhs}</a>, <span class="s">{opts}</span>)                      <span id="vim.keymap.del%28%29" class="t">vim.keymap.del()</span>
    Remove an existing mapping. Examples: 
<span class="e">        vim.keymap.del('n', 'lhs')</span>
<span class="e"></span>
<span class="e">        vim.keymap.del({'n', 'i', 'v'}, '&lt;leader&gt;w', { buffer = 5 })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{modes}</span>  (`string|string[]`)
      • <a href="map.txt.html#%7Blhs%7D" class="s">{lhs}</a>    (`string`)
      • <span class="s">{opts}</span>   (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                 • <span class="s">{buffer}</span>? (`integer|boolean`) Remove <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#mapping" class="d">mapping</a> from the
                   given buffer. When <span class="e">0</span> or <span class="e">true</span>, use the current buffer.

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.keymap.set%28%29" class="l">vim.keymap.set()</a>

vim.keymap.set({mode}, <a href="map.txt.html#%7Blhs%7D" class="s">{lhs}</a>, <a href="map.txt.html#%7Brhs%7D" class="s">{rhs}</a>, <span class="s">{opts}</span>)                <span id="vim.keymap.set%28%29" class="t">vim.keymap.set()</span>
    Defines <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#mapping" class="l">mapping</a> of <a href="intro.txt.html#keycodes" class="l">keycodes</a> to <a href="insert.txt.html#a" class="d">a</a> function or keycodes.

    Examples: 
<span class="e">        -- Map "x" to a Lua function:</span>
<span class="e">        vim.keymap.set('n', 'x', function() print("real lua function") end)</span>
<span class="e">        -- Map "&lt;leader&gt;x" to multiple modes for the current buffer:</span>
<span class="e">        vim.keymap.set({'n', 'v'}, '&lt;leader&gt;x', vim.lsp.buf.references, { buffer = true })</span>
<span class="e">        -- Map &lt;Tab&gt; to an expression (|:map-&lt;expr&gt;|):</span>
<span class="e">        vim.keymap.set('i', '&lt;Tab&gt;', function()</span>
<span class="e">          return vim.fn.pumvisible() == 1 and "&lt;C-n&gt;" or "&lt;Tab&gt;"</span>
<span class="e">        end, { expr = true })</span>
<span class="e">        -- Map "[%%" to a &lt;Plug&gt; mapping:</span>
<span class="e">        vim.keymap.set('n', '[%%', '&lt;Plug&gt;(MatchitNormalMultiBackward)')</span>


<span class="h">    Parameters: </span>
      • <span class="s">{mode}</span>  (`string|string[]`) Mode "short-name" (see
                <a href="api.txt.html#nvim_set_keymap%28%29" class="l">nvim_set_keymap()</a>), or <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> thereof.
      • <a href="map.txt.html#%7Blhs%7D" class="s">{lhs}</a>   (`string`) Left-hand side <a href="map.txt.html#%7Blhs%7D" class="l">{lhs}</a> of the mapping.
      • <a href="map.txt.html#%7Brhs%7D" class="s">{rhs}</a>   (`string|function`) Right-hand side <a href="map.txt.html#%7Brhs%7D" class="l">{rhs}</a> of the mapping,
                can be <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#Lua" class="d">Lua</a> function.
      • <span class="s">{opts}</span>  (`table?`) Table of <a href="map.txt.html#%3Amap-arguments" class="l">:map-arguments</a><a href="repeat.txt.html#." class="d">.</a> Same <a href="motion.txt.html#as" class="d">as</a>
                <a href="api.txt.html#nvim_set_keymap%28%29" class="l">nvim_set_keymap()</a> <span class="s">{opts}</span>, except:
                • <span class="s">{replace_keycodes}</span> <a href="vim_diff.txt.html#defaults" class="d">defaults</a> to <span class="e">true</span> if "<a href="vimeval.txt.html#expr" class="d">expr</a>" <a href="motion.txt.html#is" class="d">is</a> <span class="e">true</span>.

                Also accepts:
                • <span class="s">{buffer}</span>? (`integer|boolean`) Creates buffer-local mapping,
                  <span class="e">0</span> or <span class="e">true</span> <a href="luaref.txt.html#for" class="d">for</a> current buffer.
                • <span class="s">{remap}</span>? (`boolean`, default: <span class="e">false</span>) Make the <a href="map.txt.html#mapping" class="d">mapping</a>
                  recursive. Inverse of <span class="s">{noremap}</span>.

<span class="h">    See also: </span>
      • <a href="api.txt.html#nvim_set_keymap%28%29" class="l">nvim_set_keymap()</a>
      • <a href="vimfn.txt.html#maparg%28%29" class="l">maparg()</a>
      • <a href="vimfn.txt.html#mapcheck%28%29" class="l">mapcheck()</a>
      • <a href="vimfn.txt.html#mapset%28%29" class="l">mapset()</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.fs" class="d">vim.fs</a>                                                    <span id="vim.fs" class="t">vim.fs</span>


                                                             <span id="vim.fs.exists%28%29" class="t">vim.fs.exists()</span>
Use <a href="luvref.txt.html#uv.fs_stat%28%29" class="l">uv.fs_stat()</a> to check <a href="insert.txt.html#a" class="d">a</a> file's type, and whether <a href="motion.txt.html#it" class="d">it</a> exists.

Example: 
<span class="e">  if vim.uv.fs_stat(file) then</span>
<span class="e">    vim.print('file exists')</span>
<span class="e">  end</span>



vim.fs.abspath({path})                                      <span id="vim.fs.abspath%28%29" class="t">vim.fs.abspath()</span>
    Convert path to an absolute path. <a href="insert.txt.html#A" class="d">A</a> tilde (~) character <a href="motion.txt.html#at" class="d">at</a> the beginning
    of the path <a href="motion.txt.html#is" class="d">is</a> expanded to the user's <a href="intro.txt.html#home" class="d">home</a> directory. Does not check if
    the path exists, normalize the path, resolve symlinks or hardlinks
    (including <span class="e">.</span> and <span class="e">..</span>), or expand environment variables. If the path <a href="motion.txt.html#is" class="d">is</a>
    already absolute, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> returned unchanged. Also converts <span class="e">\</span> path
    separators to <span class="e">/</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path

<span class="h">    Return: </span>
        (`string`) Absolute path

vim.fs.basename({file})                                    <span id="vim.fs.basename%28%29" class="t">vim.fs.basename()</span>
    Return the basename of the given path

<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>  (`string?`) Path

<span class="h">    Return: </span>
        (`string?`) Basename of <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>

vim.fs.dir({path}, <span class="s">{opts}</span>)                                      <span id="vim.fs.dir%28%29" class="t">vim.fs.dir()</span>
    Return an <a href="lua.txt.html#iterator" class="d">iterator</a> over the items located in <span class="s">{path}</span>

<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) An absolute or relative path to the directory to
                iterate over. The path <a href="motion.txt.html#is" class="d">is</a> first normalized
                <a href="lua.txt.html#vim.fs.normalize%28%29" class="l">vim.fs.normalize()</a><a href="repeat.txt.html#." class="d">.</a>
      • <span class="s">{opts}</span>  (`table?`) Optional keyword arguments:
                • <span class="s">{depth}</span>? (`integer`, default: <span class="e">1</span>) How deep the traverse.
                • <span class="s">{skip}</span>? (`fun(dir_name: string): boolean`) Predicate to
                  <a href="intro.txt.html#control" class="d">control</a> traversal. Return false to stop searching the
                  current directory. Only useful when depth <a href="change.txt.html#%3E" class="d">&gt;</a> 1 Return an
                  <a href="lua.txt.html#iterator" class="d">iterator</a> over the items located in <span class="s">{path}</span>
                • <span class="s">{follow}</span>? (`boolean`, default: <span class="e">false</span>) Follow symbolic
                  links.

<span class="h">    Return: </span>
        (`Iterator`) over items in <span class="s">{path}</span>. Each iteration yields two values:
        "name" and "type"<a href="repeat.txt.html#." class="d">.</a> "name" <a href="motion.txt.html#is" class="d">is</a> the basename of the item relative to
        <span class="s">{path}</span>. "type" <a href="motion.txt.html#is" class="d">is</a> one of the following: "file"<a href="motion.txt.html#%2C" class="d">,</a> "directory"<a href="motion.txt.html#%2C" class="d">,</a> "link"<a href="motion.txt.html#%2C" class="d">,</a>
        "fifo"<a href="motion.txt.html#%2C" class="d">,</a> "socket"<a href="motion.txt.html#%2C" class="d">,</a> "char"<a href="motion.txt.html#%2C" class="d">,</a> "block"<a href="motion.txt.html#%2C" class="d">,</a> "unknown"<a href="repeat.txt.html#." class="d">.</a>

vim.fs.dirname({file})                                      <span id="vim.fs.dirname%28%29" class="t">vim.fs.dirname()</span>
    Gets the parent directory of the given path (not expanded/resolved, the
    caller must <a href="diff.txt.html#do" class="d">do</a> that).

<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>  (`string?`) Path

<span class="h">    Return: </span>
        (`string?`) Parent directory of <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>

vim.fs.find({names}, <span class="s">{opts}</span>)                                   <span id="vim.fs.find%28%29" class="t">vim.fs.find()</span>
    Find files or directories (or other items <a href="motion.txt.html#as" class="d">as</a> specified by <span class="e">opts.type</span>) in
    the given path.

    Finds items given in <span class="s">{names}</span> <a href="starting.txt.html#starting" class="d">starting</a> from <span class="s">{path}</span>. If <span class="s">{upward}</span> <a href="motion.txt.html#is" class="d">is</a> "true"
    then the search traverses upward through parent directories; otherwise,
    the search traverses downward. <span class="n">Note</span> that downward searches are recursive
    and may search through many directories! If <span class="s">{stop}</span> <a href="motion.txt.html#is" class="d">is</a> non-nil, then the
    search stops when the directory given in <span class="s">{stop}</span> <a href="motion.txt.html#is" class="d">is</a> reached. The search
    terminates when <span class="s">{limit}</span> (default 1) matches are found. You can set <span class="s">{type}</span>
    to "file"<a href="motion.txt.html#%2C" class="d">,</a> "directory"<a href="motion.txt.html#%2C" class="d">,</a> "link"<a href="motion.txt.html#%2C" class="d">,</a> "socket"<a href="motion.txt.html#%2C" class="d">,</a> "char"<a href="motion.txt.html#%2C" class="d">,</a> "block"<a href="motion.txt.html#%2C" class="d">,</a> or "fifo" to
    narrow the search to find only that type.

    Examples: 
<span class="e">        -- List all test directories under the runtime directory.</span>
<span class="e">        local dirs = vim.fs.find(</span>
<span class="e">          { 'test', 'tst', 'testdir' },</span>
<span class="e">          { limit = math.huge, type = 'directory', path = './runtime/' }</span>
<span class="e">        )</span>
<span class="e"></span>
<span class="e">        -- Get all "lib/*.cpp" and "lib/*.hpp" files, using Lua patterns.</span>
<span class="e">        -- Or use `vim.glob.to_lpeg(…):match(…)` for glob/wildcard matching.</span>
<span class="e">        local files = vim.fs.find(function(name, path)</span>
<span class="e">          return name:match('.*%.[ch]pp$') and path:match('[/\\]lib$')</span>
<span class="e">        end, { limit = math.huge, type = 'file' })</span>


<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <span class="s">{names}</span>  (`string<span class="l">string[]</span>fun(name: string, path: string): boolean`)
                 Names of the items to find. Must be base names, paths and
                 globs are not supported when <span class="s">{names}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> or <a href="insert.txt.html#a" class="d">a</a> table.
                 If <span class="s">{names}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> called <a href="luaref.txt.html#for" class="d">for</a> each traversed
                 item with args:
                 • name: base name of the current item
                 • path: full path of the current item

                 The function should return <span class="e">true</span> if the given item <a href="motion.txt.html#is" class="d">is</a>
                 considered <a href="insert.txt.html#a" class="d">a</a> match.
      • <span class="s">{opts}</span>   (`table?`) Optional keyword arguments:
                 • <span class="s">{path}</span>? (`string`) Path to begin searching from. If
                   omitted, the <a href="editing.txt.html#current-directory" class="l">current-directory</a> <a href="motion.txt.html#is" class="d">is</a> used.
                 • <span class="s">{upward}</span>? (`boolean`, default: <span class="e">false</span>) Search upward
                   through parent directories. Otherwise, search through child
                   directories (recursively).
                 • <span class="s">{stop}</span>? (`string`) Stop searching when this directory <a href="motion.txt.html#is" class="d">is</a>
                   reached. The directory itself <a href="motion.txt.html#is" class="d">is</a> not searched.
                 • <span class="s">{type}</span>? (`string`) Find only items of the given type. If
                   omitted, all items that match <span class="s">{names}</span> are included.
                 • <span class="s">{limit}</span>? (`number`, default: <span class="e">1</span>) Stop the search after
                   finding this many matches. Use <span class="e">math.huge</span> to place no
                   limit on the number of matches.
                 • <span class="s">{follow}</span>? (`boolean`, default: <span class="e">false</span>) Follow symbolic
                   links.

<span class="h">    Return: </span>
        (`string[]`) Normalized paths <a href="lua.txt.html#vim.fs.normalize%28%29" class="l">vim.fs.normalize()</a> of all matching
        items

vim.fs.joinpath({...})                                     <span id="vim.fs.joinpath%28%29" class="t">vim.fs.joinpath()</span>
    Concatenates <a href="vimfn.txt.html#partial" class="d">partial</a> paths (one absolute or relative path followed by zero
    or more relative paths). Slashes are normalized: redundant slashes are
    removed, and (on Windows) backslashes are replaced with forward-slashes.

    Examples:
    • "foo/"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="pattern.txt.html#%2Fbar" class="d">/bar</a>" =&gt; "foo/bar"
    • Windows: "a\foo\"<a href="motion.txt.html#%2C" class="d">,</a> "\bar" =&gt; "a/foo/bar"

<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{...}</span>  (`string`)

<span class="h">    Return: </span>
        (`string`)

vim.fs.normalize({path}, <span class="s">{opts}</span>)                          <span id="vim.fs.normalize%28%29" class="t">vim.fs.normalize()</span>
    Normalize <a href="insert.txt.html#a" class="d">a</a> path to <a href="insert.txt.html#a" class="d">a</a> standard format. <a href="insert.txt.html#A" class="d">A</a> tilde (~) character <a href="motion.txt.html#at" class="d">at</a> the
    beginning of the path <a href="motion.txt.html#is" class="d">is</a> expanded to the user's <a href="intro.txt.html#home" class="d">home</a> directory and
    environment <a href="vimeval.txt.html#variables" class="d">variables</a> are also expanded. "<a href="repeat.txt.html#." class="d">.</a>" and ".." components are also
    resolved, except when the path <a href="motion.txt.html#is" class="d">is</a> relative and trying to resolve <a href="motion.txt.html#it" class="d">it</a> would
    result in an absolute path.
    • "<a href="repeat.txt.html#." class="d">.</a>" <a href="motion.txt.html#as" class="d">as</a> the only part in <a href="insert.txt.html#a" class="d">a</a> relative path:
      • "<a href="repeat.txt.html#." class="d">.</a>" =&gt; "<a href="repeat.txt.html#." class="d">.</a>"
      • "././" =&gt; "<a href="repeat.txt.html#." class="d">.</a>"
    • ".." when <a href="motion.txt.html#it" class="d">it</a> leads outside the current directory
      • "foo/../../bar" =&gt; "../bar"
      • "../../foo" =&gt; "../../foo"
    • ".." in the root directory returns the root directory.
      • "/../../" =&gt; "<a href="pattern.txt.html#%2F" class="d">/</a>"

    On Windows, <a href="intro.txt.html#backslash" class="d">backslash</a> (\) characters are converted to forward slashes (/).

    Examples: 
<span class="e">        [[C:\Users\jdoe]]                         =&gt; "C:/Users/jdoe"</span>
<span class="e">        "~/src/neovim"                            =&gt; "/home/jdoe/src/neovim"</span>
<span class="e">        "$XDG_CONFIG_HOME/nvim/init.vim"          =&gt; "/Users/jdoe/.config/nvim/init.vim"</span>
<span class="e">        "~/src/nvim/api/../tui/./tui.c"           =&gt; "/home/jdoe/src/nvim/tui/tui.c"</span>
<span class="e">        "./foo/bar"                               =&gt; "foo/bar"</span>
<span class="e">        "foo/../../../bar"                        =&gt; "../../bar"</span>
<span class="e">        "/home/jdoe/../../../bar"                 =&gt; "/bar"</span>
<span class="e">        "C:foo/../../baz"                         =&gt; "C:../baz"</span>
<span class="e">        "C:/foo/../../baz"                        =&gt; "C:/baz"</span>
<span class="e">        [[\\?\UNC\server\share\foo\..\..\..\bar]] =&gt; "//?/UNC/server/share/bar"</span>


<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path to normalize
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{expand_env}</span>? (`boolean`, default: <span class="e">true</span>) Expand
                  environment variables.
                • <span class="s">{win}</span>? (`boolean`, default: <span class="e">true</span> in Windows, <span class="e">false</span>
                  otherwise) Path <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> Windows path.

<span class="h">    Return: </span>
        (`string`) Normalized path

vim.fs.parents({start})                                     <span id="vim.fs.parents%28%29" class="t">vim.fs.parents()</span>
    Iterate over all the parents of the given path (not expanded/resolved, the
    caller must <a href="diff.txt.html#do" class="d">do</a> that).

    Example: 
<span class="e">        local root_dir</span>
<span class="e">        for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do</span>
<span class="e">          if vim.fn.isdirectory(dir .. '/.git') == 1 then</span>
<span class="e">            root_dir = dir</span>
<span class="e">            break</span>
<span class="e">          end</span>
<span class="e">        end</span>
<span class="e"></span>
<span class="e">        if root_dir then</span>
<span class="e">          print('Found git repository at', root_dir)</span>
<span class="e">        end</span>


<span class="h">    Attributes: </span>
        Since: 0.8.0

<span class="h">    Parameters: </span>
      • <span class="s">{start}</span>  (`string`) Initial path.

<span class="h">    Return (multiple): </span>
        (`fun(_, dir: string): string?`) Iterator
        (`nil`)
        (`string?`)

vim.fs.relpath({base}, <span class="s">{target}</span>, <span class="s">{opts}</span>)                    <span id="vim.fs.relpath%28%29" class="t">vim.fs.relpath()</span>
    Gets <span class="e">target</span> path relative to <span class="e">base</span>, or <span class="e">nil</span> if <span class="e">base</span> <a href="motion.txt.html#is" class="d">is</a> not an
    ancestor.

    Example: 
<span class="e">        vim.fs.relpath('/var', '/var/lib') -- 'lib'</span>
<span class="e">        vim.fs.relpath('/var', '/usr/bin') -- nil</span>


<span class="h">    Parameters: </span>
      • <span class="s">{base}</span>    (`string`)
      • <span class="s">{target}</span>  (`string`)
      • <span class="s">{opts}</span>    (`table?`) Reserved <a href="luaref.txt.html#for" class="d">for</a> future use

<span class="h">    Return: </span>
        (`string?`)

vim.fs.rm({path}, <span class="s">{opts}</span>)                                        <span id="vim.fs.rm%28%29" class="t">vim.fs.rm()</span>
    Remove files or directories

<span class="h">    Attributes: </span>
        Since: 0.11.0

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path to remove
      • <span class="s">{opts}</span>  (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{recursive}</span>? (`boolean`) Remove directories and their
                  contents recursively
                • <span class="s">{force}</span>? (`boolean`) Ignore nonexistent files and arguments

vim.fs.root({source}, <span class="s">{marker}</span>)                                <span id="vim.fs.root%28%29" class="t">vim.fs.root()</span>
    Find the first parent directory containing <a href="insert.txt.html#a" class="d">a</a> specific "marker"<a href="motion.txt.html#%2C" class="d">,</a> relative
    to <a href="insert.txt.html#a" class="d">a</a> file path or buffer.

    If the buffer <a href="motion.txt.html#is" class="d">is</a> unnamed (has no backing file) or has <a href="insert.txt.html#a" class="d">a</a> non-empty
    <a href="options.txt.html#%27buftype%27" class="o">'buftype'</a> then the search begins from Nvim's <a href="editing.txt.html#current-directory" class="l">current-directory</a><a href="repeat.txt.html#." class="d">.</a>

    Examples: 
<span class="e">        -- Find the root of a Python project, starting from file 'main.py'</span>
<span class="e">        vim.fs.root(vim.fs.joinpath(vim.env.PWD, 'main.py'), {'pyproject.toml', 'setup.py' })</span>
<span class="e"></span>
<span class="e">        -- Find the root of a git repository</span>
<span class="e">        vim.fs.root(0, '.git')</span>
<span class="e"></span>
<span class="e">        -- Find the parent directory containing any file with a .csproj extension</span>
<span class="e">        vim.fs.root(0, function(name, path)</span>
<span class="e">          return name:match('%.csproj$') ~= nil</span>
<span class="e">        end)</span>
<span class="e"></span>
<span class="e">        -- Find the first ancestor directory containing EITHER "stylua.toml" or ".luarc.json"; if</span>
<span class="e">        -- not found, find the first ancestor containing ".git":</span>
<span class="e">        vim.fs.root(0, { { 'stylua.toml', '.luarc.json' }, '.git' })</span>


<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{source}</span>  (`integer|string`) Buffer number (0 <a href="luaref.txt.html#for" class="d">for</a> current buffer) or
                  file path (absolute or relative to the <a href="editing.txt.html#current-directory" class="l">current-directory</a><a href="motion.txt.html#%29" class="d">)</a>
                  to begin the search from.
      • <span class="s">{marker}</span>  (`(string<span class="l">string[]</span>fun(name: string, path: string): boolean)[]<a href="vimeval.txt.html#string" class="l">string</a>fun(name: string, path: string): boolean`)
                  Filename, function, or <a href="vimeval.txt.html#list" class="d">list</a> thereof, that decides how to
                  find the root. To indicate "equal priority"<a href="motion.txt.html#%2C" class="d">,</a> specify items
                  in <a href="insert.txt.html#a" class="d">a</a> nested <a href="vimeval.txt.html#list" class="d">list</a> <a href="motion.txt.html#%60%7B" class="d">`{</a> <span class="s">{ 'a.txt', 'b.lua' }</span>, … }`. <a href="insert.txt.html#A" class="d">A</a> function
                  item must return true if <span class="e">name</span> and <span class="e">path</span> are <a href="insert.txt.html#a" class="d">a</a> match. Each
                  item (which may itself be <a href="insert.txt.html#a" class="d">a</a> nested list) <a href="motion.txt.html#is" class="d">is</a> evaluated
                  in-order against all ancestors, until <a href="insert.txt.html#a" class="d">a</a> match <a href="motion.txt.html#is" class="d">is</a> found.

<span class="h">    Return: </span>
        (`string?`) Directory path containing one of the given markers, or nil
        if no directory was found.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.glob" class="d">vim.glob</a>                                                <span id="vim.glob" class="t">vim.glob</span>

vim.glob.to_lpeg({pattern})                               <span id="vim.glob.to_lpeg%28%29" class="t">vim.glob.to_lpeg()</span>
    Parses <a href="insert.txt.html#a" class="d">a</a> raw glob into an <a href="lua.txt.html#lua-lpeg" class="l">lua-lpeg</a> pattern.

    This uses glob semantics from <a href="lsp.txt.html#LSP" class="d">LSP</a> 3.17.0:
    <a class="u" href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern">https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern</a>

    Glob patterns can have the following syntax:
    • <span class="e">*</span> to match one or more characters in <a href="insert.txt.html#a" class="d">a</a> path segment
    • <span class="e">?</span> to match on one character in <a href="insert.txt.html#a" class="d">a</a> path segment
    • <span class="e">**</span> to match any number of path segments, including none
    • <span class="e">{}</span> to group conditions (e.g. <span class="e">*.{ts,js}</span> matches TypeScript and
      JavaScript files)
    • <span class="e">[]</span> to declare <a href="insert.txt.html#a" class="d">a</a> range of characters to match in <a href="insert.txt.html#a" class="d">a</a> path segment (e.g.,
      <span class="e">example.[0-9]</span> to match on <span class="e">example.0</span>, <span class="e">example.1</span>, …<a href="motion.txt.html#%29" class="d">)</a>
    • <span class="e">[!...]</span> to negate <a href="insert.txt.html#a" class="d">a</a> range of characters to match in <a href="insert.txt.html#a" class="d">a</a> path segment
      (e.g., <span class="e">example.[!0-9]</span> to match on <span class="e">example.a</span>, <span class="e">example.b</span>, but not
      <span class="e">example.0</span>)

<span class="h">    Parameters: </span>
      • <span class="s">{pattern}</span>  (`string`) The raw glob <a href="pattern.txt.html#pattern" class="d">pattern</a>

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`) <a href="pattern.txt.html#pattern" class="d">pattern</a> An <a href="lua.txt.html#lua-lpeg" class="l">lua-lpeg</a> representation of the
        <a href="pattern.txt.html#pattern" class="d">pattern</a>


<span class="h">==============================================================================</span>
<span class="c">VIM.LPEG</span>                                                            <span id="vim.lpeg" class="t">vim.lpeg</span>


LPeg <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> pattern-matching library <a href="luaref.txt.html#for" class="d">for</a> Lua, based on Parsing Expression
Grammars (PEGs). <a class="u" href="https://bford.info/packrat/">https://bford.info/packrat/</a>

                                                   <span id="lua-lpeg" class="t">lua-lpeg</span> <span id="vim.lpeg.Pattern" class="t">vim.lpeg.Pattern</span>
The LPeg library <a href="luaref.txt.html#for" class="d">for</a> parsing <a href="vimeval.txt.html#expression" class="d">expression</a> grammars <a href="motion.txt.html#is" class="d">is</a> included <a href="motion.txt.html#as" class="d">as</a> <span class="e">vim.lpeg</span>
(https://www.inf.puc-rio.br/~roberto/lpeg/).

In addition, its regex-like interface <a href="motion.txt.html#is" class="d">is</a> available <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#vim.re" class="l">vim.re</a>
(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).



Pattern:match({subject}, <span class="s">{init}</span>, <span class="s">{...}</span>)                      <span id="Pattern%3Amatch%28%29" class="t">Pattern:match()</span>
    Matches the given <span class="e">pattern</span> against the <span class="e">subject</span> string. If the match
    succeeds, returns the <a href="index.txt.html#index" class="d">index</a> in the subject of the first character after
    the match, or the captured values (if the <a href="pattern.txt.html#pattern" class="d">pattern</a> captured any value). An
    optional numeric argument <span class="e">init</span> makes the match start <a href="motion.txt.html#at" class="d">at</a> that position in
    the subject string. As usual in <a href="lua.txt.html#Lua" class="d">Lua</a> libraries, <a href="insert.txt.html#a" class="d">a</a> negative value counts
    from the end. Unlike typical pattern-matching functions, <span class="e">match</span> works
    only in anchored mode; that is, <a href="motion.txt.html#it" class="d">it</a> tries to match the <a href="pattern.txt.html#pattern" class="d">pattern</a> with <a href="insert.txt.html#a" class="d">a</a>
    prefix of the given subject <a href="vimeval.txt.html#string" class="d">string</a> (at position <span class="e">init</span>), not with an
    arbitrary <a href="vimeval.txt.html#substring" class="d">substring</a> of the subject. So, if we want to find <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a>
    anywhere in <a href="insert.txt.html#a" class="d">a</a> string, we must either write <a href="insert.txt.html#a" class="d">a</a> loop in <a href="lua.txt.html#Lua" class="d">Lua</a> or write <a href="insert.txt.html#a" class="d">a</a>
    <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches anywhere.

    Example: 
<span class="e">        local pattern = lpeg.R('az') ^ 1 * -1</span>
<span class="e">        assert(pattern:match('hello') == 6)</span>
<span class="e">        assert(lpeg.match(pattern, 'hello') == 6)</span>
<span class="e">        assert(pattern:match('1 hello') == nil)</span>


<span class="h">    Parameters: </span>
      • <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>  (`string`)
      • <span class="s">{init}</span>     (`integer?`)
      • <span class="s">{...}</span>      (`any`)

<span class="h">    Return: </span>
        (`any`) <a href="userfunc.txt.html#..." class="d">...</a>

vim.lpeg.B({pattern})                                           <span id="vim.lpeg.B%28%29" class="t">vim.lpeg.B()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches only if the input <a href="vimeval.txt.html#string" class="d">string</a> <a href="motion.txt.html#at" class="d">at</a> the current
    position <a href="motion.txt.html#is" class="d">is</a> preceded by <span class="e">patt</span>. <a href="pattern.txt.html#Pattern" class="d">Pattern</a> <span class="e">patt</span> must match only strings
    with some fixed length, and <a href="motion.txt.html#it" class="d">it</a> cannot contain captures. Like the <span class="e">and</span>
    predicate, this <a href="pattern.txt.html#pattern" class="d">pattern</a> never consumes any input, independently of success
    or failure.

<span class="h">    Parameters: </span>
      • <span class="s">{pattern}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

vim.lpeg.C({patt})                                              <span id="vim.lpeg.C%28%29" class="t">vim.lpeg.C()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> simple capture, which captures the <a href="vimeval.txt.html#substring" class="d">substring</a> of the subject that
    matches <span class="e">patt</span>. The captured value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> string. If <span class="e">patt</span> has other
    captures, their values are returned after this one.

    Example: 
<span class="e">        local function split (s, sep)</span>
<span class="e">          sep = lpeg.P(sep)</span>
<span class="e">          local elem = lpeg.C((1 - sep) ^ 0)</span>
<span class="e">          local p = elem * (sep * elem) ^ 0</span>
<span class="e">          return lpeg.match(p, s)</span>
<span class="e">        end</span>
<span class="e">        local a, b, c = split('a,b,c', ',')</span>
<span class="e">        assert(a == 'a')</span>
<span class="e">        assert(b == 'b')</span>
<span class="e">        assert(c == 'c')</span>


<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Carg({n})                                           <span id="vim.lpeg.Carg%28%29" class="t">vim.lpeg.Carg()</span>
    Creates an argument capture. This <a href="pattern.txt.html#pattern" class="d">pattern</a> matches the empty <a href="vimeval.txt.html#string" class="d">string</a> and
    produces the value given <a href="motion.txt.html#as" class="d">as</a> the nth extra argument given in the call to
    <span class="e">lpeg.match</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{n}</span>  (`integer`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cb({name})                                            <span id="vim.lpeg.Cb%28%29" class="t">vim.lpeg.Cb()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> back capture. This <a href="pattern.txt.html#pattern" class="d">pattern</a> matches the empty <a href="vimeval.txt.html#string" class="d">string</a> and produces
    the values produced by the most recent group capture named <span class="e">name</span> (where
    <span class="e">name</span> can be any <a href="lua.txt.html#Lua" class="d">Lua</a> value). Most recent means the last complete
    outermost group capture with the given name. <a href="insert.txt.html#A" class="d">A</a> Complete capture means that
    the entire <a href="pattern.txt.html#pattern" class="d">pattern</a> corresponding to the capture has matched. An Outermost
    capture means that the capture <a href="motion.txt.html#is" class="d">is</a> not inside another complete capture. In
    the same way that LPeg does not specify when <a href="motion.txt.html#it" class="d">it</a> evaluates captures, <a href="motion.txt.html#it" class="d">it</a>
    does not specify whether <a href="motion.txt.html#it" class="d">it</a> reuses values previously produced by the group
    or re-evaluates them.

<span class="h">    Parameters: </span>
      • <span class="s">{name}</span>  (`any`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cc({...})                                             <span id="vim.lpeg.Cc%28%29" class="t">vim.lpeg.Cc()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> constant capture. This <a href="pattern.txt.html#pattern" class="d">pattern</a> matches the empty <a href="vimeval.txt.html#string" class="d">string</a> and
    produces all given values <a href="motion.txt.html#as" class="d">as</a> its captured values.

<span class="h">    Parameters: </span>
      • <span class="s">{...}</span>  (`any`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cf({patt}, <span class="s">{func}</span>)                                    <span id="vim.lpeg.Cf%28%29" class="t">vim.lpeg.Cf()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> fold capture. If <span class="e">patt</span> produces <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of captures C1 C2 <a href="userfunc.txt.html#..." class="d">...</a>
    Cn, this capture will produce the value
    `func(...func(func(C1, C2), C3)...,Cn)`, that is, <a href="motion.txt.html#it" class="d">it</a> will fold (or
    accumulate, or reduce) the captures from <span class="e">patt</span> using function <span class="e">func</span>.
    This capture assumes that <span class="e">patt</span> should produce <a href="motion.txt.html#at" class="d">at</a> least one capture with
    <a href="motion.txt.html#at" class="d">at</a> least one value (of any type), which becomes the initial value of an
    accumulator. (If you need <a href="insert.txt.html#a" class="d">a</a> specific initial value, you may prefix <a href="insert.txt.html#a" class="d">a</a>
    constant capture to <span class="e">patt</span>.) For each subsequent capture, LPeg calls
    <span class="e">func</span> with this accumulator <a href="motion.txt.html#as" class="d">as</a> the first argument and all values produced
    by the capture <a href="motion.txt.html#as" class="d">as</a> extra arguments; the first result from this call becomes
    the new value <a href="luaref.txt.html#for" class="d">for</a> the accumulator. The final value of the accumulator
    becomes the captured value.

    Example: 
<span class="e">        local number = lpeg.R('09') ^ 1 / tonumber</span>
<span class="e">        local list = number * (',' * number) ^ 0</span>
<span class="e">        local function add(acc, newvalue) return acc + newvalue end</span>
<span class="e">        local sum = lpeg.Cf(list, add)</span>
<span class="e">        assert(sum:match('10,30,43') == 83)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)
      • <span class="s">{func}</span>  (`fun(acc, newvalue)`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cg({patt}, <span class="s">{name}</span>)                                    <span id="vim.lpeg.Cg%28%29" class="t">vim.lpeg.Cg()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> group capture. It groups all values returned by <span class="e">patt</span> into <a href="insert.txt.html#a" class="d">a</a>
    single capture. The group may be anonymous (if no name <a href="motion.txt.html#is" class="d">is</a> given) or named
    with the given name (which can be any non-nil <a href="lua.txt.html#Lua" class="d">Lua</a> value).

<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)
      • <span class="s">{name}</span>  (`string?`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cmt({patt}, <span class="s">{fn}</span>)                                    <span id="vim.lpeg.Cmt%28%29" class="t">vim.lpeg.Cmt()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> match-time capture. Unlike all other captures, this one <a href="motion.txt.html#is" class="d">is</a>
    evaluated immediately when <a href="insert.txt.html#a" class="d">a</a> match occurs (even if <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> part of <a href="insert.txt.html#a" class="d">a</a> larger
    <a href="pattern.txt.html#pattern" class="d">pattern</a> that fails later). It forces the immediate evaluation of all its
    nested captures and then calls <span class="e">function</span>. The given function gets <a href="motion.txt.html#as" class="d">as</a>
    arguments the entire subject, the current position (after the match of
    <span class="e">patt</span>), plus any capture values produced by <span class="e">patt</span>. The first value
    returned by <span class="e">function</span> defines how the match happens. If the call returns
    <a href="insert.txt.html#a" class="d">a</a> number, the match succeeds and the returned number becomes the new
    current position. (Assuming <a href="insert.txt.html#a" class="d">a</a> subject sand current position <span class="e">i</span>, the
    returned number must be in the range `[i, len(s) <a href="motion.txt.html#%2B" class="d">+</a> 1]`.) If the call
    returns <span class="e">true</span>, the match succeeds without consuming any input (so, to
    return true <a href="motion.txt.html#is" class="d">is</a> equivalent to return <span class="e">i</span>). If the call returns <span class="e">false</span>,
    <span class="e">nil</span>, or no value, the match fails. Any extra values returned by the
    function become the values produced by the capture.

<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)
      • <span class="s">{fn}</span>    (`fun(s: string, i: integer, ...: any)`) (position:
                <a href="options.txt.html#boolean" class="d">boolean</a>|integer, ...: any)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

<a href="lua.txt.html#vim.lpeg.Cp%28%29" class="d">vim.lpeg.Cp()</a>                                                  <span id="vim.lpeg.Cp%28%29" class="t">vim.lpeg.Cp()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> position capture. It matches the empty <a href="vimeval.txt.html#string" class="d">string</a> and captures the
    position in the subject where the match occurs. The captured value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a>
    number.

    Example: 
<span class="e">        local I = lpeg.Cp()</span>
<span class="e">        local function anywhere(p) return lpeg.P({I * p * I + 1 * lpeg.V(1)}) end</span>
<span class="e">        local match_start, match_end = anywhere('world'):match('hello world!')</span>
<span class="e">        assert(match_start == 7)</span>
<span class="e">        assert(match_end == 12)</span>


<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Cs({patt})                                            <span id="vim.lpeg.Cs%28%29" class="t">vim.lpeg.Cs()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> substitution capture. This function creates <a href="insert.txt.html#a" class="d">a</a> substitution
    capture, which captures the <a href="vimeval.txt.html#substring" class="d">substring</a> of the subject that matches <span class="e">patt</span>,
    with substitutions. For any capture inside <span class="e">patt</span> with <a href="insert.txt.html#a" class="d">a</a> value, the
    <a href="vimeval.txt.html#substring" class="d">substring</a> that matched the capture <a href="motion.txt.html#is" class="d">is</a> replaced by the capture value (which
    should be <a href="insert.txt.html#a" class="d">a</a> string). The final captured value <a href="motion.txt.html#is" class="d">is</a> the <a href="vimeval.txt.html#string" class="d">string</a> resulting from
    all replacements.

    Example: 
<span class="e">        local function gsub (s, patt, repl)</span>
<span class="e">          patt = lpeg.P(patt)</span>
<span class="e">          patt = lpeg.Cs((patt / repl + 1) ^ 0)</span>
<span class="e">          return lpeg.match(patt, s)</span>
<span class="e">        end</span>
<span class="e">        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')</span>


<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.Ct({patt})                                            <span id="vim.lpeg.Ct%28%29" class="t">vim.lpeg.Ct()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> table capture. This capture returns <a href="insert.txt.html#a" class="d">a</a> table with all values from
    all anonymous captures made by <span class="e">patt</span> inside this table in successive
    integer keys, <a href="starting.txt.html#starting" class="d">starting</a> <a href="motion.txt.html#at" class="d">at</a> 1. Moreover, <a href="luaref.txt.html#for" class="d">for</a> each named capture group
    created by <span class="e">patt</span>, the first value of the group <a href="motion.txt.html#is" class="d">is</a> <a href="change.txt.html#put" class="d">put</a> into the table with
    the group name <a href="motion.txt.html#as" class="d">as</a> its key. The captured value <a href="motion.txt.html#is" class="d">is</a> only the table.

<span class="h">    Parameters: </span>
      • <span class="s">{patt}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)

<span class="h">    Return: </span>
        (`vim.lpeg.Capture`)

vim.lpeg.locale({tab})                                     <span id="vim.lpeg.locale%28%29" class="t">vim.lpeg.locale()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> table with patterns <a href="luaref.txt.html#for" class="d">for</a> matching some character classes
    according to the current locale. The table has fields named <span class="e">alnum</span>,
    <span class="e">alpha</span>, <span class="e">cntrl</span>, <span class="e">digit</span>, <span class="e">graph</span>, <span class="e">lower</span>, <span class="e">print</span>, <span class="e">punct</span>, <span class="e">space</span>,
    <span class="e">upper</span>, and <span class="e">xdigit</span>, each one containing <a href="insert.txt.html#a" class="d">a</a> correspondent pattern. Each
    <a href="pattern.txt.html#pattern" class="d">pattern</a> matches any single character that belongs to its class. If called
    with an argument <span class="e">table</span>, then <a href="motion.txt.html#it" class="d">it</a> creates those fields inside the given
    table and returns that table.

    Example: 
<span class="e">        lpeg.locale(lpeg)</span>
<span class="e">        local space = lpeg.space ^ 0</span>
<span class="e">        local name = lpeg.C(lpeg.alpha ^ 1) * space</span>
<span class="e">        local sep = lpeg.S(',;') * space</span>
<span class="e">        local pair = lpeg.Cg(name * '=' * space * name) * sep ^ -1</span>
<span class="e">        local list = lpeg.Cf(lpeg.Ct('') * pair ^ 0, rawset)</span>
<span class="e">        local t = list:match('a=b, c = hi; next = pi')</span>
<span class="e">        assert(t.a == 'b')</span>
<span class="e">        assert(t.c == 'hi')</span>
<span class="e">        assert(t.next == 'pi')</span>
<span class="e">        local locale = lpeg.locale()</span>
<span class="e">        assert(type(locale.digit) == 'userdata')</span>


<span class="h">    Parameters: </span>
      • <span class="s">{tab}</span>  (`table?`)

<span class="h">    Return: </span>
        (`vim.lpeg.Locale`)

vim.lpeg.match({pattern}, <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>, <span class="s">{init}</span>, <span class="s">{...}</span>)         <span id="vim.lpeg.match%28%29" class="t">vim.lpeg.match()</span>
    Matches the given <span class="e">pattern</span> against the <span class="e">subject</span> string. If the match
    succeeds, returns the <a href="index.txt.html#index" class="d">index</a> in the subject of the first character after
    the match, or the captured values (if the <a href="pattern.txt.html#pattern" class="d">pattern</a> captured any value). An
    optional numeric argument <span class="e">init</span> makes the match start <a href="motion.txt.html#at" class="d">at</a> that position in
    the subject string. As usual in <a href="lua.txt.html#Lua" class="d">Lua</a> libraries, <a href="insert.txt.html#a" class="d">a</a> negative value counts
    from the end. Unlike typical pattern-matching functions, <span class="e">match</span> works
    only in anchored mode; that is, <a href="motion.txt.html#it" class="d">it</a> tries to match the <a href="pattern.txt.html#pattern" class="d">pattern</a> with <a href="insert.txt.html#a" class="d">a</a>
    prefix of the given subject <a href="vimeval.txt.html#string" class="d">string</a> (at position <span class="e">init</span>), not with an
    arbitrary <a href="vimeval.txt.html#substring" class="d">substring</a> of the subject. So, if we want to find <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a>
    anywhere in <a href="insert.txt.html#a" class="d">a</a> string, we must either write <a href="insert.txt.html#a" class="d">a</a> loop in <a href="lua.txt.html#Lua" class="d">Lua</a> or write <a href="insert.txt.html#a" class="d">a</a>
    <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches anywhere.

    Example: 
<span class="e">        local pattern = lpeg.R('az') ^ 1 * -1</span>
<span class="e">        assert(pattern:match('hello') == 6)</span>
<span class="e">        assert(lpeg.match(pattern, 'hello') == 6)</span>
<span class="e">        assert(pattern:match('1 hello') == nil)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{pattern}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)
      • <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>  (`string`)
      • <span class="s">{init}</span>     (`integer?`)
      • <span class="s">{...}</span>      (`any`)

<span class="h">    Return: </span>
        (`any`) <a href="userfunc.txt.html#..." class="d">...</a>

vim.lpeg.P({value})                                             <span id="vim.lpeg.P%28%29" class="t">vim.lpeg.P()</span>
    Converts the given value into <a href="insert.txt.html#a" class="d">a</a> proper pattern. The following rules are
    applied:
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> pattern, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> returned unmodified.
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> string, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> translated to <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches
      the <a href="vimeval.txt.html#string" class="d">string</a> literally.
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> non-negative number <span class="e">n</span>, the result <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a>
      that matches exactly <span class="e">n</span> characters.
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> negative number <span class="e">-n</span>, the result <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that
      succeeds only if the input <a href="vimeval.txt.html#string" class="d">string</a> has <a href="various.txt.html#less" class="d">less</a> than <span class="e">n</span> characters left:
      <span class="e">lpeg.P(-n)</span> <a href="motion.txt.html#is" class="d">is</a> equivalent to <span class="e">-lpeg.P(n)</span> (see the unary minus
      operation).
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> boolean, the result <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that always
      succeeds or always fails (according to the <a href="options.txt.html#boolean" class="d">boolean</a> value), without
      consuming any input.
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> table, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> interpreted <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> grammar (see
      Grammars).
    • If the argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function, returns <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> equivalent to <a href="insert.txt.html#a" class="d">a</a>
      match-time capture over the empty string.

<span class="h">    Parameters: </span>
      • <span class="s">{value}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

vim.lpeg.R({...})                                               <span id="vim.lpeg.R%28%29" class="t">vim.lpeg.R()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches any single character belonging to one of
    the given ranges. Each <span class="e">range</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> <span class="e">xy</span> of length 2, representing
    all characters with code between the codes of <span class="e">x</span> and <span class="e">y</span> (both
    inclusive). As an example, the <a href="pattern.txt.html#pattern" class="d">pattern</a> <span class="e">lpeg.R('09')</span> matches any digit,
    and `lpeg.R('az', 'AZ')` matches any ASCII letter.

    Example: 
<span class="e">        local pattern = lpeg.R('az') ^ 1 * -1</span>
<span class="e">        assert(pattern:match('hello') == 6)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{...}</span>  (`string`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

vim.lpeg.S({string})                                            <span id="vim.lpeg.S%28%29" class="t">vim.lpeg.S()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> <a href="pattern.txt.html#pattern" class="d">pattern</a> that matches any single character that appears in the
    given <a href="vimeval.txt.html#string" class="d">string</a> (the <span class="e">S</span> stands <a href="luaref.txt.html#for" class="d">for</a> Set). As an example, the <a href="pattern.txt.html#pattern" class="d">pattern</a>
    <span class="e">lpeg.S('+-*/')</span> matches any arithmetic operator. <span class="n">Note</span> that, if <span class="e">s</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a>
    character (that is, <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> of length 1), then <span class="e">lpeg.P(s)</span> <a href="motion.txt.html#is" class="d">is</a> equivalent
    to <span class="e">lpeg.S(s)</span> which <a href="motion.txt.html#is" class="d">is</a> equivalent to <span class="e">lpeg.R(s..s)</span>. <span class="n">Note</span> also that both
    <span class="e">lpeg.S('')</span> and <span class="e">lpeg.R()</span> are patterns that always fail.

<span class="h">    Parameters: </span>
      • <span class="s">{string}</span>  (`string`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

vim.lpeg.setmaxstack({max})                           <span id="vim.lpeg.setmaxstack%28%29" class="t">vim.lpeg.setmaxstack()</span>
    Sets <a href="insert.txt.html#a" class="d">a</a> limit <a href="luaref.txt.html#for" class="d">for</a> the size of the backtrack stack used by LPeg to track
    calls and choices. The default limit <a href="motion.txt.html#is" class="d">is</a> <span class="e">400</span>. Most well-written patterns
    need little backtrack levels and therefore you seldom need to change this
    limit; before <a href="change.txt.html#changing" class="d">changing</a> <a href="motion.txt.html#it" class="d">it</a> you should try to rewrite your <a href="pattern.txt.html#pattern" class="d">pattern</a> to avoid
    the need <a href="luaref.txt.html#for" class="d">for</a> extra space. Nevertheless, <a href="insert.txt.html#a" class="d">a</a> few useful patterns may
    overflow. Also, with recursive grammars, subjects with deep recursion may
    also need larger limits.

<span class="h">    Parameters: </span>
      • <span class="s">{max}</span>  (`integer`)

vim.lpeg.type({value})                                       <span id="vim.lpeg.type%28%29" class="t">vim.lpeg.type()</span>
    Returns the <a href="vimeval.txt.html#string" class="d">string</a> <span class="e">"pattern"</span> if the given value <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> pattern, otherwise
    <span class="e">nil</span>.

<span class="h">    Parameters: </span>
      • <span class="s">{value}</span>  (`vim.lpeg.Pattern<a href="vimeval.txt.html#string" class="l">string</a>integer<a href="options.txt.html#boolean" class="l">boolean</a>table|function`)

<span class="h">    Return: </span>
        (`"<a href="pattern.txt.html#pattern" class="d">pattern</a>"?`)

vim.lpeg.V({v})                                                 <span id="vim.lpeg.V%28%29" class="t">vim.lpeg.V()</span>
    Creates <a href="insert.txt.html#a" class="d">a</a> non-terminal (a variable) <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> grammar. This operation creates
    <a href="insert.txt.html#a" class="d">a</a> non-terminal (a variable) <a href="luaref.txt.html#for" class="d">for</a> <a href="insert.txt.html#a" class="d">a</a> grammar. The created non-terminal refers
    to the rule indexed by <span class="e">v</span> in the enclosing grammar.

    Example: 
<span class="e">        local b = lpeg.P({'(' * ((1 - lpeg.S '()') + lpeg.V(1)) ^ 0 * ')'})</span>
<span class="e">        assert(b:match('((string))') == 11)</span>
<span class="e">        assert(b:match('(') == nil)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{v}</span>  (`boolean<a href="vimeval.txt.html#string" class="l">string</a>number<span class="l">function</span>table<span class="l">thread</span><a href="luaref.txt.html#userdata" class="d">userdata</a>|lightuserdata`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

<a href="lua.txt.html#vim.lpeg.version%28%29" class="d">vim.lpeg.version()</a>                                        <span id="vim.lpeg.version%28%29" class="t">vim.lpeg.version()</span>
    Returns <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> with the running version of LPeg.

<span class="h">    Return: </span>
        (`string`)


<span class="h">==============================================================================</span>
<span class="c">VIM.RE</span>                                                                <span id="vim.re" class="t">vim.re</span>

The <span class="e">vim.re</span> module provides <a href="insert.txt.html#a" class="d">a</a> conventional regex-like <a href="syntax.txt.html#syntax" class="d">syntax</a> <a href="luaref.txt.html#for" class="d">for</a> <a href="pattern.txt.html#pattern" class="d">pattern</a>
usage within LPeg <a href="lua.txt.html#vim.lpeg" class="l">vim.lpeg</a><a href="repeat.txt.html#." class="d">.</a> (Unrelated to <a href="lua.txt.html#vim.regex" class="l">vim.regex</a> which provides Vim
<a href="pattern.txt.html#regexp" class="l">regexp</a> from Lua.)

See <a class="u" href="https://www.inf.puc-rio.br/~roberto/lpeg/re.html">https://www.inf.puc-rio.br/~roberto/lpeg/re.html</a> <a href="luaref.txt.html#for" class="d">for</a> the original
documentation including regex <a href="syntax.txt.html#syntax" class="d">syntax</a> and examples.


vim.re.compile({string}, <span class="s">{defs}</span>)                            <span id="vim.re.compile%28%29" class="t">vim.re.compile()</span>
    Compiles the given <span class="s">{string}</span> and returns an equivalent LPeg pattern. The
    given <a href="vimeval.txt.html#string" class="d">string</a> may define either an <a href="vimeval.txt.html#expression" class="d">expression</a> or <a href="insert.txt.html#a" class="d">a</a> grammar. The optional
    <span class="s">{defs}</span> table provides extra <a href="lua.txt.html#Lua" class="d">Lua</a> values to be used by the pattern.

<span class="h">    Parameters: </span>
      • <span class="s">{string}</span>  (`string`)
      • <span class="s">{defs}</span>    (`table?`)

<span class="h">    Return: </span>
        (`vim.lpeg.Pattern`)

vim.re.find({subject}, <span class="s">{pattern}</span>, <span class="s">{init}</span>)                      <span id="vim.re.find%28%29" class="t">vim.re.find()</span>
    Searches the given <span class="s">{pattern}</span> in the given <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>. If <a href="motion.txt.html#it" class="d">it</a> finds <a href="insert.txt.html#a" class="d">a</a> match,
    returns the <a href="index.txt.html#index" class="d">index</a> where this occurrence starts and the <a href="index.txt.html#index" class="d">index</a> where <a href="motion.txt.html#it" class="d">it</a>
    ends. Otherwise, returns nil.

    An optional numeric argument <span class="s">{init}</span> makes the search starts <a href="motion.txt.html#at" class="d">at</a> that
    position in the subject string. As usual in <a href="lua.txt.html#Lua" class="d">Lua</a> libraries, <a href="insert.txt.html#a" class="d">a</a> negative
    value counts from the end.

<span class="h">    Parameters: </span>
      • <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>  (`string`)
      • <span class="s">{pattern}</span>  (`vim.lpeg.Pattern|string`)
      • <span class="s">{init}</span>     (`integer?`)

<span class="h">    Return (multiple): </span>
        (`integer?`) the <a href="index.txt.html#index" class="d">index</a> where the occurrence starts, nil if no match
        (`integer?`) the <a href="index.txt.html#index" class="d">index</a> where the occurrence ends, nil if no match

vim.re.gsub({subject}, <span class="s">{pattern}</span>, <span class="s">{replacement}</span>)               <span id="vim.re.gsub%28%29" class="t">vim.re.gsub()</span>
    Does <a href="insert.txt.html#a" class="d">a</a> global substitution, <a href="change.txt.html#replacing" class="d">replacing</a> all occurrences of <span class="s">{pattern}</span> in the
    given <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a> by <span class="s">{replacement}</span>.

<span class="h">    Parameters: </span>
      • <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>      (`string`)
      • <span class="s">{pattern}</span>      (`vim.lpeg.Pattern|string`)
      • <span class="s">{replacement}</span>  (`string`)

<span class="h">    Return: </span>
        (`string`)

vim.re.match({subject}, <span class="s">{pattern}</span>, <span class="s">{init}</span>)                    <span id="vim.re.match%28%29" class="t">vim.re.match()</span>
    Matches the given <span class="s">{pattern}</span> against the given <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>, returning all
    captures.

<span class="h">    Parameters: </span>
      • <a href="helphelp.txt.html#%7Bsubject%7D" class="s">{subject}</a>  (`string`)
      • <span class="s">{pattern}</span>  (`vim.lpeg.Pattern|string`)
      • <span class="s">{init}</span>     (`integer?`)

<span class="h">    Return: </span>
        (`integer|vim.lpeg.Capture?`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#vim.lpeg.match%28%29" class="d">vim.lpeg.match()</a>

<a href="lua.txt.html#vim.re.updatelocale%28%29" class="d">vim.re.updatelocale()</a>                                  <span id="vim.re.updatelocale%28%29" class="t">vim.re.updatelocale()</span>
    Updates the pre-defined character classes to the current locale.


<span class="h">==============================================================================</span>
<span class="c">VIM.REGEX</span>                                                          <span id="vim.regex" class="t">vim.regex</span>

Vim regexes can be used directly from Lua. Currently they only allow matching
within <a href="insert.txt.html#a" class="d">a</a> single line.


                                                          <span id="regex%3Amatch_line%28%29" class="t">regex:match_line()</span>
regex:match_line({bufnr}, <span class="s">{line_idx}</span>, <span class="s">{start}</span>, <span class="s">{end_}</span>)
    Matches line <a href="motion.txt.html#at" class="d">at</a> <span class="e">line_idx</span> (zero-based) in buffer <span class="e">bufnr</span>. Match <a href="motion.txt.html#is" class="d">is</a>
    restricted to byte <a href="index.txt.html#index" class="d">index</a> range <span class="e">start</span> and <span class="e">end_</span> if given, otherwise see
    <a href="lua.txt.html#regex%3Amatch_str%28%29" class="l">regex:match_str()</a><a href="repeat.txt.html#." class="d">.</a> Returned byte indices are relative to <span class="e">start</span> if
    given.

<span class="h">    Parameters: </span>
      • <span class="s">{bufnr}</span>     (`integer`)
      • <span class="s">{line_idx}</span>  (`integer`)
      • <span class="s">{start}</span>     (`integer?`)
      • <span class="s">{end_}</span>      (`integer?`)

<span class="h">    Return (multiple): </span>
        (`integer?`) match start (byte index) relative to <span class="e">start</span>, or <span class="e">nil</span> if
        no match
        (`integer?`) match <a href="intro.txt.html#end" class="d">end</a> (byte index) relative to <span class="e">start</span>, or <span class="e">nil</span> if
        no match

regex:match_str({str})                                     <span id="regex%3Amatch_str%28%29" class="t">regex:match_str()</span>
    Matches <a href="vimeval.txt.html#string" class="d">string</a> <span class="e">str</span> against this regex. To match the <a href="vimeval.txt.html#string" class="d">string</a> precisely,
    surround the regex with "<a href="motion.txt.html#%5E" class="d">^</a>" and "<a href="motion.txt.html#%24" class="d">$</a>"<a href="repeat.txt.html#." class="d">.</a> Returns the byte indices <a href="luaref.txt.html#for" class="d">for</a> the
    start and <a href="intro.txt.html#end" class="d">end</a> of the match, or <span class="e">nil</span> if there <a href="motion.txt.html#is" class="d">is</a> no match. Because any
    integer <a href="motion.txt.html#is" class="d">is</a> "<a href="vimeval.txt.html#truthy" class="d">truthy</a>"<a href="motion.txt.html#%2C" class="d">,</a> <span class="e">regex:match_str()</span> can be directly used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a>
    condition in an if-statement.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`)

<span class="h">    Return (multiple): </span>
        (`integer?`) match start (byte index), or <span class="e">nil</span> if no match
        (`integer?`) match <a href="intro.txt.html#end" class="d">end</a> (byte index), or <span class="e">nil</span> if no match

vim.regex({re})                                                  <span id="vim.regex%28%29" class="t">vim.regex()</span>
    Parses the Vim regex <span class="e">re</span> and returns <a href="insert.txt.html#a" class="d">a</a> regex object. Regexes are "magic"
    and case-sensitive by default, regardless of <a href="options.txt.html#%27magic%27" class="o">'magic'</a> and <a href="options.txt.html#%27ignorecase%27" class="o">'ignorecase'</a>.
    They can be controlled with flags, see <a href="pattern.txt.html#%2Fmagic" class="l">/magic</a> and <a href="pattern.txt.html#%2Fignorecase" class="l">/ignorecase</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{re}</span>  (`string`)

<span class="h">    Return: </span>
        (`vim.regex`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.secure" class="d">vim.secure</a>                                            <span id="vim.secure" class="t">vim.secure</span>

vim.secure.read({path})                                    <span id="vim.secure.read%28%29" class="t">vim.secure.read()</span>
    If <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> file: attempt to read the file, prompting the user if the
    file should be trusted.

    If <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> directory: return true if the directory <a href="motion.txt.html#is" class="d">is</a> trusted
    (non-recursive), prompting the user <a href="motion.txt.html#as" class="d">as</a> necessary.

    The user's choice <a href="motion.txt.html#is" class="d">is</a> persisted in <a href="insert.txt.html#a" class="d">a</a> <a href="editing.txt.html#trust" class="d">trust</a> database <a href="motion.txt.html#at" class="d">at</a>
    $XDG_STATE_HOME/nvim/trust.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{path}</span>  (`string`) Path to <a href="insert.txt.html#a" class="d">a</a> file or directory to read.

<span class="h">    Return: </span>
        (`boolean|string?`) If <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> not trusted or does not exist,
        returns <span class="e">nil</span>. Otherwise, returns the contents of <span class="s">{path}</span> if <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a>
        file, or true if <span class="s">{path}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> directory.

<span class="h">    See also: </span>
      • <a href="editing.txt.html#%3Atrust" class="l">:trust</a>

vim.secure.trust({opts})                                  <span id="vim.secure.trust%28%29" class="t">vim.secure.trust()</span>
    Manage the <a href="editing.txt.html#trust" class="d">trust</a> database.

    The <a href="editing.txt.html#trust" class="d">trust</a> database <a href="motion.txt.html#is" class="d">is</a> located <a href="motion.txt.html#at" class="d">at</a> <a href="starting.txt.html#%24XDG_STATE_HOME" class="l">$XDG_STATE_HOME</a>/nvim/trust.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{opts}</span>  (`table`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
                • <span class="s">{action}</span> (`'allow'<span class="l">'deny'</span><span class="o">'remove'</span>`) <a href="motion.txt.html#-" class="d">-</a> <span class="e">'allow'</span> to add <a href="insert.txt.html#a" class="d">a</a>
                  file to the <a href="editing.txt.html#trust" class="d">trust</a> database and <a href="editing.txt.html#trust" class="d">trust</a> it,
                • <span class="e">'deny'</span> to add <a href="insert.txt.html#a" class="d">a</a> file to the <a href="editing.txt.html#trust" class="d">trust</a> database and deny it,
                • <span class="e">'remove'</span> to remove file from the <a href="editing.txt.html#trust" class="d">trust</a> database
                • <span class="s">{path}</span>? (`string`) Path to <a href="insert.txt.html#a" class="d">a</a> file to update. Mutually
                  <a href="motion.txt.html#exclusive" class="d">exclusive</a> with <span class="s">{bufnr}</span>. Cannot be used when <span class="s">{action}</span> <a href="motion.txt.html#is" class="d">is</a>
                  "allow"<a href="repeat.txt.html#." class="d">.</a>
                • <span class="s">{bufnr}</span>? (`integer`) Buffer number to update. Mutually
                  <a href="motion.txt.html#exclusive" class="d">exclusive</a> with <span class="s">{path}</span>.

<span class="h">    Return (multiple): </span>
        (`boolean`) success true if operation was successful
        (`string`) msg full path if operation was successful, else error
        message


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.version" class="d">vim.version</a>                                          <span id="vim.version" class="t">vim.version</span>

The <span class="e">vim.version</span> module provides <a href="vimeval.txt.html#functions" class="d">functions</a> <a href="luaref.txt.html#for" class="d">for</a> comparing versions and ranges
conforming to the <a class="u" href="https://semver.org">https://semver.org</a> spec. Plugins, and <a href="usr_05.txt.html#plugin" class="d">plugin</a> managers, can
use this to check available tools and dependencies on the current system.

Example: 
<span class="e">    local v = vim.version.parse(vim.fn.system({'tmux', '-V'}), {strict=false})</span>
<span class="e">    if vim.version.gt(v, {3, 2, 0}) then</span>
<span class="e">      -- ...</span>
<span class="e">    end</span>


<span id="vim.version%28%29" class="t">vim.version()</span> returns the version of the current Nvim process.

<span class="c">VERSION RANGE SPEC</span>                                             <span id="version-range" class="t">version-range</span>

<a href="insert.txt.html#A" class="d">A</a> version "range spec" defines <a href="insert.txt.html#a" class="d">a</a> semantic version range which can be tested
against <a href="insert.txt.html#a" class="d">a</a> version, using <a href="lua.txt.html#vim.version.range%28%29" class="l">vim.version.range()</a><a href="repeat.txt.html#." class="d">.</a>

Supported range specs are shown in the following table. <span class="n">Note:</span> suffixed
versions (1.2.3-rc1) are not matched. 
<span class="e">    1.2.3             is 1.2.3</span>
<span class="e">    =1.2.3            is 1.2.3</span>
<span class="e">    &gt;1.2.3            greater than 1.2.3</span>
<span class="e">    &lt;1.2.3            before 1.2.3</span>
<span class="e">    &gt;=1.2.3           at least 1.2.3</span>
<span class="e">    ~1.2.3            is &gt;=1.2.3 &lt;1.3.0       "reasonably close to 1.2.3"</span>
<span class="e">    ^1.2.3            is &gt;=1.2.3 &lt;2.0.0       "compatible with 1.2.3"</span>
<span class="e">    ^0.2.3            is &gt;=0.2.3 &lt;0.3.0       (0.x.x is special)</span>
<span class="e">    ^0.0.1            is =0.0.1               (0.0.x is special)</span>
<span class="e">    ^1.2              is &gt;=1.2.0 &lt;2.0.0       (like ^1.2.0)</span>
<span class="e">    ~1.2              is &gt;=1.2.0 &lt;1.3.0       (like ~1.2.0)</span>
<span class="e">    ^1                is &gt;=1.0.0 &lt;2.0.0       "compatible with 1"</span>
<span class="e">    ~1                same                    "reasonably close to 1"</span>
<span class="e">    1.x               same</span>
<span class="e">    1.*               same</span>
<span class="e">    1                 same</span>
<span class="e">    *                 any version</span>
<span class="e">    x                 same</span>
<span class="e"></span>
<span class="e">    1.2.3 - 2.3.4     is &gt;=1.2.3 &lt;=2.3.4</span>
<span class="e"></span>
<span class="e">    Partial right: missing pieces treated as x (2.3 =&gt; 2.3.x).</span>
<span class="e">    1.2.3 - 2.3       is &gt;=1.2.3 &lt;2.4.0</span>
<span class="e">    1.2.3 - 2         is &gt;=1.2.3 &lt;3.0.0</span>
<span class="e"></span>
<span class="e">    Partial left: missing pieces treated as 0 (1.2 =&gt; 1.2.0).</span>
<span class="e">    1.2 - 2.3.0       is 1.2.0 - 2.3.0</span>



vim.version.cmp({v1}, <span class="s">{v2}</span>)                                <span id="vim.version.cmp%28%29" class="t">vim.version.cmp()</span>
    Parses and compares two version <a href="index.txt.html#objects" class="d">objects</a> (the result of
    <a href="lua.txt.html#vim.version.parse%28%29" class="l">vim.version.parse()</a><a href="motion.txt.html#%2C" class="d">,</a> or specified literally <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> `{major, minor, patch}`
    tuple, e.g. `{1, 0, 3}`).

    Example: 
<span class="e">        if vim.version.cmp({1,0,3}, {0,2,1}) == 0 then</span>
<span class="e">          -- ...</span>
<span class="e">        end</span>
<span class="e">        local v1 = vim.version.parse('1.0.3-pre')</span>
<span class="e">        local v2 = vim.version.parse('0.2.1')</span>
<span class="e">        if vim.version.cmp(v1, v2) == 0 then</span>
<span class="e">          -- ...</span>
<span class="e">        end</span>


<span class="h">    Note: </span>
      • Per semver, build metadata <a href="motion.txt.html#is" class="d">is</a> ignored when comparing two
        otherwise-equivalent versions.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`) Version object.
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`) Version to compare with <span class="e">v1</span>.

<span class="h">    Return: </span>
        (`integer`) -1 if `v1 <a href="change.txt.html#%3C" class="d">&lt;</a> v2`, <a href="motion.txt.html#0" class="d">0</a> if `v1 <a href="change.txt.html#%3D%3D" class="d">==</a> v2`, 1 if `v1 <a href="change.txt.html#%3E" class="d">&gt;</a> v2`.

vim.version.eq({v1}, <span class="s">{v2}</span>)                                  <span id="vim.version.eq%28%29" class="t">vim.version.eq()</span>
    Returns <span class="e">true</span> if the given versions are equal. See <a href="lua.txt.html#vim.version.cmp%28%29" class="l">vim.version.cmp()</a>
    <a href="luaref.txt.html#for" class="d">for</a> usage.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`)
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`)

<span class="h">    Return: </span>
        (`boolean`)

vim.version.ge({v1}, <span class="s">{v2}</span>)                                  <span id="vim.version.ge%28%29" class="t">vim.version.ge()</span>
    Returns <span class="e">true</span> if `v1 &gt;= v2`. See <a href="lua.txt.html#vim.version.cmp%28%29" class="l">vim.version.cmp()</a> <a href="luaref.txt.html#for" class="d">for</a> usage.

<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`)
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`)

<span class="h">    Return: </span>
        (`boolean`)

vim.version.gt({v1}, <span class="s">{v2}</span>)                                  <span id="vim.version.gt%28%29" class="t">vim.version.gt()</span>
    Returns <span class="e">true</span> if `v1 <a href="change.txt.html#%3E" class="d">&gt;</a> v2`. See <a href="lua.txt.html#vim.version.cmp%28%29" class="l">vim.version.cmp()</a> <a href="luaref.txt.html#for" class="d">for</a> usage.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`)
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`)

<span class="h">    Return: </span>
        (`boolean`)

vim.version.last({versions})                              <span id="vim.version.last%28%29" class="t">vim.version.last()</span>
    TODO: generalize this, move to func.lua

<span class="h">    Parameters: </span>
      • <span class="s">{versions}</span>  (`vim.Version[]`)

<span class="h">    Return: </span>
        (`vim.Version?`)

vim.version.le({v1}, <span class="s">{v2}</span>)                                  <span id="vim.version.le%28%29" class="t">vim.version.le()</span>
    Returns <span class="e">true</span> if `v1 &lt;= v2`. See <a href="lua.txt.html#vim.version.cmp%28%29" class="l">vim.version.cmp()</a> <a href="luaref.txt.html#for" class="d">for</a> usage.

<span class="h">    Attributes: </span>
        Since: 0.10.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`)
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`)

<span class="h">    Return: </span>
        (`boolean`)

vim.version.lt({v1}, <span class="s">{v2}</span>)                                  <span id="vim.version.lt%28%29" class="t">vim.version.lt()</span>
    Returns <span class="e">true</span> if `v1 <a href="change.txt.html#%3C" class="d">&lt;</a> v2`. See <a href="lua.txt.html#vim.version.cmp%28%29" class="l">vim.version.cmp()</a> <a href="luaref.txt.html#for" class="d">for</a> usage.

<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{v1}</span>  (`vim.Version<span class="l">number[]</span>string`)
      • <span class="s">{v2}</span>  (`vim.Version<span class="l">number[]</span>string`)

<span class="h">    Return: </span>
        (`boolean`)

vim.version.parse({version}, <span class="s">{opts}</span>)                     <span id="vim.version.parse%28%29" class="t">vim.version.parse()</span>
    Parses <a href="insert.txt.html#a" class="d">a</a> semantic version <a href="vimeval.txt.html#string" class="d">string</a> and returns <a href="insert.txt.html#a" class="d">a</a> version object which can be
    used with other <span class="e">vim.version</span> functions. For example "1.0.1-rc1+build.2"
    returns: 
<span class="e">        { major = 1, minor = 0, patch = 1, prerelease = "rc1", build = "build.2" }</span>


<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{version}</span>  (`string`) Version <a href="vimeval.txt.html#string" class="d">string</a> to parse.
      • <span class="s">{opts}</span>     (`table?`) Optional keyword arguments:
                   • strict (boolean): Default false. If <span class="e">true</span>, no coercion
                     <a href="motion.txt.html#is" class="d">is</a> attempted on input not conforming to semver v2.0.0. If
                     <span class="e">false</span>, <span class="e">parse()</span> attempts to coerce input such <a href="motion.txt.html#as" class="d">as</a>
                     "1.0"<a href="motion.txt.html#%2C" class="d">,</a> "0-x"<a href="motion.txt.html#%2C" class="d">,</a> "tmux 3.2a" into valid versions.

<span class="h">    Return: </span>
        (`vim.Version?`) parsed_version Version object or <span class="e">nil</span> if input <a href="motion.txt.html#is" class="d">is</a>
        invalid.

<span class="h">    See also: </span>
      • <a class="u" href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>

vim.version.range({spec})                                <span id="vim.version.range%28%29" class="t">vim.version.range()</span>
    Parses <a href="insert.txt.html#a" class="d">a</a> semver <a href="lua.txt.html#version-range" class="l">version-range</a> "spec" and returns <a href="insert.txt.html#a" class="d">a</a> range object: 
<span class="e">        {</span>
<span class="e">          from: Version</span>
<span class="e">          to: Version</span>
<span class="e">          has(v: string|Version)</span>
<span class="e">        }</span>


    <span class="e">:has()</span> checks if <a href="insert.txt.html#a" class="d">a</a> version <a href="motion.txt.html#is" class="d">is</a> in the range (inclusive <span class="e">from</span>, <a href="motion.txt.html#exclusive" class="d">exclusive</a>
    <span class="e">to</span>).

    Example: 
<span class="e">        local r = vim.version.range('1.0.0 - 2.0.0')</span>
<span class="e">        print(r:has('1.9.9'))       -- true</span>
<span class="e">        print(r:has('2.0.0'))       -- false</span>
<span class="e">        print(r:has(vim.version())) -- check against current Nvim version</span>


    Or use cmp(), le(), lt(), ge(), gt(), and/or eq() to compare <a href="insert.txt.html#a" class="d">a</a> version
    against <span class="e">.to</span> and <span class="e">.from</span> directly: 
<span class="e">        local r = vim.version.range('1.0.0 - 2.0.0') -- &gt;=1.0, &lt;2.0</span>
<span class="e">        print(vim.version.ge({1,0,3}, r.from) and vim.version.lt({1,0,3}, r.to))</span>


<span class="h">    Attributes: </span>
        Since: 0.9.0

<span class="h">    Parameters: </span>
      • <span class="s">{spec}</span>  (`string`) Version range "spec"

<span class="h">    Return: </span>
        (`table?`) <a href="insert.txt.html#A" class="d">A</a> table with the following fields:
        • <span class="s">{from}</span> (`vim.Version`)
        • <span class="s">{to}</span>? (`vim.Version`)
        • <span class="s">{has}</span> (`fun(self: vim.VersionRange, version: <a href="vimeval.txt.html#string" class="d">string</a>|vim.Version)`)

<span class="h">    See also: </span>
      • <a class="u" href="https://github.com/npm/node-semver#ranges">https://github.com/npm/node-semver#ranges</a>


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.iter" class="d">vim.iter</a>                                                <span id="vim.iter" class="t">vim.iter</span>

<span id="vim.iter%28%29" class="t">vim.iter()</span> <a href="motion.txt.html#is" class="d">is</a> an interface <a href="luaref.txt.html#for" class="d">for</a> <a href="lua.txt.html#iterable" class="l">iterable</a>s: <a href="motion.txt.html#it" class="d">it</a> wraps <a href="insert.txt.html#a" class="d">a</a> table or function
argument into an <span id="Iter" class="t">Iter</span> object with methods (such <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#Iter%3Afilter%28%29" class="l">Iter:filter()</a> and
<a href="lua.txt.html#Iter%3Amap%28%29" class="l">Iter:map()</a><a href="motion.txt.html#%29" class="d">)</a> that transform the underlying source data. These methods can be
chained to create <a href="lua.txt.html#iterator" class="d">iterator</a> "pipelines"<a href="cmdline.txt.html#%3A" class="d">:</a> the output of each pipeline stage <a href="motion.txt.html#is" class="d">is</a>
input to the next stage. The first stage depends on the type passed to
<span class="e">vim.iter()</span>:
• <a href="vimeval.txt.html#Lists" class="d">Lists</a> or arrays <a href="motion.txt.html#%28" class="d">(</a><a href="lua.txt.html#lua-list" class="l">lua-list</a><a href="motion.txt.html#%29" class="d">)</a> yield only the value of each element.
  • Holes (nil values) are allowed (but discarded).
  • Use <a href="luaref.txt.html#pairs%28%29" class="d">pairs()</a> to treat array/list tables <a href="motion.txt.html#as" class="d">as</a> dicts (preserve holes and
    non-contiguous integer keys): <span class="e">vim.iter(pairs(…))</span>.
  • Use <a href="lua.txt.html#Iter%3Aenumerate%28%29" class="l">Iter:enumerate()</a> to also pass the <a href="index.txt.html#index" class="d">index</a> to the next stage.
    • Or initialize with ipairs(): <span class="e">vim.iter(ipairs(…))</span>.
• Non-list tables <a href="motion.txt.html#%28" class="d">(</a><a href="lua.txt.html#lua-dict" class="l">lua-dict</a><a href="motion.txt.html#%29" class="d">)</a> yield both the key and value of each element.
• Function <a href="lua.txt.html#iterator" class="l">iterator</a><a href="change.txt.html#s" class="d">s</a> yield all values returned by the underlying function.
• Tables with <a href="insert.txt.html#a" class="d">a</a> <a href="luaref.txt.html#__call%28%29" class="l">__call()</a> metamethod are treated <a href="motion.txt.html#as" class="d">as</a> function iterators.

The <a href="lua.txt.html#iterator" class="d">iterator</a> pipeline terminates when the underlying <a href="lua.txt.html#iterable" class="l">iterable</a> <a href="motion.txt.html#is" class="d">is</a> exhausted
(for function iterators this means <a href="motion.txt.html#it" class="d">it</a> returned nil).

<span class="n">Note:</span> <span class="e">vim.iter()</span> scans table input to decide if <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> or <a href="insert.txt.html#a" class="d">a</a> dict; to
avoid this cost you can wrap the table with an <a href="lua.txt.html#iterator" class="d">iterator</a> e.g.
<span class="e">vim.iter(ipairs({…}))</span>, but that precludes the use of <a href="lua.txt.html#list-iterator" class="l">list-iterator</a>
operations such <a href="motion.txt.html#as" class="d">as</a> <a href="lua.txt.html#Iter%3Arev%28%29" class="l">Iter:rev()</a>).

Examples: 
<span class="e">    local it = vim.iter({ 1, 2, 3, 4, 5 })</span>
<span class="e">    it:map(function(v)</span>
<span class="e">      return v * 3</span>
<span class="e">    end)</span>
<span class="e">    it:rev()</span>
<span class="e">    it:skip(2)</span>
<span class="e">    it:totable()</span>
<span class="e">    -- { 9, 6, 3 }</span>
<span class="e"></span>
<span class="e">    -- ipairs() is a function iterator which returns both the index (i) and the value (v)</span>
<span class="e">    vim.iter(ipairs({ 1, 2, 3, 4, 5 })):map(function(i, v)</span>
<span class="e">      if i &gt; 2 then return v end</span>
<span class="e">    end):totable()</span>
<span class="e">    -- { 3, 4, 5 }</span>
<span class="e"></span>
<span class="e">    local it = vim.iter(vim.gsplit('1,2,3,4,5', ','))</span>
<span class="e">    it:map(function(s) return tonumber(s) end)</span>
<span class="e">    for i, d in it:enumerate() do</span>
<span class="e">      print(string.format("Column %d is %d", i, d))</span>
<span class="e">    end</span>
<span class="e">    -- Column 1 is 1</span>
<span class="e">    -- Column 2 is 2</span>
<span class="e">    -- Column 3 is 3</span>
<span class="e">    -- Column 4 is 4</span>
<span class="e">    -- Column 5 is 5</span>
<span class="e"></span>
<span class="e">    vim.iter({ a = 1, b = 2, c = 3, z = 26 }):any(function(k, v)</span>
<span class="e">      return k == 'z'</span>
<span class="e">    end)</span>
<span class="e">    -- true</span>
<span class="e"></span>
<span class="e">    local rb = vim.ringbuf(3)</span>
<span class="e">    rb:push("a")</span>
<span class="e">    rb:push("b")</span>
<span class="e">    vim.iter(rb):totable()</span>
<span class="e">    -- { "a", "b" }</span>



Iter:all({pred})                                                  <span id="Iter%3Aall%28%29" class="t">Iter:all()</span>
    Returns true if all items in the <a href="lua.txt.html#iterator" class="d">iterator</a> match the given predicate.

<span class="h">    Parameters: </span>
      • <span class="s">{pred}</span>  (`fun(...):boolean`) Predicate function. Takes all values
                returned from the previous stage in the pipeline <a href="motion.txt.html#as" class="d">as</a> arguments
                and returns true if the predicate matches.

Iter:any({pred})                                                  <span id="Iter%3Aany%28%29" class="t">Iter:any()</span>
    Returns true if any of the items in the <a href="lua.txt.html#iterator" class="d">iterator</a> match the given
    predicate.

<span class="h">    Parameters: </span>
      • <span class="s">{pred}</span>  (`fun(...):boolean`) Predicate function. Takes all values
                returned from the previous stage in the pipeline <a href="motion.txt.html#as" class="d">as</a> arguments
                and returns true if the predicate matches.

Iter:each({f})                                                   <span id="Iter%3Aeach%28%29" class="t">Iter:each()</span>
    Calls <a href="insert.txt.html#a" class="d">a</a> function once <a href="luaref.txt.html#for" class="d">for</a> each item in the pipeline, draining the
    iterator.

    For <a href="vimeval.txt.html#functions" class="d">functions</a> with side effects. To modify the values in the iterator, use
    <a href="lua.txt.html#Iter%3Amap%28%29" class="l">Iter:map()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`fun(...)`) Function to execute <a href="luaref.txt.html#for" class="d">for</a> each item in the pipeline.
             Takes all of the values returned by the previous stage in the
             pipeline <a href="motion.txt.html#as" class="d">as</a> arguments.

<a href="lua.txt.html#Iter%3Aenumerate%28%29" class="d">Iter:enumerate()</a>                                            <span id="Iter%3Aenumerate%28%29" class="t">Iter:enumerate()</span>
    Yields the item <a href="index.txt.html#index" class="d">index</a> (count) and value <a href="luaref.txt.html#for" class="d">for</a> each item of an <a href="lua.txt.html#iterator" class="d">iterator</a>
    pipeline.

    For <a href="vimeval.txt.html#list" class="d">list</a> tables, this <a href="motion.txt.html#is" class="d">is</a> more efficient: 
<span class="e">        vim.iter(ipairs(t))</span>


    instead of: 
<span class="e">        vim.iter(t):enumerate()</span>


    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter(vim.gsplit('abc', '')):enumerate()</span>
<span class="e">        it:next()</span>
<span class="e">        -- 1	'a'</span>
<span class="e">        it:next()</span>
<span class="e">        -- 2	'b'</span>
<span class="e">        it:next()</span>
<span class="e">        -- 3	'c'</span>


<span class="h">    Return: </span>
        (`Iter`)

Iter:filter({f})                                               <span id="Iter%3Afilter%28%29" class="t">Iter:filter()</span>
    Filters an <a href="lua.txt.html#iterator" class="d">iterator</a> pipeline.

    Example: 
<span class="e">        local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)</span>


<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`fun(...):boolean`) Takes all values returned from the previous
             stage in the pipeline and returns false or nil if the current
             <a href="lua.txt.html#iterator" class="d">iterator</a> element should be removed.

<span class="h">    Return: </span>
        (`Iter`)

Iter:find({f})                                                   <span id="Iter%3Afind%28%29" class="t">Iter:find()</span>
    Find the first value in the <a href="lua.txt.html#iterator" class="d">iterator</a> that satisfies the given predicate.

    Advances the iterator. Returns nil and drains the <a href="lua.txt.html#iterator" class="d">iterator</a> if no value <a href="motion.txt.html#is" class="d">is</a>
    found.

    Examples: 
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it:find(12)</span>
<span class="e">        -- 12</span>
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it:find(20)</span>
<span class="e">        -- nil</span>
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it:find(function(v) return v % 4 == 0 end)</span>
<span class="e">        -- 12</span>


<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`any`)

<span class="h">    Return: </span>
        (`any`)

Iter:flatten({depth})                                         <span id="Iter%3Aflatten%28%29" class="t">Iter:flatten()</span>
    Flattens <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a><a href="motion.txt.html#%2C" class="d">,</a> un-nesting nested values up to the given
    <span class="s">{depth}</span>. Errors if <a href="motion.txt.html#it" class="d">it</a> attempts to flatten <a href="insert.txt.html#a" class="d">a</a> dict-like value.

    Examples: 
<span class="e">        vim.iter({ 1, { 2 }, { { 3 } } }):flatten():totable()</span>
<span class="e">        -- { 1, 2, { 3 } }</span>
<span class="e"></span>
<span class="e">        vim.iter({1, { { a = 2 } }, { 3 } }):flatten():totable()</span>
<span class="e">        -- { 1, { a = 2 }, 3 }</span>
<span class="e"></span>
<span class="e">        vim.iter({ 1, { { a = 2 } }, { 3 } }):flatten(math.huge):totable()</span>
<span class="e">        -- error: attempt to flatten a dict-like table</span>


<span class="h">    Parameters: </span>
      • <span class="s">{depth}</span>  (`number?`) Depth to which <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> should be
                 flattened (defaults to 1)

<span class="h">    Return: </span>
        (`Iter`)

Iter:fold({init}, <span class="s">{f}</span>)                                           <span id="Iter%3Afold%28%29" class="t">Iter:fold()</span>
    Folds <a href="motion.txt.html#%28" class="d">(</a>"reduces"<a href="motion.txt.html#%29" class="d">)</a> an <a href="lua.txt.html#iterator" class="d">iterator</a> into <a href="insert.txt.html#a" class="d">a</a> single value.         <span id="Iter%3Areduce%28%29" class="t">Iter:reduce()</span>

    Examples: 
<span class="e">        -- Create a new table with only even values</span>
<span class="e">        vim.iter({ a = 1, b = 2, c = 3, d = 4 })</span>
<span class="e">          :filter(function(k, v) return v % 2 == 0 end)</span>
<span class="e">          :fold({}, function(acc, k, v)</span>
<span class="e">            acc[k] = v</span>
<span class="e">            return acc</span>
<span class="e">          end) --&gt; { b = 2, d = 4 }</span>
<span class="e"></span>
<span class="e">        -- Get the "maximum" item of an iterable.</span>
<span class="e">        vim.iter({ -99, -4, 3, 42, 0, 0, 7 })</span>
<span class="e">          :fold({}, function(acc, v)</span>
<span class="e">            acc.max = math.max(v, acc.max or v)</span>
<span class="e">            return acc</span>
<span class="e">          end) --&gt; { max = 42 }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{init}</span>  (`any`) Initial value of the accumulator.
      • <span class="s">{f}</span>     (`fun(acc:A, ...):A`) Accumulation function.

<span class="h">    Return: </span>
        (`any`)

Iter:join({delim})                                               <span id="Iter%3Ajoin%28%29" class="t">Iter:join()</span>
    Collect the <a href="lua.txt.html#iterator" class="d">iterator</a> into <a href="insert.txt.html#a" class="d">a</a> delimited string.

    Each element in the <a href="lua.txt.html#iterator" class="d">iterator</a> <a href="motion.txt.html#is" class="d">is</a> joined into <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#string" class="d">string</a> separated by <span class="s">{delim}</span>.

    Consumes the iterator.

<span class="h">    Parameters: </span>
      • <span class="s">{delim}</span>  (`string`) Delimiter

<span class="h">    Return: </span>
        (`string`)

<a href="lua.txt.html#Iter%3Alast%28%29" class="d">Iter:last()</a>                                                      <span id="Iter%3Alast%28%29" class="t">Iter:last()</span>
    Drains the <a href="lua.txt.html#iterator" class="d">iterator</a> and returns the last item.

    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter(vim.gsplit('abcdefg', ''))</span>
<span class="e">        it:last()</span>
<span class="e">        -- 'g'</span>
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12, 15 })</span>
<span class="e">        it:last()</span>
<span class="e">        -- 15</span>


<span class="h">    Return: </span>
        (`any`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#Iter%3Arpeek%28%29" class="l">Iter:rpeek()</a>

Iter:map({f})                                                     <span id="Iter%3Amap%28%29" class="t">Iter:map()</span>
    Maps the items of an <a href="lua.txt.html#iterator" class="d">iterator</a> pipeline to the values returned by <span class="e">f</span>.

    If the map function returns nil, the value <a href="motion.txt.html#is" class="d">is</a> filtered from the iterator.

    Example: 
<span class="e">        local it = vim.iter({ 1, 2, 3, 4 }):map(function(v)</span>
<span class="e">          if v % 2 == 0 then</span>
<span class="e">            return v * 3</span>
<span class="e">          end</span>
<span class="e">        end)</span>
<span class="e">        it:totable()</span>
<span class="e">        -- { 6, 12 }</span>


<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`fun(...):...:any`) Mapping function. Takes all values returned
             from the previous stage in the pipeline <a href="motion.txt.html#as" class="d">as</a> arguments and returns
             one or more new values, which are used in the next pipeline
             stage. Nil return values are filtered from the output.

<span class="h">    Return: </span>
        (`Iter`)

<a href="lua.txt.html#Iter%3Anext%28%29" class="d">Iter:next()</a>                                                      <span id="Iter%3Anext%28%29" class="t">Iter:next()</span>
    Gets the next value from the iterator.

    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter(string.gmatch('1 2 3', '%d+')):map(tonumber)</span>
<span class="e">        it:next()</span>
<span class="e">        -- 1</span>
<span class="e">        it:next()</span>
<span class="e">        -- 2</span>
<span class="e">        it:next()</span>
<span class="e">        -- 3</span>


<span class="h">    Return: </span>
        (`any`)

Iter:nth({n})                                                     <span id="Iter%3Anth%28%29" class="t">Iter:nth()</span>
    Gets the nth value of an <a href="lua.txt.html#iterator" class="d">iterator</a> (and advances to it).

    If <span class="e">n</span> <a href="motion.txt.html#is" class="d">is</a> negative, offsets from the <a href="intro.txt.html#end" class="d">end</a> of <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a><a href="repeat.txt.html#." class="d">.</a>

    Example: 
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it:nth(2)</span>
<span class="e">        -- 6</span>
<span class="e">        it:nth(2)</span>
<span class="e">        -- 12</span>
<span class="e"></span>
<span class="e">        local it2 = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it2:nth(-2)</span>
<span class="e">        -- 9</span>
<span class="e">        it2:nth(-2)</span>
<span class="e">        -- 3</span>


<span class="h">    Parameters: </span>
      • <span class="s">{n}</span>  (`number`) Index of the value to return. May be negative if the
             source <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return: </span>
        (`any`)

<a href="lua.txt.html#Iter%3Apeek%28%29" class="d">Iter:peek()</a>                                                      <span id="Iter%3Apeek%28%29" class="t">Iter:peek()</span>
    Gets the next value in <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> without consuming it.

    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 })</span>
<span class="e">        it:peek()</span>
<span class="e">        -- 3</span>
<span class="e">        it:peek()</span>
<span class="e">        -- 3</span>
<span class="e">        it:next()</span>
<span class="e">        -- 3</span>


<span class="h">    Return: </span>
        (`any`)

<a href="lua.txt.html#Iter%3Apop%28%29" class="d">Iter:pop()</a>                                                        <span id="Iter%3Apop%28%29" class="t">Iter:pop()</span>
    "Pops" <a href="insert.txt.html#a" class="d">a</a> value from <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> (gets the last value and decrements
    the tail).

    Example: 
<span class="e">        local it = vim.iter({1, 2, 3, 4})</span>
<span class="e">        it:pop()</span>
<span class="e">        -- 4</span>
<span class="e">        it:pop()</span>
<span class="e">        -- 3</span>


<span class="h">    Return: </span>
        (`any`)

<a href="lua.txt.html#Iter%3Arev%28%29" class="d">Iter:rev()</a>                                                        <span id="Iter%3Arev%28%29" class="t">Iter:rev()</span>
    Reverses <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> pipeline.

    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 }):rev()</span>
<span class="e">        it:totable()</span>
<span class="e">        -- { 12, 9, 6, 3 }</span>


<span class="h">    Return: </span>
        (`Iter`)

Iter:rfind({f})                                                 <span id="Iter%3Arfind%28%29" class="t">Iter:rfind()</span>
    Gets the first value satisfying <a href="insert.txt.html#a" class="d">a</a> predicate, from the <a href="intro.txt.html#end" class="d">end</a> of <a href="insert.txt.html#a" class="d">a</a>
    <a href="lua.txt.html#list-iterator" class="l">list-iterator</a><a href="repeat.txt.html#." class="d">.</a>

    Advances the iterator. Returns nil and drains the <a href="lua.txt.html#iterator" class="d">iterator</a> if no value <a href="motion.txt.html#is" class="d">is</a>
    found.

    Examples: 
<span class="e"></span>
<span class="e">        local it = vim.iter({ 1, 2, 3, 2, 1 }):enumerate()</span>
<span class="e">        it:rfind(1)</span>
<span class="e">        -- 5	1</span>
<span class="e">        it:rfind(1)</span>
<span class="e">        -- 1	1</span>


<span class="h">    Parameters: </span>
      • <span class="s">{f}</span>  (`any`)

<span class="h">    Return: </span>
        (`any`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#Iter%3Afind%28%29" class="l">Iter:find()</a>

<a href="lua.txt.html#Iter%3Arpeek%28%29" class="d">Iter:rpeek()</a>                                                    <span id="Iter%3Arpeek%28%29" class="t">Iter:rpeek()</span>
    Gets the last value of <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> without consuming it.

    Example: 
<span class="e">        local it = vim.iter({1, 2, 3, 4})</span>
<span class="e">        it:rpeek()</span>
<span class="e">        -- 4</span>
<span class="e">        it:rpeek()</span>
<span class="e">        -- 4</span>
<span class="e">        it:pop()</span>
<span class="e">        -- 4</span>


<span class="h">    Return: </span>
        (`any`)

<span class="h">    See also: </span>
      • <a href="lua.txt.html#Iter%3Alast%28%29" class="l">Iter:last()</a>

Iter:rskip({n})                                                 <span id="Iter%3Arskip%28%29" class="t">Iter:rskip()</span>
    Discards <span class="e">n</span> values from the <a href="intro.txt.html#end" class="d">end</a> of <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> pipeline.

    Example: 
<span class="e">        local it = vim.iter({ 1, 2, 3, 4, 5 }):rskip(2)</span>
<span class="e">        it:next()</span>
<span class="e">        -- 1</span>
<span class="e">        it:pop()</span>
<span class="e">        -- 3</span>


<span class="h">    Parameters: </span>
      • <span class="s">{n}</span>  (`number`) <a href="vimeval.txt.html#Number" class="d">Number</a> of values to skip.

<span class="h">    Return: </span>
        (`Iter`)

Iter:skip({n})                                                   <span id="Iter%3Askip%28%29" class="t">Iter:skip()</span>
    Skips <span class="e">n</span> values of an <a href="lua.txt.html#iterator" class="d">iterator</a> pipeline.

    Example: 
<span class="e"></span>
<span class="e">        local it = vim.iter({ 3, 6, 9, 12 }):skip(2)</span>
<span class="e">        it:next()</span>
<span class="e">        -- 9</span>


<span class="h">    Parameters: </span>
      • <span class="s">{n}</span>  (`number`) <a href="vimeval.txt.html#Number" class="d">Number</a> of values to skip.

<span class="h">    Return: </span>
        (`Iter`)

Iter:slice({first}, <span class="s">{last}</span>)                                     <span id="Iter%3Aslice%28%29" class="t">Iter:slice()</span>
    Sets the start and <a href="intro.txt.html#end" class="d">end</a> of <a href="insert.txt.html#a" class="d">a</a> <a href="lua.txt.html#list-iterator" class="l">list-iterator</a> pipeline.

    Equivalent to `:skip(first <a href="motion.txt.html#-" class="d">-</a> 1):rskip(len <a href="motion.txt.html#-" class="d">-</a> last <a href="motion.txt.html#%2B" class="d">+</a> 1)`.

<span class="h">    Parameters: </span>
      • <span class="s">{first}</span>  (`number`)
      • <span class="s">{last}</span>   (`number`)

<span class="h">    Return: </span>
        (`Iter`)

Iter:take({n})                                                   <span id="Iter%3Atake%28%29" class="t">Iter:take()</span>
    Transforms an <a href="lua.txt.html#iterator" class="d">iterator</a> to yield only the first <a href="pattern.txt.html#n" class="d">n</a> values.

    Example: 
<span class="e">        local it = vim.iter({ 1, 2, 3, 4 }):take(2)</span>
<span class="e">        it:next()</span>
<span class="e">        -- 1</span>
<span class="e">        it:next()</span>
<span class="e">        -- 2</span>
<span class="e">        it:next()</span>
<span class="e">        -- nil</span>


<span class="h">    Parameters: </span>
      • <span class="s">{n}</span>  (`integer`)

<span class="h">    Return: </span>
        (`Iter`)

<a href="lua.txt.html#Iter%3Atotable%28%29" class="d">Iter:totable()</a>                                                <span id="Iter%3Atotable%28%29" class="t">Iter:totable()</span>
    Collect the <a href="lua.txt.html#iterator" class="d">iterator</a> into <a href="insert.txt.html#a" class="d">a</a> table.

    The resulting table depends on the initial source in the <a href="lua.txt.html#iterator" class="d">iterator</a>
    pipeline. Array-like tables and function iterators will be collected into
    an array-like table. If multiple values are returned from the final stage
    in the <a href="lua.txt.html#iterator" class="d">iterator</a> pipeline, each value will be included in <a href="insert.txt.html#a" class="d">a</a> table.

    Examples: 
<span class="e">        vim.iter(string.gmatch('100 20 50', '%d+')):map(tonumber):totable()</span>
<span class="e">        -- { 100, 20, 50 }</span>
<span class="e"></span>
<span class="e">        vim.iter({ 1, 2, 3 }):map(function(v) return v, 2 * v end):totable()</span>
<span class="e">        -- { { 1, 2 }, { 2, 4 }, { 3, 6 } }</span>
<span class="e"></span>
<span class="e">        vim.iter({ a = 1, b = 2, c = 3 }):filter(function(k, v) return v % 2 ~= 0 end):totable()</span>
<span class="e">        -- { { 'a', 1 }, { 'c', 3 } }</span>


    The generated table <a href="motion.txt.html#is" class="d">is</a> an array-like table with consecutive, numeric
    indices. To create <a href="insert.txt.html#a" class="d">a</a> map-like table with arbitrary keys, use
    <a href="lua.txt.html#Iter%3Afold%28%29" class="l">Iter:fold()</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return: </span>
        (`table`)


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.snippet" class="d">vim.snippet</a>                                          <span id="vim.snippet" class="t">vim.snippet</span>

<span id="vim.snippet.ActiveFilter" class="t">vim.snippet.ActiveFilter</span>

<span class="h">    Fields: </span>
      • <span class="s">{direction}</span>  (`vim.snippet.Direction`) Navigation direction. -1 <a href="luaref.txt.html#for" class="d">for</a>
                     previous, 1 <a href="luaref.txt.html#for" class="d">for</a> next.


vim.snippet.active({filter})                            <span id="vim.snippet.active%28%29" class="t">vim.snippet.active()</span>
    Returns <span class="e">true</span> if there's an active snippet in the current buffer,
    applying the given <a href="change.txt.html#filter" class="d">filter</a> if provided.

<span class="h">    Parameters: </span>
      • <span class="s">{filter}</span>  (`vim.snippet.ActiveFilter?`) Filter to constrain the search
                  with:
                  • <span class="e">direction</span> (vim.snippet.Direction): Navigation direction.
                    Will return <span class="e">true</span> if the snippet can be jumped in the
                    given direction. See <a href="lua.txt.html#vim.snippet.ActiveFilter" class="l">vim.snippet.ActiveFilter</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Return: </span>
        (`boolean`)

vim.snippet.expand({input})                             <span id="vim.snippet.expand%28%29" class="t">vim.snippet.expand()</span>
    Expands the given snippet text. Refer to
    <a class="u" href="https://microsoft.github.io/language-server-protocol/specification/#snippet_syntax">https://microsoft.github.io/language-server-protocol/specification/#snippet_syntax</a>
    <a href="luaref.txt.html#for" class="d">for</a> the specification of valid input.

    Tabstops are highlighted with <a href="syntax.txt.html#hl-SnippetTabstop" class="l">hl-SnippetTabstop</a><a href="repeat.txt.html#." class="d">.</a>

<span class="h">    Parameters: </span>
      • <span class="s">{input}</span>  (`string`)

vim.snippet.jump({direction})                             <span id="vim.snippet.jump%28%29" class="t">vim.snippet.jump()</span>
    Jumps to the next (or previous) placeholder in the current snippet, if
    possible.

    By default <span class="e">&lt;Tab&gt;</span> <a href="motion.txt.html#is" class="d">is</a> setup to jump if <a href="insert.txt.html#a" class="d">a</a> snippet <a href="motion.txt.html#is" class="d">is</a> active. The default
    <a href="map.txt.html#mapping" class="d">mapping</a> looks like: 
<span class="e">        vim.keymap.set({ 'i', 's' }, '&lt;Tab&gt;', function()</span>
<span class="e">           if vim.snippet.active({ direction = 1 }) then</span>
<span class="e">             return '&lt;Cmd&gt;lua vim.snippet.jump(1)&lt;CR&gt;'</span>
<span class="e">           else</span>
<span class="e">             return '&lt;Tab&gt;'</span>
<span class="e">           end</span>
<span class="e">         end, { descr = '...', expr = true, silent = true })</span>


<span class="h">    Parameters: </span>
      • <span class="s">{direction}</span>  (`vim.snippet.Direction`) Navigation direction. -1 <a href="luaref.txt.html#for" class="d">for</a>
                     previous, 1 <a href="luaref.txt.html#for" class="d">for</a> next.

<a href="lua.txt.html#vim.snippet.stop%28%29" class="d">vim.snippet.stop()</a>                                        <span id="vim.snippet.stop%28%29" class="t">vim.snippet.stop()</span>
    Exits the current snippet.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: <a href="lua.txt.html#vim.text" class="d">vim.text</a>                                                <span id="vim.text" class="t">vim.text</span>

vim.text.hexdecode({enc})                               <span id="vim.text.hexdecode%28%29" class="t">vim.text.hexdecode()</span>
    Hex decode <a href="insert.txt.html#a" class="d">a</a> string.

<span class="h">    Parameters: </span>
      • <span class="s">{enc}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to decode

<span class="h">    Return (multiple): </span>
        (`string?`) Decoded <a href="vimeval.txt.html#string" class="d">string</a>
        (`string?`) Error message, if any

vim.text.hexencode({str})                               <span id="vim.text.hexencode%28%29" class="t">vim.text.hexencode()</span>
    Hex encode <a href="insert.txt.html#a" class="d">a</a> string.

<span class="h">    Parameters: </span>
      • <span class="s">{str}</span>  (`string`) <a href="vimeval.txt.html#String" class="d">String</a> to encode

<span class="h">    Return: </span>
        (`string`) Hex encoded <a href="vimeval.txt.html#string" class="d">string</a>

vim.text.indent({size}, <span class="s">{text}</span>, <span class="s">{opts}</span>)                    <span id="vim.text.indent%28%29" class="t">vim.text.indent()</span>
    Sets the indent (i.e. the common leading whitespace) of non-empty lines in
    <span class="e">text</span> to <span class="e">size</span> spaces/tabs.

    Indent <a href="motion.txt.html#is" class="d">is</a> calculated by number of consecutive indent chars.
    • The first indented, non-empty line decides the indent char (space/tab):
      • `SPC SPC TAB …<a href="motion.txt.html#%60" class="d">`</a> <a href="change.txt.html#%3D" class="d">=</a> two-space indent.
      • `TAB SPC …<a href="motion.txt.html#%60" class="d">`</a> <a href="change.txt.html#%3D" class="d">=</a> one-tab indent.
    • Set <span class="e">opts.expandtab</span> to treat tabs <a href="motion.txt.html#as" class="d">as</a> spaces.

    To "dedent" (remove the common indent), pass <span class="e">size=0</span>: 
<span class="e">        vim.print(vim.text.indent(0, ' a\n  b\n'))</span>


    To adjust relative-to an existing indent, call <a href="vimfn.txt.html#indent%28%29" class="d">indent()</a> twice: 
<span class="e">        local indented, old_indent = vim.text.indent(0, ' a\n b\n')</span>
<span class="e">        indented = vim.text.indent(old_indent + 2, indented)</span>
<span class="e">        vim.print(indented)</span>


    To ignore the final, blank line when calculating the indent, use gsub()
    before calling indent(): 
<span class="e">        local text = '  a\n  b\n '</span>
<span class="e">        vim.print(vim.text.indent(0, (text:gsub('\n[\t ]+\n?$', '\n'))))</span>


<span class="h">    Parameters: </span>
      • <span class="s">{size}</span>  (`integer`) <a href="vimeval.txt.html#Number" class="d">Number</a> of spaces.
      • <span class="s">{text}</span>  (`string`) Text to indent.
      • <span class="s">{opts}</span>  (`{ expandtab?: number }?`)

<span class="h">    Return (multiple): </span>
        (`string`) Indented text.
        (`integer`) Indent size before modification.


<span class="h">==============================================================================</span>
<a href="lua.txt.html#Lua" class="d">Lua</a> module: tohtml                                                <span id="vim.tohtml" class="t">vim.tohtml</span>


:[range]TOhtml <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>                                                <span id="%3ATOhtml" class="t">:TOhtml</span>
Converts the buffer shown in the current <a href="windows.txt.html#window" class="d">window</a> to HTML, opens the generated
HTML in <a href="insert.txt.html#a" class="d">a</a> new split window, and saves its contents to <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a>. If <a href="editing.txt.html#%7Bfile%7D" class="s">{file}</a> <a href="motion.txt.html#is" class="d">is</a> not
given, <a href="insert.txt.html#a" class="d">a</a> temporary file (created by <a href="vimfn.txt.html#tempname%28%29" class="l">tempname()</a><a href="motion.txt.html#%29" class="d">)</a> <a href="motion.txt.html#is" class="d">is</a> used.


tohtml.tohtml({winid}, <span class="s">{opt}</span>)                         <span id="tohtml.tohtml.tohtml%28%29" class="t">tohtml.tohtml.tohtml()</span>
    Converts the buffer shown in the <a href="windows.txt.html#window" class="d">window</a> <span class="s">{winid}</span> to HTML and returns the
    output <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vimeval.txt.html#list" class="d">list</a> of string.

<span class="h">    Parameters: </span>
      • <span class="s">{winid}</span>  (`integer?`) Window to convert (defaults to current window)
      • <span class="s">{opt}</span>    (`table?`) Optional parameters.
                 • <span class="s">{title}</span>? (`string|false`, default: buffer name) Title <a href="tagsrch.txt.html#tag" class="d">tag</a>
                   to set in the generated HTML code.
                 • <span class="s">{number_lines}</span>? (`boolean`, default: <span class="e">false</span>) Show line
                   numbers.
                 • <span class="s">{font}</span>? (`string[]|string`, default: <span class="e">guifont</span>) Fonts to
                   use.
                 • <span class="s">{width}</span>? (`integer`, default: <a href="options.txt.html#%27textwidth%27" class="o">'textwidth'</a> if non-zero or
                   <a href="windows.txt.html#window" class="d">window</a> width otherwise) Width used <a href="luaref.txt.html#for" class="d">for</a> items which are
                   either right aligned or repeat <a href="insert.txt.html#a" class="d">a</a> character infinitely.
                 • <span class="s">{range}</span>? (`integer[]`, default: entire buffer) Range of
                   rows to use.

<span class="h">    Return: </span>
        (`string[]`)


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:


</pre>
</div>
</main>
<p>Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
</p>
<footer>This site is maintained by Carlo Teubner (<i>(my first name) at cteubner dot net</i>).</footer>
</body>
</html>