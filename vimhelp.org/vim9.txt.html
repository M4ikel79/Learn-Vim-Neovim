<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="color-scheme" content="light dark">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Vim help pages, always up-to-date">
<title>Vim: vim9.txt</title>
<link rel="shortcut icon" href="s/KXPobNpJBGAI5V1t/favicon-vim.ico">
<!-- favicon is based on http://amnoid.de/tmp/vim_solidbright_512.png and is used with permission by its author -->

<link rel="stylesheet" href="s/MsMIu46igYudff1x/tom-select.min.css">
<script defer src="s/RLcAbtLBYX-q5me0/tom-select.base.min.js"></script>

<link rel="stylesheet" href="s/QRMkrs52-wJfIQ-w/vimhelp.css">
<noscript><link rel="stylesheet" href="s/eRFCn9A-K4lmzV_A/noscript.css"></noscript>
<script defer src="s/KpwrKyx19dtnhPoe/vimhelp.js"></script>
</head>
<body>




<div class="bar">
  <div class="ql">Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
&middot; <a href="vim_faq.txt.html">faq</a>
</div>
  <div class="tag srch need-js">
    <select id="vh-select-tag"></select>
    <div class="placeholder">Go to keyword<span class="not-mobile">&nbsp;(shortcut: <kbd>k</kbd>)</span></div>
  </div>
  <form class="site srch" action="https://duckduckgo.com" method="get" target="_blank" rel="noopener noreferrer">
    <input type="hidden" name="sites" value="vimhelp.org">
    <input type="search" name="q" id="vh-srch-input" placeholder="Site search">
    <div class="placeholder need-js">Site search<span class="not-mobile">&nbsp;(shortcut: <kbd>s</kbd>)</span></div>
  </form>
  <div id="theme-switcher" class="need-js">
  <button id="theme-current" title="Switch theme">Theme</button>
  <div id="theme-dropdown"><ul>
    <li><button id="theme-native" title="Switch to native theme">Native</button></li>
    <li><button id="theme-light" title="Switch to light theme">Light</button></li>
    <li><button id="theme-dark" title="Switch to dark theme">Dark</button></li>
  </ul></div>
</div>

</div>

<main>
<div id="vh-sidebar">
<ul><li><a href="vim9.txt.html#">↑Top↑</a></li>
<li><a href="vim9.txt.html#Vim9-script">What is Vim9 script?</a></li>
<li><a href="vim9.txt.html#vim9-differences">Differences from legacy Vim script</a></li>
<li><a href="vim9.txt.html#fast-functions">New style functions</a></li>
<li><a href="vim9.txt.html#vim9-types">Types</a></li>
<li><a href="vim9.txt.html#generic-functions">generic-functions</a></li>
<li><a href="vim9.txt.html#_namespace--import-and-exp">Namespace, Import and Export</a></li>
<li><a href="vim9.txt.html#vim9-classes">Classes and interfaces</a></li>
<li><a href="vim9.txt.html#vim9-rationale">Rationale</a></li>
</ul>
</div>
<div id="vh-content">
<pre>
<span id="vim9.txt" class="t">vim9.txt</span>  	For <span class="i">Vim version 9.1.</span>  Last change: 2025 Nov 30


		  <span class="i">VIM REFERENCE MANUAL	  by Bram Moolenaar</span>


<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> commands and expressions.			<span id="Vim9" class="t">Vim9</span> <span id="vim9" class="t">vim9</span>

Most <a href="eval.txt.html#expression" class="d">expression</a> <a href="helphelp.txt.html#help" class="d">help</a> <a href="motion.txt.html#is" class="d">is</a> in <a href="eval.txt.html#eval.txt" class="l">eval.txt</a><a href="repeat.txt.html#." class="d">.</a>  This file <a href="motion.txt.html#is" class="d">is</a> about the new <a href="syntax.txt.html#syntax" class="d">syntax</a> and
features in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script.



1.  What <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script?		<a href="vim9.txt.html#Vim9-script" class="l">Vim9-script</a>
2.  Differences				<a href="vim9.txt.html#vim9-differences" class="l">vim9-differences</a>
3.  New style <a href="eval.txt.html#functions" class="d">functions</a>			<a href="vim9.txt.html#fast-functions" class="l">fast-functions</a>
4.  Types				<a href="vim9.txt.html#vim9-types" class="l">vim9-types</a>
5.  Generic <a href="eval.txt.html#functions" class="d">functions</a>			<a href="vim9.txt.html#generic-functions" class="l">generic-functions</a>
6.  Namespace, Import and Export	<a href="vim9.txt.html#vim9script" class="l">vim9script</a>
7.  Classes and interfaces		<a href="vim9.txt.html#vim9-classes" class="l">vim9-classes</a>
8.  Rationale				<a href="vim9.txt.html#vim9-rationale" class="l">vim9-rationale</a>


<span class="h">------------------------------------------------------------------------------</span>

  <span class="n">NOTE:</span> In this <a href="vim9.txt.html#vim9.txt" class="d">vim9.txt</a> <a href="helphelp.txt.html#help" class="d">help</a> file, the <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> code blocks beginning
	with <span class="e">vim9script</span> (and individual lines <a href="starting.txt.html#starting" class="d">starting</a> with <span class="e">vim9cmd</span>) are
	<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighted.  Also, they are sourceable, meaning
	you can run them to see what they output.  To source them, use
	<span class="e">:'&lt;,'&gt;source</span> (see <a href="repeat.txt.html#%3Asource-range" class="l">:source-range</a>), which <a href="motion.txt.html#is" class="d">is</a> done by visually
	selecting the line(s) with <a href="visual.txt.html#V" class="l">V</a> and typing <span class="e">:so</span>.  For example, try <a href="motion.txt.html#it" class="d">it</a>
	on the following <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script: &gt;vim9

		<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
		echowindow "Welcome to <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script!"
<a href="change.txt.html#%3C" class="d">&lt;</a>
	There are also code examples that should not be sourced <a href="motion.txt.html#-" class="d">-</a> they
	explain concepts that don't require <a href="insert.txt.html#a" class="d">a</a> sourceable example.  Such code
	blocks appear in generic code <a href="syntax.txt.html#syntax" class="d">syntax</a> highlighting, like this: 
<span class="e"></span>
<span class="e">		def ThisFunction()          # script-local</span>
<span class="e">		def g:ThatFunction()        # global</span>
<span class="e">		export def Function()       # for import and import autoload</span>
<span class="e"></span>
<span class="h">==============================================================================</span>

1. What <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script?					<span id="Vim9-script" class="t">Vim9-script</span>

Vim <a href="usr_41.txt.html#script" class="d">script</a> has been growing over time, while preserving backwards
compatibility.  That means bad choices from the past often can't be changed
and compatibility with <a href="intro.txt.html#Vi" class="d">Vi</a> restricts possible solutions.  Execution <a href="motion.txt.html#is" class="d">is</a> quite
slow, each line <a href="motion.txt.html#is" class="d">is</a> parsed every time <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> executed.

The main goal of <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> to drastically improve performance.  This <a href="motion.txt.html#is" class="d">is</a>
accomplished by compiling commands into instructions that can be efficiently
executed.  An increase in execution speed of 10 to 100 times can be expected.

<a href="insert.txt.html#A" class="d">A</a> secondary goal <a href="motion.txt.html#is" class="d">is</a> to avoid Vim-specific constructs and get closer to
commonly used programming languages, such <a href="motion.txt.html#as" class="d">as</a> JavaScript, TypeScript and Java.

The performance improvements can only be achieved by not being 100% backwards
compatible.  For example, making function arguments available in the "a:"
dictionary adds quite <a href="insert.txt.html#a" class="d">a</a> lot of overhead.  In <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> function this dictionary
<a href="motion.txt.html#is" class="d">is</a> not available.  Other differences are more subtle, such <a href="motion.txt.html#as" class="d">as</a> how <a href="message.txt.html#errors" class="d">errors</a> are
handled.

The <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> and semantics are used in:
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> function defined with the <span class="e">:def</span> command
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> file where the first command <a href="motion.txt.html#is" class="d">is</a> <span class="e">vim9script</span>
<a href="motion.txt.html#-" class="d">-</a> an <a href="autocmd.txt.html#autocommand" class="d">autocommand</a> defined in the context of the above
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> command prefixed with the <span class="e">vim9cmd</span> command modifier

When using <span class="e">:function</span> in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> file the legacy <a href="syntax.txt.html#syntax" class="d">syntax</a> <a href="motion.txt.html#is" class="d">is</a> used, with
the highest <a href="eval.txt.html#scriptversion" class="l">scriptversion</a><a href="repeat.txt.html#." class="d">.</a>  However, this can be confusing and <a href="motion.txt.html#is" class="d">is</a> therefore
discouraged.

<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> and legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> can be mixed.  There <a href="motion.txt.html#is" class="d">is</a> no requirement to
rewrite old scripts, they keep working <a href="motion.txt.html#as" class="d">as</a> before.  You may want to use <a href="insert.txt.html#a" class="d">a</a> few
<span class="e">:def</span> <a href="eval.txt.html#functions" class="d">functions</a> for code that needs to be fast.

:vim9[cmd] <span class="s">{cmd}</span>				<span id="%3Avim9" class="t">:vim9</span> <span id="%3Avim9cmd" class="t">:vim9cmd</span> <span id="E1164" class="t">E1164</span>
		Evaluate and execute <span class="s">{cmd}</span> using <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> and
		semantics.  Useful when typing <a href="insert.txt.html#a" class="d">a</a> command and in <a href="insert.txt.html#a" class="d">a</a> legacy
		<a href="usr_41.txt.html#script" class="d">script</a> or function.

:leg[acy] <span class="s">{cmd}</span>					<span id="%3Aleg" class="t">:leg</span> <span id="%3Alegacy" class="t">:legacy</span> <span id="E1189" class="t">E1189</span> <span id="E1234" class="t">E1234</span>
		Evaluate and execute <span class="s">{cmd}</span> using legacy <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> and
		semantics.  Only useful in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> or <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#%3Adef" class="d">:def</a> function.
		<span class="n">Note</span> that <span class="s">{cmd}</span> cannot use local variables, since <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> parsed
		with legacy <a href="eval.txt.html#expression" class="d">expression</a> syntax.

See some examples of <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#at" class="d">at</a> <a href="usr_52.txt.html#52.6" class="l">52.6</a><a href="repeat.txt.html#." class="d">.</a>
<span class="h">==============================================================================</span>

2. Differences from legacy Vim <a href="usr_41.txt.html#script" class="d">script</a>			<span id="vim9-differences" class="t">vim9-differences</span>

<span class="h">Overview </span>
							<span id="E1146" class="t">E1146</span>
Brief summary of the differences you will most often encounter when using <a href="vim9.txt.html#Vim9" class="d">Vim9</a>
<a href="usr_41.txt.html#script" class="d">script</a> and <span class="e">:def</span> functions; details are below:
<a href="motion.txt.html#-" class="d">-</a> Comments start with #, not "<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	echo "hello"   # comment</span>
<a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> for line continuation <a href="motion.txt.html#is" class="d">is</a> hardly ever needed: 
<span class="e">	echo "hello "</span>
<span class="e">	     .. yourName</span>
<span class="e">	     .. ", how are you?"</span>
<a href="motion.txt.html#-" class="d">-</a> White <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> required in many places to improve readability,
  see <a href="vim9.txt.html#vim9-white-space" class="l">vim9-white-space</a><a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> Assign values without <span class="e">:let</span> <span id="E1126" class="t">E1126</span> <a href="motion.txt.html#%2C" class="d">,</a> declare <a href="eval.txt.html#variables" class="d">variables</a> with <span class="e">:var</span>: 
<span class="e">	var count = 0</span>
<span class="e">	count += 3</span>
<a href="motion.txt.html#-" class="d">-</a> Constants can be declared with <span class="e">:final</span> and <span class="e">:const</span>: 
<span class="e">	final matches = []		  # add to the list later</span>
<span class="e">	const names = ['Betty', 'Peter']  # cannot be changed</span>
<a href="motion.txt.html#-" class="d">-</a> <span class="e">:final</span> cannot be used <a href="motion.txt.html#as" class="d">as</a> an abbreviation of <span class="e">:finally</span>.
<a href="motion.txt.html#-" class="d">-</a> Variables and <a href="eval.txt.html#functions" class="d">functions</a> are <a href="map.txt.html#script-local" class="d">script-local</a> by default.
<a href="motion.txt.html#-" class="d">-</a> Functions are declared with argument types and return type: 
<span class="e">	def CallMe(count: number, message: string): bool</span>
<a href="motion.txt.html#-" class="d">-</a> Call <a href="eval.txt.html#functions" class="d">functions</a> without <span class="e">:call</span>: 
<span class="e">	writefile(['done'], 'file.txt')</span>
<a href="motion.txt.html#-" class="d">-</a> You cannot use old <a href="intro.txt.html#Ex" class="d">Ex</a> commands:
	<span class="e">:Print</span>
	<span class="e">:append</span>
	<span class="e">:change</span>
	<span class="e">:d</span>  directly followed by 'd' or 'p'.
	<span class="e">:insert</span>
	<span class="e">:k</span>
	<span class="e">:mode</span>
	<span class="e">:open</span>
	<span class="e">:s</span>  with only flags
	<span class="e">:t</span>
	<span class="e">:xit</span>
<a href="motion.txt.html#-" class="d">-</a> Some commands, especially those used for flow control, cannot be shortened.
  E.g., <span class="e">:throw</span> cannot be written <a href="motion.txt.html#as" class="d">as</a> <span class="e">:th</span>.  <span id="vim9-no-shorten" class="t">vim9-no-shorten</span>
<a href="motion.txt.html#-" class="d">-</a> You cannot use curly-braces names.
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#A" class="d">A</a> range before <a href="insert.txt.html#a" class="d">a</a> command <a href="vim_faq.txt.html#must" class="d">must</a> be prefixed with <a href="insert.txt.html#a" class="d">a</a> colon: 
<span class="e">	:%s/this/that</span>
<a href="motion.txt.html#-" class="d">-</a> Executing <a href="insert.txt.html#a" class="d">a</a> register with "<a href="eval.txt.html#%40r" class="d">@r</a>" does not work, you can prepend <a href="insert.txt.html#a" class="d">a</a> colon or use
  <span class="e">:exe</span>: 
<span class="e">	:exe @a</span>
<a href="motion.txt.html#-" class="d">-</a> Unless mentioned specifically, the highest <a href="eval.txt.html#scriptversion" class="l">scriptversion</a> <a href="motion.txt.html#is" class="d">is</a> used.
<a href="motion.txt.html#-" class="d">-</a> When defining an <a href="eval.txt.html#expression" class="d">expression</a> mapping, the <a href="eval.txt.html#expression" class="d">expression</a> will be evaluated in the
  context of the <a href="usr_41.txt.html#script" class="d">script</a> where <a href="motion.txt.html#it" class="d">it</a> was defined.
<a href="motion.txt.html#-" class="d">-</a> When indexing <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> the <a href="index.txt.html#index" class="d">index</a> <a href="motion.txt.html#is" class="d">is</a> counted in characters, not bytes:
  <a href="vim9.txt.html#vim9-string-index" class="l">vim9-string-index</a>
<a href="motion.txt.html#-" class="d">-</a> Some possibly unexpected differences: <a href="vim9.txt.html#vim9-gotchas" class="l">vim9-gotchas</a><a href="repeat.txt.html#." class="d">.</a>


<span class="h">Comments starting with # </span>

In legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> comments start with double <a href="change.txt.html#quote." class="d">quote.</a>  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a>
comments start with #. 
<span class="e">	# declarations</span>
<span class="e">	var count = 0  # number of occurrences</span>
<span class="e"></span>
The reason <a href="motion.txt.html#is" class="d">is</a> that <a href="insert.txt.html#a" class="d">a</a> double <a href="change.txt.html#quote" class="d">quote</a> can also be the start of <a href="insert.txt.html#a" class="d">a</a> string. In many
places, especially halfway through an <a href="eval.txt.html#expression" class="d">expression</a> with <a href="insert.txt.html#a" class="d">a</a> line break, it's hard
to tell what the meaning is, since both <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> and <a href="insert.txt.html#a" class="d">a</a> comment can be followed
by arbitrary text.  To avoid confusion only <a href="pattern.txt.html#%23" class="d">#</a> comments are recognized.  This
<a href="motion.txt.html#is" class="d">is</a> the same <a href="motion.txt.html#as" class="d">as</a> in shell scripts and <a href="if_pyth.txt.html#Python" class="d">Python</a> programs.

In <a href="intro.txt.html#Vi" class="d">Vi</a> <a href="pattern.txt.html#%23" class="d">#</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> command to <a href="eval.txt.html#list" class="d">list</a> text with numbers.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> you can use
<span class="e">:number</span> for that. 
<span class="e">	:101 number</span>
<span class="e"></span>
To improve readability there <a href="vim_faq.txt.html#must" class="d">must</a> be <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#space" class="d">space</a> between <a href="insert.txt.html#a" class="d">a</a> command and the <a href="pattern.txt.html#%23" class="d">#</a>
that starts <a href="insert.txt.html#a" class="d">a</a> comment: 
<span class="e">	var name = value # comment</span>
<span class="e">	var name = value# error!</span>
							<span id="E1170" class="t">E1170</span>
Do not start <a href="insert.txt.html#a" class="d">a</a> comment with #{, <a href="motion.txt.html#it" class="d">it</a> looks like the legacy dictionary literal
and produces an error where this might be confusing.  #{{ or #{{{ are OK,
these can be used to start <a href="insert.txt.html#a" class="d">a</a> fold.

When <a href="starting.txt.html#starting" class="d">starting</a> to read <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> file Vim doesn't know <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#Vim9" class="l">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> until
the <span class="e">vim9script</span> command <a href="motion.txt.html#is" class="d">is</a> found.  Until that point you would need to use
legacy comments: 
<span class="e">	" legacy comment</span>
<span class="e">	vim9script</span>
<span class="e">	# Vim9 comment</span>
<span class="e"></span>
That looks ugly, better <a href="change.txt.html#put" class="d">put</a> <span class="e">vim9script</span> in the very first line: 
<span class="e">	vim9script</span>
<span class="e">	# Vim9 comment</span>
<span class="e"></span>
In legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="pattern.txt.html#%23" class="d">#</a> <a href="motion.txt.html#is" class="d">is</a> also used for the alternate file name.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a>
<a href="usr_41.txt.html#script" class="d">script</a> you need to use %% instead.  Instead of ## use %%% (stands for all
arguments).


<span class="h">Vim9 functions </span>
							<span id="E1099" class="t">E1099</span>
<a href="insert.txt.html#A" class="d">A</a> function defined with <span class="e">:def</span> <a href="motion.txt.html#is" class="d">is</a> compiled.  Execution <a href="motion.txt.html#is" class="d">is</a> many times faster,
often 10 to 100 times.

Many <a href="message.txt.html#errors" class="d">errors</a> are already found when compiling, before the function <a href="motion.txt.html#is" class="d">is</a> executed.
The <a href="syntax.txt.html#syntax" class="d">syntax</a> <a href="motion.txt.html#is" class="d">is</a> strict, to enforce code that <a href="motion.txt.html#is" class="d">is</a> <a href="starting.txt.html#easy" class="d">easy</a> to read and understand.

Compilation <a href="motion.txt.html#is" class="d">is</a> done when any of these <a href="motion.txt.html#is" class="d">is</a> encountered:
<a href="motion.txt.html#-" class="d">-</a> the first time the function <a href="motion.txt.html#is" class="d">is</a> called
<a href="motion.txt.html#-" class="d">-</a> when the <span class="e">:defcompile</span> command <a href="motion.txt.html#is" class="d">is</a> encountered in the <a href="usr_41.txt.html#script" class="d">script</a> after the
  function was defined
<a href="motion.txt.html#-" class="d">-</a> <span class="e">:disassemble</span> <a href="motion.txt.html#is" class="d">is</a> used for the function.
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> function that <a href="motion.txt.html#is" class="d">is</a> compiled calls the function or uses <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> function
  <a href="intro.txt.html#reference" class="d">reference</a> (so that the argument and return types can be checked)
						<span id="E1091" class="t">E1091</span> <span id="E1191" class="t">E1191</span>
If compilation fails <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> not tried again on the next call, instead this
error <a href="motion.txt.html#is" class="d">is</a> given: "E1091: Function <a href="motion.txt.html#is" class="d">is</a> not compiled: <span class="s">{name}</span>"<a href="repeat.txt.html#." class="d">.</a>
Compilation will fail when encountering <a href="insert.txt.html#a" class="d">a</a> user command that has not been
created yet.  In this <a href="change.txt.html#case" class="d">case</a> you can call <span class="e">execute()</span> to invoke <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#at" class="d">at</a> runtime. 
<span class="e">	def MyFunc()</span>
<span class="e">	  execute('DefinedLater')</span>
<span class="e">	enddef</span>
<span class="e"></span>
<span class="e">:def</span> has no <a href="options.txt.html#options" class="d">options</a> like <span class="e">:function</span> does: "range"<a href="motion.txt.html#%2C" class="d">,</a> "abort"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="eval.txt.html#dict" class="d">dict</a>" or
"<a href="eval.txt.html#closure" class="d">closure</a>"<a href="repeat.txt.html#." class="d">.</a>  <a href="insert.txt.html#A" class="d">A</a> <span class="e">:def</span> function always aborts on an error (unless <span class="e">:silent!</span> was
used for the command or the error was caught <a href="insert.txt.html#a" class="d">a</a> <span class="e">:try</span> block), does not get <a href="insert.txt.html#a" class="d">a</a>
range passed, cannot be <a href="insert.txt.html#a" class="d">a</a> "<a href="eval.txt.html#dict" class="d">dict</a>" function, and can always be <a href="insert.txt.html#a" class="d">a</a> closure.
						<span id="vim9-no-dict-function" class="t">vim9-no-dict-function</span> <span id="E1182" class="t">E1182</span>
You can use <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="vim9class.txt.html#Class" class="d">Class</a> <a href="motion.txt.html#%28" class="d">(</a><a href="vim9class.txt.html#Vim9-class" class="l">Vim9-class</a><a href="motion.txt.html#%29" class="d">)</a> instead of <a href="insert.txt.html#a" class="d">a</a> "<a href="eval.txt.html#dict" class="d">dict</a> function"<a href="repeat.txt.html#." class="d">.</a>
You can also pass the dictionary explicitly: 
<span class="e">	def DictFunc(self: dict&lt;any&gt;, arg: string)</span>
<span class="e">	   echo self[arg]</span>
<span class="e">	enddef</span>
<span class="e">	var ad = {item: 'value', func: DictFunc}</span>
<span class="e">	ad.func(ad, 'item')</span>
<span class="e"></span>
You can call <a href="insert.txt.html#a" class="d">a</a> legacy <a href="eval.txt.html#dict" class="d">dict</a> function though: 
<span class="e">	func Legacy() dict</span>
<span class="e">	  echo self.value</span>
<span class="e">	endfunc</span>
<span class="e">	def CallLegacy()</span>
<span class="e">	  var d = {func: Legacy, value: 'text'}</span>
<span class="e">	  d.func()</span>
<span class="e">	enddef</span>
<span class="e"></span>
The argument types and return type need to be specified.  The "any" type can
be used, type checking will then be done <a href="motion.txt.html#at" class="d">at</a> runtime, like with legacy
functions.
							<span id="E1106" class="t">E1106</span>
Arguments are accessed by name, without "a:"<a href="motion.txt.html#%2C" class="d">,</a> just like any other language.
There <a href="motion.txt.html#is" class="d">is</a> no "a:" dictionary or "<a href="userfunc.txt.html#a%3A000" class="d">a:000</a>" list.
			<span id="vim9-variable-arguments" class="t">vim9-variable-arguments</span> <span id="E1055" class="t">E1055</span> <span id="E1160" class="t">E1160</span> <span id="E1180" class="t">E1180</span>
Variable arguments are defined <a href="motion.txt.html#as" class="d">as</a> the last argument, with <a href="insert.txt.html#a" class="d">a</a> name and have <a href="insert.txt.html#a" class="d">a</a>
<a href="eval.txt.html#list" class="d">list</a> type, similar to TypeScript.  For example, <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> of numbers: 
<span class="e">	def MyFunc(...itemlist: list&lt;number&gt;)</span>
<span class="e">	   for item in itemlist</span>
<span class="e">	     ...</span>
<span class="e"></span>
When <a href="insert.txt.html#a" class="d">a</a> function argument <a href="motion.txt.html#is" class="d">is</a> optional (it has <a href="insert.txt.html#a" class="d">a</a> default value) passing <span class="e">v:none</span>
<a href="motion.txt.html#as" class="d">as</a> the argument results in using the default value.  This <a href="motion.txt.html#is" class="d">is</a> useful when you
want to specify <a href="insert.txt.html#a" class="d">a</a> value for an argument that comes after an argument that
should use its default value.  Example: 
<span class="e">	def MyFunc(one = 'one', last = 'last')</span>
<span class="e">	  ...</span>
<span class="e">	enddef</span>
<span class="e">	MyFunc(v:none, 'LAST')  # first argument uses default value 'one'</span>

					<span id="vim9-ignored-argument" class="t">vim9-ignored-argument</span> <span id="E1181" class="t">E1181</span>
The argument "<a href="motion.txt.html#_" class="d">_</a>" (an underscore) can be used to ignore the argument.  This <a href="motion.txt.html#is" class="d">is</a>
most useful in callbacks where you don't need it, but <a href="diff.txt.html#do" class="d">do</a> need to give an
argument to match the call.  E.g. when using <a href="builtin.txt.html#map%28%29" class="d">map()</a> two arguments are passed,
the key and the value, to ignore the key: 
<span class="e">	map(numberList, (_, v) =&gt; v * 2)</span>
There <a href="motion.txt.html#is" class="d">is</a> no error for using the "<a href="motion.txt.html#_" class="d">_</a>" argument multiple times.  No type needs to
be given.


<span class="h">Functions and variables are script-local by default </span>
							<span id="vim9-scopes" class="t">vim9-scopes</span>
When using <span class="e">:function</span> or <span class="e">:def</span> to specify <a href="insert.txt.html#a" class="d">a</a> new function <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level
in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, the function <a href="motion.txt.html#is" class="d">is</a> local to the script.  Like prefixing "s:" in
legacy script.  To define <a href="insert.txt.html#a" class="d">a</a> global function or variable the "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix <a href="vim_faq.txt.html#must" class="d">must</a>
be used.  For <a href="eval.txt.html#functions" class="d">functions</a> in <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> that <a href="motion.txt.html#is" class="d">is</a> to be imported and in an <a href="userfunc.txt.html#autoload" class="d">autoload</a>
<a href="usr_41.txt.html#script" class="d">script</a> "export" needs to be used for those to be used elsewhere. 
<span class="e">	def ThisFunction()          # script-local</span>
<span class="e">	def g:ThatFunction()        # global</span>
<span class="e">	export def Function()       # for import and import autoload</span>
						<span id="E1075" class="t">E1075</span>
When using <span class="e">:function</span> or <span class="e">:def</span> to specify <a href="insert.txt.html#a" class="d">a</a> nested function inside <a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span>
function and no namespace was given, this nested function <a href="motion.txt.html#is" class="d">is</a> local to the code
block <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> defined in.  It cannot be used in <span class="e">function()</span> with <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a>
argument, pass the function <a href="intro.txt.html#reference" class="d">reference</a> itself: 
<span class="e">	def Outer()</span>
<span class="e">	  def Inner()</span>
<span class="e">	    echo 'inner'</span>
<span class="e">	  enddef</span>
<span class="e">	  var Fok = function(Inner)     # OK</span>
<span class="e">	  var Fbad = function('Inner')  # does not work</span>
<span class="e"></span>
Detail: this <a href="motion.txt.html#is" class="d">is</a> because "Inner" will actually become <a href="insert.txt.html#a" class="d">a</a> function <a href="intro.txt.html#reference" class="d">reference</a> to <a href="insert.txt.html#a" class="d">a</a>
function with <a href="insert.txt.html#a" class="d">a</a> generated name.

It <a href="motion.txt.html#is" class="d">is</a> not possible to define <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#script-local" class="d">script-local</a> function in <a href="insert.txt.html#a" class="d">a</a> function.  You can
define <a href="insert.txt.html#a" class="d">a</a> local function and assign <a href="motion.txt.html#it" class="d">it</a> to <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#script-local" class="d">script-local</a> <a href="eval.txt.html#Funcref" class="d">Funcref</a> (it <a href="vim_faq.txt.html#must" class="d">must</a> have
been declared <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level).  It <a href="motion.txt.html#is" class="d">is</a> possible to define <a href="insert.txt.html#a" class="d">a</a> global
function by using the "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix.

When referring to <a href="insert.txt.html#a" class="d">a</a> function and no "s:" or "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix <a href="motion.txt.html#is" class="d">is</a> used, Vim will
search for the function:
<a href="motion.txt.html#-" class="d">-</a> in the function scope, in block scopes
<a href="motion.txt.html#-" class="d">-</a> in the <a href="usr_41.txt.html#script" class="d">script</a> scope

Imported <a href="eval.txt.html#functions" class="d">functions</a> are found with the prefix from the <span class="e">:import</span> command.

Since <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#script-local" class="d">script-local</a> function <a href="intro.txt.html#reference" class="d">reference</a> can be used without "s:" the name <a href="vim_faq.txt.html#must" class="d">must</a>
start with an upper <a href="change.txt.html#case" class="d">case</a> <a href="print.txt.html#letter" class="d">letter</a> even when using the "s:" prefix.  In legacy
<a href="usr_41.txt.html#script" class="d">script</a> "s:funcref" could be used, because <a href="motion.txt.html#it" class="d">it</a> could not be referred to with
"funcref"<a href="repeat.txt.html#." class="d">.</a>  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#it" class="d">it</a> can, therefore "s:Funcref" <a href="vim_faq.txt.html#must" class="d">must</a> be used to avoid
that the name interferes with builtin functions.
						<span id="vim9-s-namespace" class="t">vim9-s-namespace</span> <span id="E1268" class="t">E1268</span>
The use of the "s:" prefix <a href="motion.txt.html#is" class="d">is</a> not supported <a href="motion.txt.html#at" class="d">at</a> the <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> level.  All
<a href="eval.txt.html#functions" class="d">functions</a> and <a href="eval.txt.html#variables" class="d">variables</a> without <a href="insert.txt.html#a" class="d">a</a> prefix are script-local.

In <a href="vim9.txt.html#%3Adef" class="d">:def</a> <a href="eval.txt.html#functions" class="d">functions</a> the use of "s:" depends on the script: Script-local
<a href="eval.txt.html#variables" class="d">variables</a> and <a href="eval.txt.html#functions" class="d">functions</a> in <a href="insert.txt.html#a" class="d">a</a> legacy <a href="usr_41.txt.html#script" class="d">script</a> <a href="diff.txt.html#do" class="d">do</a> use "s:"<a href="motion.txt.html#%2C" class="d">,</a> while in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a>
they <a href="diff.txt.html#do" class="d">do</a> not use "s:"<a href="repeat.txt.html#." class="d">.</a>  This matches what you see in the rest of the file.

In legacy <a href="eval.txt.html#functions" class="d">functions</a> the use of "s:" for <a href="usr_41.txt.html#script" class="d">script</a> items <a href="motion.txt.html#is" class="d">is</a> required, <a href="motion.txt.html#as" class="d">as</a> before.
No matter if the <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> or legacy.

In all cases the function <a href="vim_faq.txt.html#must" class="d">must</a> be defined before used.  That <a href="motion.txt.html#is" class="d">is</a> when <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a>
called, when <span class="e">:defcompile</span> causes <a href="motion.txt.html#it" class="d">it</a> to be compiled, or when code that calls
<a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> being compiled (to figure out the return type).

The result <a href="motion.txt.html#is" class="d">is</a> that <a href="eval.txt.html#functions" class="d">functions</a> and <a href="eval.txt.html#variables" class="d">variables</a> without <a href="insert.txt.html#a" class="d">a</a> namespace can usually be
found in the script, either defined there or imported.  Global <a href="eval.txt.html#functions" class="d">functions</a> and
<a href="eval.txt.html#variables" class="d">variables</a> could be defined anywhere (good luck finding out where!  You can
often see where <a href="motion.txt.html#it" class="d">it</a> was last set using <a href="various.txt.html#%3Averbose" class="l">:verbose</a>).
							<span id="E1102" class="t">E1102</span>
Global <a href="eval.txt.html#functions" class="d">functions</a> can still be defined and deleted <a href="motion.txt.html#at" class="d">at</a> nearly any time.  In
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="map.txt.html#script-local" class="d">script-local</a> <a href="eval.txt.html#functions" class="d">functions</a> are defined once when the <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> sourced
and cannot be deleted or replaced by itself (it can be by reloading the
script).

When compiling <a href="insert.txt.html#a" class="d">a</a> function and <a href="insert.txt.html#a" class="d">a</a> function call <a href="motion.txt.html#is" class="d">is</a> encountered for <a href="insert.txt.html#a" class="d">a</a> function
that <a href="motion.txt.html#is" class="d">is</a> not (yet) defined, the <a href="autocmd.txt.html#FuncUndefined" class="l">FuncUndefined</a> <a href="autocmd.txt.html#autocommand" class="d">autocommand</a> <a href="motion.txt.html#is" class="d">is</a> not triggered.
You can use an <a href="userfunc.txt.html#autoload" class="d">autoload</a> function if needed, or call <a href="insert.txt.html#a" class="d">a</a> legacy function and have
<a href="autocmd.txt.html#FuncUndefined" class="l">FuncUndefined</a> triggered there.


<span class="h">Reloading a Vim9 script clears functions and variables by default </span>
						<span id="vim9-reload" class="t">vim9-reload</span> <span id="E1149" class="t">E1149</span> <span id="E1150" class="t">E1150</span>
When loading <a href="insert.txt.html#a" class="d">a</a> legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="insert.txt.html#a" class="d">a</a> second time nothing <a href="motion.txt.html#is" class="d">is</a> removed, the
commands will replace existing <a href="eval.txt.html#variables" class="d">variables</a> and functions, create new ones, and
leave removed things hanging around.

When loading <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="insert.txt.html#a" class="d">a</a> second time all existing <a href="map.txt.html#script-local" class="d">script-local</a> <a href="eval.txt.html#functions" class="d">functions</a>
and <a href="eval.txt.html#variables" class="d">variables</a> are deleted, thus you start with <a href="insert.txt.html#a" class="d">a</a> clean slate.  This <a href="motion.txt.html#is" class="d">is</a> useful
if you are developing <a href="insert.txt.html#a" class="d">a</a> <a href="usr_05.txt.html#plugin" class="d">plugin</a> and want to try <a href="insert.txt.html#a" class="d">a</a> new version.  If you renamed
something you don't have to worry about the old name still hanging around.

If you <a href="diff.txt.html#do" class="d">do</a> want to keep items, use: 
<span class="e">	vim9script noclear</span>
<span class="e"></span>
You want to use this in scripts that use <a href="insert.txt.html#a" class="d">a</a> <span class="e">finish</span> command to bail out <a href="motion.txt.html#at" class="d">at</a>
some point when loaded again.  E.g. when <a href="insert.txt.html#a" class="d">a</a> buffer local option <a href="motion.txt.html#is" class="d">is</a> set to <a href="insert.txt.html#a" class="d">a</a>
function, the function does not need to be defined more than once: 
<span class="e">	vim9script noclear</span>
<span class="e">	setlocal completefunc=SomeFunc</span>
<span class="e">	if exists('*SomeFunc')</span>
<span class="e">	  finish</span>
<span class="e">	endif</span>
<span class="e">	def SomeFunc()</span>
<span class="e">	....</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">Variable declarations with :var, :final and :const </span>
				<span id="vim9-declaration" class="t">vim9-declaration</span> <span id="%3Avar" class="t">:var</span> <span id="E1079" class="t">E1079</span>
				<span id="E1017" class="t">E1017</span> <span id="E1020" class="t">E1020</span> <span id="E1054" class="t">E1054</span> <span id="E1087" class="t">E1087</span> <span id="E1124" class="t">E1124</span>
Local <a href="eval.txt.html#variables" class="d">variables</a> need to be declared with <span class="e">:var</span>.  Local constants need to be
declared with <span class="e">:final</span> or <span class="e">:const</span>.  We refer to both <a href="motion.txt.html#as" class="d">as</a> "<a href="eval.txt.html#variables" class="d">variables</a>" in this
section.

Variables can be local to <a href="insert.txt.html#a" class="d">a</a> script, function or code block: 
<span class="e">	vim9script</span>
<span class="e">	var script_var = 123</span>
<span class="e">	def SomeFunc()</span>
<span class="e">	  var func_var = script_var</span>
<span class="e">	  if cond</span>
<span class="e">	    var block_var = func_var</span>
<span class="e">	  ...</span>
<span class="e"></span>
The <a href="eval.txt.html#variables" class="d">variables</a> are only visible in the block where they are defined and nested
blocks.  Once the block ends the variable <a href="motion.txt.html#is" class="d">is</a> no longer accessible: 
<span class="e">	if cond</span>
<span class="e">	   var inner = 5</span>
<span class="e">	else</span>
<span class="e">	   var inner = 0</span>
<span class="e">	endif</span>
<span class="e">	echo inner  # Error!</span>
<span class="e"></span>
The declaration <a href="vim_faq.txt.html#must" class="d">must</a> be done earlier: 
<span class="e">	var inner: number</span>
<span class="e">	if cond</span>
<span class="e">	   inner = 5</span>
<span class="e">	else</span>
<span class="e">	   inner = 0</span>
<span class="e">	endif</span>
<span class="e">	echo inner</span>
<span class="e"></span>
Although this <a href="motion.txt.html#is" class="d">is</a> shorter and faster for simple values: 
<span class="e">	var inner = 0</span>
<span class="e">	if cond</span>
<span class="e">	   inner = 5</span>
<span class="e">	endif</span>
<span class="e">	echo inner</span>
							<span id="E1025" class="t">E1025</span> <span id="E1128" class="t">E1128</span>
To intentionally hide <a href="insert.txt.html#a" class="d">a</a> variable from code that follows, <a href="insert.txt.html#a" class="d">a</a> block can be
used: 
<span class="e">	{</span>
<span class="e">	   var temp = 'temp'</span>
<span class="e">	   ...</span>
<span class="e">	}</span>
<span class="e">	echo temp  # Error!</span>
<span class="e"></span>
This <a href="motion.txt.html#is" class="d">is</a> especially useful in <a href="insert.txt.html#a" class="d">a</a> user command: 
<span class="e">	command -range Rename {</span>
<span class="e">		 var save = @a</span>
<span class="e">		 @a = 'some expression'</span>
<span class="e">		 echo 'do something with ' .. @a</span>
<span class="e">		 @a = save</span>
<span class="e">	    }</span>
<span class="e"></span>
And with autocommands: 
<span class="e">   au BufWritePre *.go {</span>
<span class="e">		 var save = winsaveview()</span>
<span class="e">		 silent! exe ':%! some formatting command'</span>
<span class="e">		 winrestview(save)</span>
<span class="e">	   }</span>
<span class="e"></span>
Although using <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#%3Adef" class="d">:def</a> function probably works better.

				<span id="E1022" class="t">E1022</span> <span id="E1103" class="t">E1103</span> <span id="E1130" class="t">E1130</span> <span id="E1131" class="t">E1131</span> <span id="E1133" class="t">E1133</span>
				<span id="E1134" class="t">E1134</span>
Declaring <a href="insert.txt.html#a" class="d">a</a> variable with <a href="insert.txt.html#a" class="d">a</a> type but without an initializer will initialize to
<a href="vim9.txt.html#false" class="d">false</a> (for bool), empty (for string, list, dict, etc.) or zero (for number,
any, etc.).  This matters especially when using the "any" type, the value will
default to the number zero.  For example, when declaring <a href="insert.txt.html#a" class="d">a</a> list, items can be
added: 
<span class="e">	var myList: list&lt;number&gt;</span>
<span class="e">	myList-&gt;add(7)</span>
<span class="e"></span>
Initializing <a href="insert.txt.html#a" class="d">a</a> variable to <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a> value, e.g. <span class="e">null_list</span>, differs from not
initializing the variable.  This throws an error: 
<span class="e">	var myList = null_list</span>
<span class="e">	myList-&gt;add(7)  # E1130: Cannot add to null list</span>
<span class="e"></span>
						<span id="E1016" class="t">E1016</span> <span id="E1052" class="t">E1052</span> <span id="E1066" class="t">E1066</span>
In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <span class="e">:let</span> cannot be used.  An existing variable <a href="motion.txt.html#is" class="d">is</a> assigned to
without any command.  The same for global, window, tab, buffer and Vim
variables, because they are not really declared.  Those can also be deleted
with <span class="e">:unlet</span>.
							<span id="E1065" class="t">E1065</span>
You cannot use <span class="e">:va</span> to declare <a href="insert.txt.html#a" class="d">a</a> variable, <a href="motion.txt.html#it" class="d">it</a> <a href="vim_faq.txt.html#must" class="d">must</a> be written with the full
name <span class="e">:var</span>.  Just to make sure <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> <a href="starting.txt.html#easy" class="d">easy</a> to read.
							<span id="E1178" class="t">E1178</span>
<span class="e">:lockvar</span> does not work on local variables.  Use <span class="e">:const</span> and <span class="e">:final</span>
instead.

The <span class="e">exists()</span> and <span class="e">exists_compiled()</span> <a href="eval.txt.html#functions" class="d">functions</a> <a href="diff.txt.html#do" class="d">do</a> not work on local <a href="eval.txt.html#variables" class="d">variables</a>
or arguments.
				<span id="E1006" class="t">E1006</span> <span id="E1041" class="t">E1041</span> <span id="E1167" class="t">E1167</span> <span id="E1168" class="t">E1168</span> <span id="E1213" class="t">E1213</span>
Variables, <a href="eval.txt.html#functions" class="d">functions</a> and function arguments cannot shadow previously defined
or imported <a href="eval.txt.html#variables" class="d">variables</a> and <a href="eval.txt.html#functions" class="d">functions</a> in the same <a href="usr_41.txt.html#script" class="d">script</a> file.
Variables may shadow <a href="intro.txt.html#Ex" class="d">Ex</a> commands, rename the variable if needed.

Global <a href="eval.txt.html#variables" class="d">variables</a> <a href="vim_faq.txt.html#must" class="d">must</a> be prefixed with "<a href="eval.txt.html#g%3A" class="d">g:</a>"<a href="motion.txt.html#%2C" class="d">,</a> also <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level. 
<span class="e">	vim9script</span>
<span class="e">	var script_local = 'text'</span>
<span class="e">	g:global = 'value'</span>
<span class="e">	var Funcref = g:ThatFunction</span>
<span class="e"></span>
Global <a href="eval.txt.html#functions" class="d">functions</a> <a href="vim_faq.txt.html#must" class="d">must</a> be prefixed with "<a href="eval.txt.html#g%3A" class="d">g:</a>"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	vim9script</span>
<span class="e">	def g:GlobalFunc(): string</span>
<span class="e">	  return 'text'</span>
<span class="e">	enddef</span>
<span class="e">	echo g:GlobalFunc()</span>
The "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix <a href="motion.txt.html#is" class="d">is</a> not needed for auto-load functions.

					<span id="vim9-function-defined-later" class="t">vim9-function-defined-later</span>
Although global <a href="eval.txt.html#functions" class="d">functions</a> can be called without the "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix, they <a href="vim_faq.txt.html#must" class="d">must</a>
exist when compiled.  By adding the "<a href="eval.txt.html#g%3A" class="d">g:</a>" prefix the function can be defined
later.  Example: 
<span class="e">	def CallPluginFunc()</span>
<span class="e">	  if exists('g:loaded_plugin')</span>
<span class="e">	    g:PluginFunc()</span>
<span class="e">	  endif</span>
<span class="e">	enddef</span>
<span class="e"></span>
If you <a href="diff.txt.html#do" class="d">do</a> <a href="motion.txt.html#it" class="d">it</a> like this, you get an error <a href="motion.txt.html#at" class="d">at</a> compile time that "PluginFunc"
does not exist, even when "g:loaded_plugin" does not exist: 
<span class="e">	def CallPluginFunc()</span>
<span class="e">	  if exists('g:loaded_plugin')</span>
<span class="e">	    PluginFunc()   # Error - function not found</span>
<span class="e">	  endif</span>
<span class="e">	enddef</span>
<span class="e"></span>
You can use <a href="builtin.txt.html#exists_compiled%28%29" class="d">exists_compiled()</a> to avoid the error, but then the function would
not be called, even when "g:loaded_plugin" <a href="motion.txt.html#is" class="d">is</a> defined later: 
<span class="e">	def CallPluginFunc()</span>
<span class="e">	  if exists_compiled('g:loaded_plugin')</span>
<span class="e">	    PluginFunc()   # Function may never be called</span>
<span class="e">	  endif</span>
<span class="e">	enddef</span>
<span class="e"></span>
Since `&amp;opt <a href="change.txt.html#%3D" class="d">=</a> value` <a href="motion.txt.html#is" class="d">is</a> now assigning <a href="insert.txt.html#a" class="d">a</a> value to option "opt"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="change.txt.html#%3A%26" class="d">:&amp;</a>" cannot be
used to repeat <a href="insert.txt.html#a" class="d">a</a> <span class="e">:substitute</span> command.
							<span id="vim9-unpack-ignore" class="t">vim9-unpack-ignore</span>
For an unpack assignment the underscore can be used to ignore <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> item,
similar to how <a href="insert.txt.html#a" class="d">a</a> function argument can be ignored: 
<span class="e">	[a, _, c] = theList</span>
To ignore any remaining items: 
<span class="e">	[a, b; _] = longList</span>
							<span id="E1163" class="t">E1163</span> <span id="E1080" class="t">E1080</span>
Declaring more than one variable <a href="motion.txt.html#at" class="d">at</a> <a href="insert.txt.html#a" class="d">a</a> time, using the unpack notation, <a href="motion.txt.html#is" class="d">is</a>
possible.  Each variable can have <a href="insert.txt.html#a" class="d">a</a> type or infer <a href="motion.txt.html#it" class="d">it</a> from the value: 
<span class="e">	var [v1: number, v2] = GetValues()</span>
Use this only when there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> with values, declaring one variable per
line <a href="motion.txt.html#is" class="d">is</a> much easier to read and change later.


<span class="h">Constants </span>
						<span id="vim9-const" class="t">vim9-const</span> <span id="vim9-final" class="t">vim9-final</span>
How constants work varies between languages.  Some consider <a href="insert.txt.html#a" class="d">a</a> variable that
can't be assigned another value <a href="insert.txt.html#a" class="d">a</a> constant.  JavaScript <a href="motion.txt.html#is" class="d">is</a> an example.  Others
also make the value immutable, thus when <a href="insert.txt.html#a" class="d">a</a> constant uses <a href="insert.txt.html#a" class="d">a</a> list, the <a href="eval.txt.html#list" class="d">list</a>
cannot be changed.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> we can use both.
							<span id="E1021" class="t">E1021</span> <span id="E1307" class="t">E1307</span>
<span class="e">:const</span> <a href="motion.txt.html#is" class="d">is</a> used for making both the variable and the value <a href="insert.txt.html#a" class="d">a</a> constant.  Use
this for composite structures that you want to make sure will not be modified.
Example: 
<span class="e">	const myList = [1, 2]</span>
<span class="e">	myList = [3, 4]		# Error!</span>
<span class="e">	myList[0] = 9		# Error!</span>
<span class="e">	myList-&gt;add(3)		# Error!</span>
							<span id="%3Afinal" class="t">:final</span> <span id="E1125" class="t">E1125</span>
<span class="e">:final</span> <a href="motion.txt.html#is" class="d">is</a> used for making only the variable <a href="insert.txt.html#a" class="d">a</a> constant, the value can be
changed.  This <a href="motion.txt.html#is" class="d">is</a> well known from Java.  Example: 
<span class="e">	final myList = [1, 2]</span>
<span class="e">	myList = [3, 4]		# Error!</span>
<span class="e">	myList[0] = 9		# OK</span>
<span class="e">	myList-&gt;add(3)		# OK</span>
<span class="e"></span>
It <a href="motion.txt.html#is" class="d">is</a> common to write constants <a href="motion.txt.html#as" class="d">as</a> ALL_CAPS, but you don't have to.

The constant only applies to the value itself, not what <a href="motion.txt.html#it" class="d">it</a> refers to. 
<span class="e">	final females = ["Mary"]</span>
<span class="e">	const NAMES = [["John", "Peter"], females]</span>
<span class="e">	NAMES[0] = ["Jack"]     # Error!</span>
<span class="e">	NAMES[0][0] = "Jack"    # Error!</span>
<span class="e">	NAMES[1] = ["Emma"]     # Error!</span>
<span class="e">	NAMES[1][0] = "Emma"    # OK, now females[0] == "Emma"</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">Omitting :call and :eval </span>
							<span id="E1190" class="t">E1190</span>
Functions can be called without <span class="e">:call</span>: 
<span class="e">	writefile(lines, 'file')</span>
Using <span class="e">:call</span> <a href="motion.txt.html#is" class="d">is</a> still possible, but this <a href="motion.txt.html#is" class="d">is</a> discouraged.

<a href="insert.txt.html#A" class="d">A</a> <a href="eval.txt.html#method" class="d">method</a> call without <span class="e">eval</span> <a href="motion.txt.html#is" class="d">is</a> possible, so long <a href="motion.txt.html#as" class="d">as</a> the start <a href="motion.txt.html#is" class="d">is</a> an
identifier or can't be an <a href="intro.txt.html#Ex" class="d">Ex</a> command.  For <a href="insert.txt.html#a" class="d">a</a> function either "<a href="motion.txt.html#%28" class="d">(</a>" or "<a href="eval.txt.html#-%3E" class="d">-&gt;</a>" <a href="vim_faq.txt.html#must" class="d">must</a>
be following, without <a href="insert.txt.html#a" class="d">a</a> line break.  Examples: 
<span class="e">	myList-&gt;add(123)</span>
<span class="e">	g:myList-&gt;add(123)</span>
<span class="e">	[1, 2, 3]-&gt;Process()</span>
<span class="e">	{a: 1, b: 2}-&gt;Process()</span>
<span class="e">	"foobar"-&gt;Process()</span>
<span class="e">	("foobar")-&gt;Process()</span>
<span class="e">	'foobar'-&gt;Process()</span>
<span class="e">	('foobar')-&gt;Process()</span>
<span class="e"></span>
In the rare <a href="change.txt.html#case" class="d">case</a> there <a href="motion.txt.html#is" class="d">is</a> ambiguity between <a href="insert.txt.html#a" class="d">a</a> function name and an <a href="intro.txt.html#Ex" class="d">Ex</a> command,
prepend "<a href="cmdline.txt.html#%3A" class="d">:</a>" to make clear you want to use the <a href="intro.txt.html#Ex" class="d">Ex</a> command.  For example, there
<a href="motion.txt.html#is" class="d">is</a> both the <span class="e">:substitute</span> command and the <span class="e">substitute()</span> function.  When the
line starts with <span class="e">substitute(</span> this will use the function. Prepend <a href="insert.txt.html#a" class="d">a</a> colon to
use the command instead: 
<span class="e">	:substitute(pattern (replacement (</span>
<span class="e"></span>
If the <a href="eval.txt.html#expression" class="d">expression</a> starts with "<a href="change.txt.html#%21" class="d">!</a>" this <a href="motion.txt.html#is" class="d">is</a> interpreted <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> shell command, not
negation of <a href="insert.txt.html#a" class="d">a</a> condition.  Thus this <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> shell command: 
<span class="e">	!shellCommand-&gt;something</span>
Put the <a href="eval.txt.html#expression" class="d">expression</a> in parentheses to use the "<a href="change.txt.html#%21" class="d">!</a>" for negation: 
<span class="e">	(!expression)-&gt;Method()</span>
<span class="e"></span>
<span class="n">Note</span> that while <a href="eval.txt.html#variables" class="d">variables</a> need to be defined before they can be used,
<a href="eval.txt.html#functions" class="d">functions</a> can be called before being defined.  This <a href="motion.txt.html#is" class="d">is</a> required to allow
for cyclic dependencies between functions.  It <a href="motion.txt.html#is" class="d">is</a> slightly <a href="various.txt.html#less" class="d">less</a> efficient,
since the function has to be looked up by name.  And <a href="insert.txt.html#a" class="d">a</a> typo in the function
name will only be found when the function <a href="motion.txt.html#is" class="d">is</a> called.


<span class="h">Omitting function() </span>

<a href="insert.txt.html#A" class="d">A</a> user defined function can be used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> function <a href="intro.txt.html#reference" class="d">reference</a> in an <a href="eval.txt.html#expression" class="d">expression</a>
without <span class="e">function()</span>. The argument types and return type will then be checked.
The function <a href="vim_faq.txt.html#must" class="d">must</a> already have been defined. 
<span class="e"></span>
<span class="e">	var Funcref = MyFunction</span>
<span class="e"></span>
When using <span class="e">function()</span> the resulting type <a href="motion.txt.html#is" class="d">is</a> "func"<a href="motion.txt.html#%2C" class="d">,</a> <a href="insert.txt.html#a" class="d">a</a> function with any
number of arguments and any return type (including void).  The function can be
defined later if the argument <a href="motion.txt.html#is" class="d">is</a> in quotes.


<span class="h">Lambda using =&gt; instead of -&gt; </span>
							<span id="vim9-lambda" class="t">vim9-lambda</span>
In legacy <a href="usr_41.txt.html#script" class="d">script</a> there can be confusion between using "<a href="eval.txt.html#-%3E" class="d">-&gt;</a>" for <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#method" class="d">method</a> call
and for <a href="insert.txt.html#a" class="d">a</a> lambda.  Also, when <a href="insert.txt.html#a" class="d">a</a> "<a href="motion.txt.html#%7B" class="d">{</a>" <a href="motion.txt.html#is" class="d">is</a> found the parser needs to figure out if
<a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> the start of <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#lambda" class="d">lambda</a> or <a href="insert.txt.html#a" class="d">a</a> dictionary, which <a href="motion.txt.html#is" class="d">is</a> now more complicated
because of the use of argument types.

To avoid these problems <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> uses <a href="insert.txt.html#a" class="d">a</a> different <a href="syntax.txt.html#syntax" class="d">syntax</a> for <a href="insert.txt.html#a" class="d">a</a> lambda,
which <a href="motion.txt.html#is" class="d">is</a> similar to JavaScript: 
<span class="e">	var Lambda = (arg) =&gt; expression</span>
<span class="e">	var Lambda = (arg): type =&gt; expression</span>
							<span id="E1157" class="t">E1157</span>
No line break <a href="motion.txt.html#is" class="d">is</a> allowed in the arguments of <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#lambda" class="d">lambda</a> up to and including the
"=&gt;" (so that Vim can tell the difference between an <a href="eval.txt.html#expression" class="d">expression</a> in parentheses
and <a href="eval.txt.html#lambda" class="d">lambda</a> arguments).  This <a href="motion.txt.html#is" class="d">is</a> OK: 
<span class="e">	filter(list, (k, v) =&gt;</span>
<span class="e">			v &gt; 0)</span>
This does not work: 
<span class="e">	filter(list, (k, v)</span>
<span class="e">			=&gt; v &gt; 0)</span>
This also does not work: 
<span class="e">	filter(list, (k,</span>
<span class="e">			v) =&gt; v &gt; 0)</span>
But you can use <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> to concatenate the lines before parsing: 
<span class="e">	filter(list, (k,</span>
<span class="e">		\	v)</span>
<span class="e">		\	=&gt; v &gt; 0)</span>
					<span id="vim9-lambda-arguments" class="t">vim9-lambda-arguments</span> <span id="E1172" class="t">E1172</span>
In legacy <a href="usr_41.txt.html#script" class="d">script</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#lambda" class="d">lambda</a> could be called with any number of extra arguments,
there was no way to warn for not using them.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> the number of
arguments <a href="vim_faq.txt.html#must" class="d">must</a> match.  If you <a href="diff.txt.html#do" class="d">do</a> want to accept any arguments, or any further
arguments, use "..._"<a href="motion.txt.html#%2C" class="d">,</a> which makes the function accept
<a href="vim9.txt.html#vim9-variable-arguments" class="l">vim9-variable-arguments</a><a href="repeat.txt.html#." class="d">.</a>  Example: 
<span class="e">	var Callback = (..._) =&gt; 'anything'</span>
<span class="e">	echo Callback(1, 2, 3)  # displays "anything"</span>
<span class="e"></span>
						<span id="inline-function" class="t">inline-function</span> <span id="E1171" class="t">E1171</span>
Additionally, <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#lambda" class="d">lambda</a> can contain statements in {}: 
<span class="e">	var Lambda = (arg) =&gt; {</span>
<span class="e">		g:was_called = 'yes'</span>
<span class="e">		return expression</span>
<span class="e">	    }</span>
This can be useful for <a href="insert.txt.html#a" class="d">a</a> timer, for example: 
<span class="e">	var count = 0</span>
<span class="e">	var timer = timer_start(500, (_) =&gt; {</span>
<span class="e">		 count += 1</span>
<span class="e">		 echom 'Handler called ' .. count</span>
<span class="e">	     }, {repeat: 3})</span>
<span class="e"></span>
The ending "<a href="motion.txt.html#%7D" class="d">}</a>" <a href="vim_faq.txt.html#must" class="d">must</a> be <a href="motion.txt.html#at" class="d">at</a> the start of <a href="insert.txt.html#a" class="d">a</a> line.  It can be followed by other
characters, e.g.: 
<span class="e">	var d = mapnew(dict, (k, v): string =&gt; {</span>
<span class="e">	     return 'value'</span>
<span class="e">	   })</span>
No command can follow the "<a href="motion.txt.html#%7B" class="d">{</a>"<a href="motion.txt.html#%2C" class="d">,</a> only <a href="insert.txt.html#a" class="d">a</a> comment can be used there.

						<span id="command-block" class="t">command-block</span> <span id="E1026" class="t">E1026</span>
The block can also be used for defining <a href="insert.txt.html#a" class="d">a</a> user command.  Inside the block <a href="vim9.txt.html#Vim9" class="d">Vim9</a>
<a href="syntax.txt.html#syntax" class="d">syntax</a> will be used.

This <a href="motion.txt.html#is" class="d">is</a> an example of using here-docs: 
<span class="e">    com SomeCommand {</span>
<span class="e">        g:someVar =&lt;&lt; trim eval END</span>
<span class="e">          ccc</span>
<span class="e">          ddd</span>
<span class="e">        END</span>
<span class="e">      }</span>
<span class="e"></span>
If the statements include <a href="insert.txt.html#a" class="d">a</a> dictionary, its closing bracket <a href="vim_faq.txt.html#must" class="d">must</a> not be
written <a href="motion.txt.html#at" class="d">at</a> the start of <a href="insert.txt.html#a" class="d">a</a> line.  Otherwise, <a href="motion.txt.html#it" class="d">it</a> would be parsed <a href="motion.txt.html#as" class="d">as</a> the <a href="intro.txt.html#end" class="d">end</a> of
the block.  This does not work: 
<span class="e">	command NewCommand {</span>
<span class="e">	     g:mydict = {</span>
<span class="e">	       'key': 'value',</span>
<span class="e">	       }  # ERROR: will be recognized as the end of the block</span>
<span class="e">	   }</span>
Put the '}' after the last item to avoid this: 
<span class="e">	command NewCommand {</span>
<span class="e">	     g:mydict = {</span>
<span class="e">	       'key': 'value' }</span>
<span class="e">	   }</span>
<span class="e"></span>
Rationale: The "<a href="motion.txt.html#%7D" class="d">}</a>" cannot be after <a href="insert.txt.html#a" class="d">a</a> command because <a href="motion.txt.html#it" class="d">it</a> would require parsing
the commands to find it.  For consistency with that no command can follow the
"<span class="s">{".  Unfortunately this means using "() =&gt; {  command  }</span>" does not work, line
breaks are always required.

							<span id="vim9-curly" class="t">vim9-curly</span>
To avoid the "<a href="motion.txt.html#%7B" class="d">{</a>" of <a href="insert.txt.html#a" class="d">a</a> dictionary literal to be recognized <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> statement block
wrap <a href="motion.txt.html#it" class="d">it</a> in parentheses: 
<span class="e">	var Lambda = (arg) =&gt; ({key: 42})</span>
<span class="e"></span>
Also when confused with the start of <a href="insert.txt.html#a" class="d">a</a> command block: 
<span class="e">	({</span>
<span class="e">	    key: value</span>
<span class="e">	 })-&gt;method()</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">Automatic line continuation </span>
					<span id="vim9-line-continuation" class="t">vim9-line-continuation</span> <span id="E1097" class="t">E1097</span>
In many cases <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> obvious that an <a href="eval.txt.html#expression" class="d">expression</a> continues on the next line.  In
those cases there <a href="motion.txt.html#is" class="d">is</a> no need to prefix the line with <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> (see
<a href="repeat.txt.html#line-continuation" class="l">line-continuation</a>).  For example, when <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> spans multiple lines: 
<span class="e">	var mylist = [</span>
<span class="e">		'one',</span>
<span class="e">		'two',</span>
<span class="e">		]</span>
And when <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#dict" class="d">dict</a> spans multiple lines: 
<span class="e">	var mydict = {</span>
<span class="e">		one: 1,</span>
<span class="e">		two: 2,</span>
<span class="e">		}</span>
With <a href="insert.txt.html#a" class="d">a</a> function call: 
<span class="e">	var result = Func(</span>
<span class="e">			arg1,</span>
<span class="e">			arg2</span>
<span class="e">			)</span>
<span class="e"></span>
For binary operators in expressions not in [], <a href="intro.txt.html#%7B%7D" class="d">{}</a> or () <a href="insert.txt.html#a" class="d">a</a> line break <a href="motion.txt.html#is" class="d">is</a>
possible just before or after the operator.  For example: 
<span class="e">	var text = lead</span>
<span class="e">		   .. middle</span>
<span class="e">		   .. end</span>
<span class="e">	var total = start +</span>
<span class="e">		    end -</span>
<span class="e">		    correction</span>
<span class="e">	var result = positive</span>
<span class="e">			? PosFunc(arg)</span>
<span class="e">			: NegFunc(arg)</span>
<span class="e"></span>
For <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#method" class="d">method</a> call using "<a href="eval.txt.html#-%3E" class="d">-&gt;</a>" and <a href="insert.txt.html#a" class="d">a</a> member using <a href="insert.txt.html#a" class="d">a</a> dot, <a href="insert.txt.html#a" class="d">a</a> line break <a href="motion.txt.html#is" class="d">is</a> allowed
before it: 
<span class="e">	var result = GetBuilder()</span>
<span class="e">			-&gt;BuilderSetWidth(333)</span>
<span class="e">			-&gt;BuilderSetHeight(777)</span>
<span class="e">			-&gt;BuilderBuild()</span>
<span class="e">	var result = MyDict</span>
<span class="e">			.member</span>
<span class="e"></span>
For commands that have an argument that <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> of commands, the | character
<a href="motion.txt.html#at" class="d">at</a> the start of the line indicates line continuation: 
<span class="e">	autocmd BufNewFile *.match if condition</span>
<span class="e">		|   echo 'match'</span>
<span class="e">		| endif</span>
<span class="e"></span>
<span class="n">Note</span> that this means that in heredoc the first line cannot start with <a href="insert.txt.html#a" class="d">a</a> bar: 
<span class="e">	var lines =&lt;&lt; trim END</span>
<span class="e">	   | this doesn't work</span>
<span class="e">	END</span>
Either use an empty line <a href="motion.txt.html#at" class="d">at</a> the start or <a href="diff.txt.html#do" class="d">do</a> not use heredoc.  Or temporarily
add the "<a href="change.txt.html#C" class="d">C</a>" flag to <a href="options.txt.html#%27cpoptions%27" class="o">'cpoptions'</a>: 
<span class="e">	set cpo+=C</span>
<span class="e">	var lines =&lt;&lt; trim END</span>
<span class="e">	   | this works</span>
<span class="e">	END</span>
<span class="e">	set cpo-=C</span>
If the heredoc <a href="motion.txt.html#is" class="d">is</a> inside <a href="insert.txt.html#a" class="d">a</a> function <a href="options.txt.html#%27cpoptions%27" class="o">'cpoptions'</a> <a href="vim_faq.txt.html#must" class="d">must</a> be set before <a href="vim9.txt.html#%3Adef" class="d">:def</a> and
restored after the :enddef.

In places where line continuation with <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> <a href="motion.txt.html#is" class="d">is</a> still needed, such <a href="motion.txt.html#as" class="d">as</a>
splitting up <a href="insert.txt.html#a" class="d">a</a> long <a href="intro.txt.html#Ex" class="d">Ex</a> command, comments can start with '#\ ': 
<span class="e">	syn region Text</span>
<span class="e">	      \ start='foo'</span>
<span class="e">	      #\ comment</span>
<span class="e">	      \ end='bar'</span>
Like with legacy <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#%27" class="d">'</a>"\ <a href="motion.txt.html#%27" class="d">'</a> <a href="motion.txt.html#is" class="d">is</a> used.  This <a href="motion.txt.html#is" class="d">is</a> also needed when line
continuation <a href="motion.txt.html#is" class="d">is</a> used without <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> and <a href="insert.txt.html#a" class="d">a</a> line starts with <a href="insert.txt.html#a" class="d">a</a> bar: 
<span class="e">	au CursorHold * echom 'BEFORE bar'</span>
<span class="e">	      #\ some comment</span>
<span class="e">	      | echom 'AFTER bar'</span>

							<span id="E1050" class="t">E1050</span>
To make <a href="motion.txt.html#it" class="d">it</a> possible for the <a href="motion.txt.html#operator" class="d">operator</a> <a href="motion.txt.html#at" class="d">at</a> the start of the line to be
recognized, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> required to <a href="change.txt.html#put" class="d">put</a> <a href="insert.txt.html#a" class="d">a</a> colon before <a href="insert.txt.html#a" class="d">a</a> range.  This example will
add "start" and "print"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	var result = start</span>
<span class="e">	+ print</span>
Like this: 
<span class="e">	var result = start + print</span>
<span class="e"></span>
This will assign "start" and print <a href="insert.txt.html#a" class="d">a</a> line: 
<span class="e">	var result = start</span>
<span class="e">	:+ print</span>
<span class="e"></span>
After the range an <a href="intro.txt.html#Ex" class="d">Ex</a> command <a href="vim_faq.txt.html#must" class="d">must</a> follow.  Without the colon you can call <a href="insert.txt.html#a" class="d">a</a>
function without <span class="e">:call</span>, but after <a href="insert.txt.html#a" class="d">a</a> range you <a href="diff.txt.html#do" class="d">do</a> need it: 
<span class="e">	MyFunc()</span>
<span class="e">	:% call MyFunc()</span>
<span class="e"></span>
<span class="n">Note</span> that the colon <a href="motion.txt.html#is" class="d">is</a> not required for the <a href="editing.txt.html#%2Bcmd" class="l">+cmd</a> argument: 
<span class="e">	edit +6 fname</span>
<span class="e"></span>
It <a href="motion.txt.html#is" class="d">is</a> also possible to split <a href="insert.txt.html#a" class="d">a</a> function header over multiple lines, in between
arguments: 
<span class="e">	def MyFunc(</span>
<span class="e">		text: string,</span>
<span class="e">		separator = '-'</span>
<span class="e">		): string</span>
<span class="e"></span>
Since <a href="insert.txt.html#a" class="d">a</a> continuation line cannot be easily recognized the parsing of commands
has been made stricter.  E.g., because of the error in the first line, the
second line <a href="motion.txt.html#is" class="d">is</a> seen <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> separate command: 
<span class="e">	popup_create(some invalid expression, {</span>
<span class="e">	   exit_cb: Func})</span>
Now "exit_cb: Func})" <a href="motion.txt.html#is" class="d">is</a> actually <a href="insert.txt.html#a" class="d">a</a> valid command: save any changes to the
file "_cb: Func})" and exit.  To avoid this kind of mistake in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a>
there <a href="vim_faq.txt.html#must" class="d">must</a> be white <a href="intro.txt.html#space" class="d">space</a> between most command names and the argument.
<span id="E1144" class="t">E1144</span>

However, the argument of <a href="insert.txt.html#a" class="d">a</a> command that <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> command won't be recognized.  For
example, after "windo echo <a href="eval.txt.html#expr" class="d">expr</a>" <a href="insert.txt.html#a" class="d">a</a> line break inside "<a href="eval.txt.html#expr" class="d">expr</a>" will not be seen.


<span class="n">Notes:</span>
<a href="motion.txt.html#-" class="d">-</a> "enddef" cannot be used <a href="motion.txt.html#at" class="d">at</a> the start of <a href="insert.txt.html#a" class="d">a</a> continuation line, <a href="motion.txt.html#it" class="d">it</a> ends the
  current function.
<a href="motion.txt.html#-" class="d">-</a> No line break <a href="motion.txt.html#is" class="d">is</a> allowed in the LHS of an assignment.  Specifically when
  unpacking <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> <a href="eval.txt.html#%3Alet-unpack" class="l">:let-unpack</a><a href="repeat.txt.html#." class="d">.</a> This <a href="motion.txt.html#is" class="d">is</a> OK: 
<span class="e">	[var1, var2] =</span>
<span class="e">		Func()</span>
  This does not work: 
<span class="e">	[var1,</span>
<span class="e">	    var2] =</span>
<span class="e">		Func()</span>
<a href="motion.txt.html#-" class="d">-</a> No line break <a href="motion.txt.html#is" class="d">is</a> allowed in between arguments of an <span class="e">:echo</span>, <span class="e">:execute</span> and
  similar commands.  This <a href="motion.txt.html#is" class="d">is</a> OK: 
<span class="e">	echo [1,</span>
<span class="e">		2] [3,</span>
<span class="e">			4]</span>
  This does not work: 
<span class="e">	echo [1, 2]</span>
<span class="e">		[3, 4]</span>
<a href="motion.txt.html#-" class="d">-</a> In some cases <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> difficult for Vim to parse <a href="insert.txt.html#a" class="d">a</a> command, especially when
  commands are used <a href="motion.txt.html#as" class="d">as</a> an argument to another command, such <a href="motion.txt.html#as" class="d">as</a> <span class="e">:windo</span>.  In
  those cases the line continuation with <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#backslash" class="d">backslash</a> has to be used.


<span class="h">White space </span>
	<span id="vim9-white-space" class="t">vim9-white-space</span> <span id="E1004" class="t">E1004</span> <span id="E1068" class="t">E1068</span> <span id="E1069" class="t">E1069</span> <span id="E1074" class="t">E1074</span> <span id="E1127" class="t">E1127</span> <span id="E1202" class="t">E1202</span>
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> enforces proper use of white space.  This <a href="motion.txt.html#is" class="d">is</a> no longer allowed: 
<span class="e">	var name=234	# Error!</span>
<span class="e">	var name= 234	# Error!</span>
<span class="e">	var name =234	# Error!</span>
There <a href="vim_faq.txt.html#must" class="d">must</a> be white <a href="intro.txt.html#space" class="d">space</a> before and after the "<a href="change.txt.html#%3D" class="d">=</a>"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	var name = 234	# OK</span>
White <a href="intro.txt.html#space" class="d">space</a> <a href="vim_faq.txt.html#must" class="d">must</a> also be <a href="change.txt.html#put" class="d">put</a> before the <a href="pattern.txt.html#%23" class="d">#</a> that starts <a href="insert.txt.html#a" class="d">a</a> comment after <a href="insert.txt.html#a" class="d">a</a>
command: 
<span class="e">	var name = 234# Error!</span>
<span class="e">	var name = 234 # OK</span>
<span class="e"></span>
White <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> required around most operators.

White <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> required in <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#sublist" class="d">sublist</a> (list slice) around the "<a href="cmdline.txt.html#%3A" class="d">:</a>"<a href="motion.txt.html#%2C" class="d">,</a> except <a href="motion.txt.html#at" class="d">at</a>
the start and end: 
<span class="e">	otherlist = mylist[v : count]	# v:count has a different meaning</span>
<span class="e">	otherlist = mylist[:]		# make a copy of the List</span>
<span class="e">	otherlist = mylist[v :]</span>
<span class="e">	otherlist = mylist[: v]</span>
<span class="e"></span>
White <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> not allowed:
<a href="motion.txt.html#-" class="d">-</a> Between <a href="insert.txt.html#a" class="d">a</a> function name and the "<a href="motion.txt.html#%28" class="d">(</a>"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	Func (arg)	   # Error!</span>
<span class="e">	Func</span>
<span class="e">	     \ (arg)	   # Error!</span>
<span class="e">	Func</span>
<span class="e">	      (arg)	   # Error!</span>
<span class="e">	Func(arg)	   # OK</span>
<span class="e">	Func(</span>
<span class="e">	      arg)	   # OK</span>
<span class="e">	Func(</span>
<span class="e">	      arg	   # OK</span>
<span class="e">	      )</span>
							<span id="E1205" class="t">E1205</span>
White <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> not allowed in <a href="insert.txt.html#a" class="d">a</a> <span class="e">:set</span> command between the option name and <a href="insert.txt.html#a" class="d">a</a>
following "<a href="change.txt.html#%26" class="d">&amp;</a>"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="change.txt.html#%21" class="d">!</a>"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="change.txt.html#%3C" class="d">&lt;</a>"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="change.txt.html#%3D" class="d">=</a>"<a href="motion.txt.html#%2C" class="d">,</a> "+="<a href="motion.txt.html#%2C" class="d">,</a> "-=" or "^="<a href="repeat.txt.html#." class="d">.</a>


<span class="h">No curly braces expansion </span>

<a href="eval.txt.html#curly-braces-names" class="l">curly-braces-names</a> cannot be used.


<span class="h">Command modifiers are not ignored </span>
								<span id="E1176" class="t">E1176</span>
Using <a href="insert.txt.html#a" class="d">a</a> command modifier for <a href="insert.txt.html#a" class="d">a</a> command that does not use <a href="motion.txt.html#it" class="d">it</a> gives an error.
								<span id="E1082" class="t">E1082</span>
Also, using <a href="insert.txt.html#a" class="d">a</a> command modifier without <a href="insert.txt.html#a" class="d">a</a> following command <a href="motion.txt.html#is" class="d">is</a> now an error.


<span class="h">Dictionary literals </span>
						<span id="vim9-literal-dict" class="t">vim9-literal-dict</span> <span id="E1014" class="t">E1014</span>
Traditionally Vim has supported dictionary literals with <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#%7B%7D" class="d">{}</a> syntax: 
<span class="e">	let dict = {'key': value}</span>
<span class="e"></span>
Later <a href="motion.txt.html#it" class="d">it</a> became clear that using <a href="insert.txt.html#a" class="d">a</a> simple text key <a href="motion.txt.html#is" class="d">is</a> very common, thus
literal dictionaries were introduced in <a href="insert.txt.html#a" class="d">a</a> backwards compatible way: 
<span class="e">	let dict = #{key: value}</span>
<span class="e"></span>
However, this <a href="eval.txt.html#%23%7B%7D" class="d">#{}</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> <a href="motion.txt.html#is" class="d">is</a> unlike any existing language.  As <a href="motion.txt.html#it" class="d">it</a> turns out
that using <a href="insert.txt.html#a" class="d">a</a> literal key <a href="motion.txt.html#is" class="d">is</a> much more common than using an expression, and
considering that JavaScript uses this syntax, using the <a href="intro.txt.html#%7B%7D" class="d">{}</a> form for dictionary
literals <a href="motion.txt.html#is" class="d">is</a> considered <a href="insert.txt.html#a" class="d">a</a> much more useful syntax.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> the <a href="intro.txt.html#%7B%7D" class="d">{}</a> form
uses literal keys: 
<span class="e">	var dict = {key: value}</span>
<span class="e"></span>
This works for alphanumeric characters, underscore and dash.  If you want to
use another character, use <a href="insert.txt.html#a" class="d">a</a> single or double quoted string: 
<span class="e">	var dict = {'key with space': value}</span>
<span class="e">	var dict = {"key\twith\ttabs": value}</span>
<span class="e">	var dict = {'': value}			# empty key</span>
							<span id="E1139" class="t">E1139</span>
In <a href="change.txt.html#case" class="d">case</a> the key needs to be an expression, square brackets can be used, just
like in JavaScript: 
<span class="e">	var dict = {["key" .. nr]: value}</span>
<span class="e"></span>
The key type can be string, number, bool or float.  Other types result in an
error.  Without using <a href="motion.txt.html#%5B%5D" class="d">[]</a> the value <a href="motion.txt.html#is" class="d">is</a> used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> string, keeping leading zeros.
An <a href="eval.txt.html#expression" class="d">expression</a> given with <a href="motion.txt.html#%5B%5D" class="d">[]</a> <a href="motion.txt.html#is" class="d">is</a> evaluated and then converted to <a href="insert.txt.html#a" class="d">a</a> string.
Leading zeros will then be dropped: 
<span class="e">	var dict = {000123: 'without', [000456]: 'with'}</span>
<span class="e">	echo dict</span>
<span class="e">	{'456': 'with', '000123': 'without'}</span>
<a href="insert.txt.html#A" class="d">A</a> float only works inside <a href="motion.txt.html#%5B%5D" class="d">[]</a> because the dot <a href="motion.txt.html#is" class="d">is</a> not accepted otherwise: 
<span class="e">	var dict = {[00.013]: 'float'}</span>
<span class="e">	echo dict</span>
<span class="e">	{'0.013': 'float'}</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">No :xit, :t, :k, :append, :change or :insert </span>
							<span id="E1100" class="t">E1100</span>
These commands are too easily confused with local variable names.
Instead of <span class="e">:x</span> or <span class="e">:xit</span> you can use <span class="e">:exit</span>.
Instead of <span class="e">:t</span> you can use <span class="e">:copy</span>.
Instead of <span class="e">:k</span> you can use <span class="e">:mark</span>.


<span class="h">Comparators </span>

The <a href="options.txt.html#%27ignorecase%27" class="o">'ignorecase'</a> option <a href="motion.txt.html#is" class="d">is</a> not used for comparators that use strings.
Thus "=~" works like "=~#"<a href="repeat.txt.html#." class="d">.</a>

"<a href="motion.txt.html#is" class="d">is</a>" and "isnot" <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#expr-is" class="l">expr-is</a> and <a href="eval.txt.html#expr-isnot" class="l">expr-isnot</a><a href="motion.txt.html#%29" class="d">)</a> when used on strings now return
false.  In legacy <a href="usr_41.txt.html#script" class="d">script</a> they just compare the strings, in <a href="vim9.txt.html#Vim9" class="l">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> they
check identity, and strings are copied when used, thus two strings are never
the same (this might change someday if strings are not copied but <a href="intro.txt.html#reference" class="d">reference</a>
counted).


<span class="h">Abort after error </span>

In legacy script, when an error <a href="motion.txt.html#is" class="d">is</a> encountered, Vim continues to execute
following lines.  This can lead to <a href="insert.txt.html#a" class="d">a</a> long sequence of <a href="message.txt.html#errors" class="d">errors</a> and need to type
<a href="pattern.txt.html#CTRL-C" class="k">CTRL-C</a> to stop it.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> execution of commands stops <a href="motion.txt.html#at" class="d">at</a> the first
error.  Example: 
<span class="e">	vim9script</span>
<span class="e">	var x = does-not-exist</span>
<span class="e">	echo 'not executed'</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">For loop </span>
							<span id="E1254" class="t">E1254</span>
The loop variable <a href="vim_faq.txt.html#must" class="d">must</a> not be declared yet: 
<span class="e">	var i = 1</span>
<span class="e">	for i in [1, 2, 3]   # Error!</span>
<span class="e"></span>
It <a href="motion.txt.html#is" class="d">is</a> possible to use <a href="insert.txt.html#a" class="d">a</a> global variable though: 
<span class="e">	g:i = 1</span>
<span class="e">	for g:i in [1, 2, 3]</span>
<span class="e">	  echo g:i</span>
<span class="e">	endfor</span>
<span class="e"></span>
Legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> has some tricks to make <a href="insert.txt.html#a" class="d">a</a> for loop over <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> handle
<a href="change.txt.html#deleting" class="d">deleting</a> items <a href="motion.txt.html#at" class="d">at</a> the current or previous item.  In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#it" class="d">it</a> just uses
the index, if items are deleted then items in the <a href="eval.txt.html#list" class="d">list</a> will be skipped.
Example legacy script: 
<span class="e">	let l = [1, 2, 3, 4]</span>
<span class="e">	for i in l</span>
<span class="e">	   echo i</span>
<span class="e">	   call remove(l, index(l, i))</span>
<span class="e">	endfor</span>
Would echo:
	1
	2
	3
	4
In compiled <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> you get:
	1
	3
Generally, you should not change the <a href="eval.txt.html#list" class="d">list</a> that <a href="motion.txt.html#is" class="d">is</a> iterated over.  Make <a href="insert.txt.html#a" class="d">a</a> copy
first if needed.
When looping over <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> of lists, the nested lists can be changed.  The loop
variable <a href="motion.txt.html#is" class="d">is</a> "final"<a href="motion.txt.html#%2C" class="d">,</a> <a href="motion.txt.html#it" class="d">it</a> cannot be changed but what its value can be changed.
							<span id="E1306" class="t">E1306</span>
The depth of loops, <a href="eval.txt.html#%3Afor" class="d">:for</a> and <a href="eval.txt.html#%3Awhile" class="d">:while</a> loops added together, cannot exceed 10.


<span class="h">Conditions and expressions </span>
						<span id="vim9-boolean" class="t">vim9-boolean</span>
Conditions and expressions are mostly working like they <a href="diff.txt.html#do" class="d">do</a> in other languages.
Some values are different from legacy Vim script:
<span class="h">	value		legacy Vim script	Vim9 script </span>
	<a href="motion.txt.html#0" class="d">0</a>		<a href="eval.txt.html#falsy" class="d">falsy</a>			<a href="eval.txt.html#falsy" class="d">falsy</a>
	1		<a href="eval.txt.html#truthy" class="d">truthy</a>			<a href="eval.txt.html#truthy" class="d">truthy</a>
	99		<a href="eval.txt.html#truthy" class="d">truthy</a>			Error!
	"<a href="motion.txt.html#0" class="d">0</a>"		<a href="eval.txt.html#falsy" class="d">falsy</a>			Error!
	"99"		<a href="eval.txt.html#truthy" class="d">truthy</a>			Error!
	"text"		<a href="eval.txt.html#falsy" class="d">falsy</a>			Error!

For the "<a href="eval.txt.html#%3F%3F" class="d">??</a>" <a href="motion.txt.html#operator" class="d">operator</a> and when using "<a href="change.txt.html#%21" class="d">!</a>" then there <a href="motion.txt.html#is" class="d">is</a> no error, every value
<a href="motion.txt.html#is" class="d">is</a> either <a href="eval.txt.html#falsy" class="d">falsy</a> or truthy.  This <a href="motion.txt.html#is" class="d">is</a> mostly like JavaScript, except that an
empty <a href="eval.txt.html#list" class="d">list</a> and <a href="eval.txt.html#dict" class="d">dict</a> <a href="motion.txt.html#is" class="d">is</a> falsy:

<span class="h">	type		truthy when </span>
	bool		true, <a href="eval.txt.html#v%3Atrue" class="d">v:true</a> or 1
	number		non-zero
	float		non-zero
	<a href="eval.txt.html#string" class="d">string</a>		non-empty
	<a href="eval.txt.html#blob" class="d">blob</a>		non-empty
	<a href="eval.txt.html#list" class="d">list</a>		non-empty (different from JavaScript)
	<a href="eval.txt.html#tuple" class="d">tuple</a>		non-empty (different from JavaScript)
	dictionary	non-empty (different from JavaScript)
	func		when there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> function name
	special		<a href="vim9.txt.html#true" class="d">true</a> or <a href="eval.txt.html#v%3Atrue" class="d">v:true</a>
	<a href="channel.txt.html#job" class="d">job</a>		when not NULL
	<a href="channel.txt.html#channel" class="d">channel</a>		when not NULL
	<a href="vim9class.txt.html#class" class="d">class</a>		when not NULL
	<a href="vim9class.txt.html#object" class="d">object</a>		when not NULL (TODO: when isTrue() returns true)

The <a href="options.txt.html#boolean" class="d">boolean</a> operators "||" and "&amp;&amp;" expect the values to be boolean, zero or
one: 
<span class="e">	1 || false   == true</span>
<span class="e">	0 || 1       == true</span>
<span class="e">	0 || false   == false</span>
<span class="e">	1 &amp;&amp; true    == true</span>
<span class="e">	0 &amp;&amp; 1       == false</span>
<span class="e">	8 || 0	     Error!</span>
<span class="e">	'yes' &amp;&amp; 0   Error!</span>
<span class="e">	[] || 99     Error!</span>
<span class="e"></span>
When using "<a href="change.txt.html#%21" class="d">!</a>" for inverting, there <a href="motion.txt.html#is" class="d">is</a> no error for using any type and the
result <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> boolean.  "<a href="change.txt.html#%21%21" class="d">!!</a>" can be used to turn any value into boolean: 
<span class="e">	!'yes'			== false</span>
<span class="e">	!![]			== false</span>
<span class="e">	!![1, 2, 3]		== true</span>
<span class="e"></span>
When using "<span class="e">.."</span> for <a href="eval.txt.html#string" class="d">string</a> concatenation arguments of simple types are
always converted to string: 
<span class="e">	'hello ' .. 123  == 'hello 123'</span>
<span class="e">	'hello ' .. v:true  == 'hello true'</span>
<span class="e"></span>
Simple types are Number, Float, <a href="eval.txt.html#Special" class="d">Special</a> and Bool.  For other types <a href="builtin.txt.html#string%28%29" class="l">string()</a>
should be used.
			<span id="false" class="t">false</span> <span id="true" class="t">true</span> <span id="null" class="t">null</span> <span id="null_blob" class="t">null_blob</span> <span id="null_channel" class="t">null_channel</span>
			<span id="null_class" class="t">null_class</span> <span id="null_dict" class="t">null_dict</span> <span id="null_function" class="t">null_function</span> <span id="null_job" class="t">null_job</span>
			<span id="null_list" class="t">null_list</span> <span id="null_object" class="t">null_object</span> <span id="null_partial" class="t">null_partial</span> <span id="null_string" class="t">null_string</span>
			<span id="E1034" class="t">E1034</span>
In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> one can use the following predefined values: 
<span class="e">	true</span>
<span class="e">	false</span>
<span class="e">	null</span>
<span class="e">	null_blob</span>
<span class="e">	null_channel</span>
<span class="e">	null_class</span>
<span class="e">	null_dict</span>
<span class="e">	null_function</span>
<span class="e">	null_job</span>
<span class="e">	null_list</span>
<span class="e">	null_tuple</span>
<span class="e">	null_object</span>
<span class="e">	null_partial</span>
<span class="e">	null_string</span>
<span class="e">true</span> <a href="motion.txt.html#is" class="d">is</a> the same <a href="motion.txt.html#as" class="d">as</a> <span class="e">v:true</span>, <span class="e">false</span> the same <a href="motion.txt.html#as" class="d">as</a> <span class="e">v:false</span>, <span class="e">null</span> the same
<a href="motion.txt.html#as" class="d">as</a> <span class="e">v:null</span>.

While <span class="e">null</span> has the type "special"<a href="motion.txt.html#%2C" class="d">,</a> the other "null_" values have the type
indicated by their name.  Quite often <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a> value <a href="motion.txt.html#is" class="d">is</a> handled the same <a href="motion.txt.html#as" class="d">as</a> an
empty value, but not always.  The values can be useful to clear <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#script-local" class="d">script-local</a>
variable, since they cannot be deleted with <span class="e">:unlet</span>.  E.g.: 
<span class="e">	var theJob = job_start(...)</span>
<span class="e">	# let the job do its work</span>
<span class="e">	theJob = null_job</span>
<span class="e"></span>
The values can also be useful <a href="motion.txt.html#as" class="d">as</a> the default value for an argument: 
<span class="e">	def MyFunc(b: blob = null_blob)</span>
<span class="e">	    # Note: compare against null, not null_blob,</span>
<span class="e">	    #       to distinguish the default value from an empty blob.</span>
<span class="e">	    if b == null</span>
<span class="e">	        # b argument was not given</span>
See <a href="vim9.txt.html#null-compare" class="l">null-compare</a> for more information about <a href="testing.txt.html#testing" class="d">testing</a> against null.

It <a href="motion.txt.html#is" class="d">is</a> possible to compare <span class="e">null</span>  with any value, this will not give <a href="insert.txt.html#a" class="d">a</a> type
error.  However, comparing <span class="e">null</span> with <a href="insert.txt.html#a" class="d">a</a> number, float or bool will always
result in <span class="e">false</span>.  This <a href="motion.txt.html#is" class="d">is</a> different from legacy script, where comparing
<span class="e">null</span> with zero or <span class="e">false</span> would return <span class="e">true</span>.
							<span id="vim9-false-true" class="t">vim9-false-true</span>
When converting <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#boolean" class="d">boolean</a> to <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <span class="e">false</span> and <span class="e">true</span> are used, not
<span class="e">v:false</span> and <span class="e">v:true</span> like in legacy script.  <span class="e">v:none</span> has no <span class="e">none</span>
replacement, <a href="motion.txt.html#it" class="d">it</a> has no equivalent in other languages.
							<span id="vim9-string-index" class="t">vim9-string-index</span>
Indexing <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> with <span class="s">[idx]</span> or taking <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#slice" class="d">slice</a> with [idx <a href="cmdline.txt.html#%3A" class="d">:</a> idx] uses character
indexes instead of byte indexes.  Composing characters are included.
Example: 
<span class="e">	echo 'bár'[1]</span>
In legacy <a href="usr_41.txt.html#script" class="d">script</a> this results in the character 0xc3 (an illegal byte), in <a href="vim9.txt.html#Vim9" class="d">Vim9</a>
<a href="usr_41.txt.html#script" class="d">script</a> this results in the <a href="eval.txt.html#string" class="d">string</a> 'á'.
<a href="insert.txt.html#A" class="d">A</a> negative <a href="index.txt.html#index" class="d">index</a> <a href="motion.txt.html#is" class="d">is</a> counting from the end, "[-1]" <a href="motion.txt.html#is" class="d">is</a> the last character.
To exclude the last character use <a href="builtin.txt.html#slice%28%29" class="l">slice()</a><a href="repeat.txt.html#." class="d">.</a>
To <a href="intro.txt.html#count" class="d">count</a> composing characters separately use <a href="builtin.txt.html#strcharpart%28%29" class="l">strcharpart()</a><a href="repeat.txt.html#." class="d">.</a>
If the <a href="index.txt.html#index" class="d">index</a> <a href="motion.txt.html#is" class="d">is</a> out of range then an empty <a href="eval.txt.html#string" class="d">string</a> results.

In legacy <a href="usr_41.txt.html#script" class="d">script</a> "++var" and "--var" would be silently accepted and have no
effect.  This <a href="motion.txt.html#is" class="d">is</a> an error in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script.

Numbers <a href="starting.txt.html#starting" class="d">starting</a> with zero are not considered to be octal, only numbers
<a href="starting.txt.html#starting" class="d">starting</a> with "<a href="eval.txt.html#0o" class="d">0o</a>" are octal: "0o744"<a href="repeat.txt.html#." class="d">.</a> <a href="eval.txt.html#scriptversion-4" class="l">scriptversion-4</a>


<span class="h">What to watch out for </span>
							<span id="vim9-gotchas" class="t">vim9-gotchas</span>
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> was designed to be closer to often used programming languages, but <a href="motion.txt.html#at" class="d">at</a> the
same time tries to support the legacy Vim commands.  Some compromises had to
be made.  Here <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> summary of what might be unexpected.

<a href="intro.txt.html#Ex" class="d">Ex</a> command ranges need to be prefixed with <a href="insert.txt.html#a" class="d">a</a> colon. 
<span class="e">	-&gt;		  legacy Vim: shifts the previous line to the right</span>
<span class="e">	-&gt;func()	  Vim9: method call in a continuation line</span>
<span class="e">	:-&gt;		  Vim9: shifts the previous line to the right</span>
<span class="e"></span>
<span class="e">	%s/a/b		  legacy Vim: substitute on all lines</span>
<span class="e">	x = alongname</span>
<span class="e">	     % another	  Vim9: modulo operator in a continuation line</span>
<span class="e">	:%s/a/b		  Vim9: substitute on all lines</span>
<span class="e">	't		  legacy Vim: jump to mark t</span>
<span class="e">	'text'-&gt;func()	  Vim9: method call</span>
<span class="e">	:'t		  Vim9: jump to mark t</span>
<span class="e"></span>
Some <a href="intro.txt.html#Ex" class="d">Ex</a> commands can be confused with assignments in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script: 
<span class="e">	g:name = value    # assignment</span>
<span class="e">	:g:pattern:cmd	  # :global command</span>
<span class="e"></span>
To avoid confusion between <a href="insert.txt.html#a" class="d">a</a> <span class="e">:global</span> or <span class="e">:substitute</span> command and an
<a href="eval.txt.html#expression" class="d">expression</a> or assignment, <a href="insert.txt.html#a" class="d">a</a> few separators cannot be used when these commands
are abbreviated to <a href="insert.txt.html#a" class="d">a</a> single character: ':', '-' and '.'. 
<span class="e">	g:pattern:cmd	  # invalid command - ERROR</span>
<span class="e">	s:pattern:repl	  # invalid command - ERROR</span>
<span class="e">	g-pattern-cmd	  # invalid command - ERROR</span>
<span class="e">	s-pattern-repl	  # invalid command - ERROR</span>
<span class="e">	g.pattern.cmd	  # invalid command - ERROR</span>
<span class="e">	s.pattern.repl	  # invalid command - ERROR</span>
<span class="e"></span>
Also, there cannot be <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#space" class="d">space</a> between the command and the separator: 
<span class="e">	g /pattern/cmd	  # invalid command - ERROR</span>
<span class="e">	s /pattern/repl	  # invalid command - ERROR</span>
<span class="e"></span>
Functions defined with <span class="e">:def</span> compile the whole function.  Legacy <a href="eval.txt.html#functions" class="d">functions</a>
can bail out, and the following lines are not parsed: 
<span class="e">	func Maybe()</span>
<span class="e">	  if !has('feature')</span>
<span class="e">	    return</span>
<span class="e">	  endif</span>
<span class="e">	  use-feature</span>
<span class="e">	endfunc</span>
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="eval.txt.html#functions" class="d">functions</a> are compiled <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> whole: 
<span class="e">	def Maybe()</span>
<span class="e">	  if !has('feature')</span>
<span class="e">	    return</span>
<span class="e">	  endif</span>
<span class="e">	  use-feature  # May give a compilation error</span>
<span class="e">	enddef</span>
For <a href="insert.txt.html#a" class="d">a</a> workaround, split <a href="motion.txt.html#it" class="d">it</a> in two functions: 
<span class="e">	func Maybe()</span>
<span class="e">	  if has('feature')</span>
<span class="e">	    call MaybeInner()</span>
<span class="e">	  endif</span>
<span class="e">	endfunc</span>
<span class="e">	if has('feature')</span>
<span class="e">	  def MaybeInner()</span>
<span class="e">	    use-feature</span>
<span class="e">	  enddef</span>
<span class="e">	endif</span>
Or <a href="change.txt.html#put" class="d">put</a> the unsupported code inside an <span class="e">if</span> with <a href="insert.txt.html#a" class="d">a</a> constant <a href="eval.txt.html#expression" class="d">expression</a> that
evaluates to false: 
<span class="e">	def Maybe()</span>
<span class="e">	  if has('feature')</span>
<span class="e">	    use-feature</span>
<span class="e">	  endif</span>
<span class="e">	enddef</span>
The <span class="e">exists_compiled()</span> function can also be used for this.
							<span id="vim9-user-command" class="t">vim9-user-command</span>
Another side effect of compiling <a href="insert.txt.html#a" class="d">a</a> function <a href="motion.txt.html#is" class="d">is</a> that the presence of <a href="insert.txt.html#a" class="d">a</a> user
command <a href="motion.txt.html#is" class="d">is</a> checked <a href="motion.txt.html#at" class="d">at</a> compile time.  If the user command <a href="motion.txt.html#is" class="d">is</a> defined later an
error will result.  This works: 
<span class="e">	command -nargs=1 MyCommand echom &lt;q-args&gt;</span>
<span class="e">	def Works()</span>
<span class="e">	  MyCommand 123</span>
<span class="e">	enddef</span>
This will give an error for "MyCommand" not being defined: 
<span class="e">	def Works()</span>
<span class="e">	  command -nargs=1 MyCommand echom &lt;q-args&gt;</span>
<span class="e">	  MyCommand 123</span>
<span class="e">	enddef</span>
<a href="insert.txt.html#A" class="d">A</a> workaround <a href="motion.txt.html#is" class="d">is</a> to invoke the command indirectly with <span class="e">:execute</span>: 
<span class="e">	def Works()</span>
<span class="e">	  command -nargs=1 MyCommand echom &lt;q-args&gt;</span>
<span class="e">	  execute 'MyCommand 123'</span>
<span class="e">	enddef</span>
<span class="e"></span>
<span class="n">Note</span> that for unrecognized commands there <a href="motion.txt.html#is" class="d">is</a> no check for "|" and <a href="insert.txt.html#a" class="d">a</a> following
command.  This will give an error for missing <span class="e">endif</span>: 
<span class="e">	def Maybe()</span>
<span class="e">	  if has('feature') | use-feature | endif</span>
<span class="e">	enddef</span>
<span class="e"></span>
<span class="h">Other differences </span>

Patterns are used like <a href="options.txt.html#%27magic%27" class="o">'magic'</a> <a href="motion.txt.html#is" class="d">is</a> set, unless explicitly overruled.
The <a href="options.txt.html#%27edcompatible%27" class="o">'edcompatible'</a> option value <a href="motion.txt.html#is" class="d">is</a> not used.
The <a href="options.txt.html#%27gdefault%27" class="o">'gdefault'</a> option value <a href="motion.txt.html#is" class="d">is</a> not used.

You may also find this wiki useful.  It was written by an early adopter of
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> script: <a class="u" href="https://github.com/lacygoill/wiki/blob/master/vim/vim9.md">https://github.com/lacygoill/wiki/blob/master/vim/vim9.md</a>

							<span id="%3A%2B%2B" class="t">:++</span> <span id="%3A--" class="t">:--</span>
The ++ and <a href="starting.txt.html#--" class="d">--</a> commands have been added.  They are very similar to adding or
subtracting one: 
<span class="e">		++var</span>
<span class="e">		var += 1</span>
<span class="e">		--var</span>
<span class="e">		var -= 1</span>
<span class="e"></span>
Using ++var or --var in an <a href="eval.txt.html#expression" class="d">expression</a> <a href="motion.txt.html#is" class="d">is</a> not supported yet.


<span class="h">==============================================================================</span>

3. New style <a href="eval.txt.html#functions" class="d">functions</a>					<span id="fast-functions" class="t">fast-functions</span>

							<span id="%3Adef" class="t">:def</span>
:def[!] <span class="s">{name}</span>(<span class="s">[arguments]</span>)[: <span class="s">{return-type}</span>]
			Define <a href="insert.txt.html#a" class="d">a</a> new function by the name <span class="s">{name}</span>.  The body of
			the function follows in the next lines, until the
			matching <span class="e">:enddef</span>.
							<span id="E1073" class="t">E1073</span>
			The <span class="s">{name}</span> cannot be reused <a href="motion.txt.html#at" class="d">at</a> the <a href="map.txt.html#script-local" class="d">script-local</a> level: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1073()
			  enddef
			  def F_1073() <a href="pattern.txt.html#%23" class="d">#</a> E1073: Name already defined: <a href="map.txt.html#%3CSNR%3E" class="s">&lt;SNR&gt;</a>...
			  enddef
<a href="change.txt.html#%3C" class="d">&lt;</a>							<span id="E1011" class="t">E1011</span>
			The <span class="s">{name}</span> <a href="vim_faq.txt.html#must" class="d">must</a> be <a href="various.txt.html#less" class="d">less</a> than 100 bytes long.

							<span id="E1077" class="t">E1077</span>
			<span class="s">{arguments}</span> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> sequence of zero or more argument
			declarations.  There are three forms:
				<span class="s">{name}</span>: <span class="s">{type}</span>
				<span class="s">{name}</span> <a href="change.txt.html#%3D" class="d">=</a> <span class="s">{value}</span>
				<span class="s">{name}</span>: <span class="s">{type}</span> <a href="change.txt.html#%3D" class="d">=</a> <span class="s">{value}</span>
			The first form <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> mandatory argument.  So, the
			declaration <a href="vim_faq.txt.html#must" class="d">must</a> provide <a href="insert.txt.html#a" class="d">a</a> type.  Example: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1077(x): void
			      <a href="pattern.txt.html#%23" class="d">#</a> E1077: Missing argument type for <a href="change.txt.html#x" class="d">x</a>
			  enddef
<a href="change.txt.html#%3C" class="d">&lt;</a>
			For the second form, because the declaration does not
			specify it, Vim infers the type.  For both second and
			third forms, <a href="insert.txt.html#a" class="d">a</a> default <span class="s">{value}</span> applies when the
			caller omits it.  Examples: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def SecondForm(arg <a href="change.txt.html#%3D" class="d">=</a> "Hi"): void
			      echo $'2. arg <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> "<span class="s">{arg-&gt;typename()}</span>" type <a href="motion.txt.html#%27" class="d">'</a> ..
			           $'and the default value of arg <a href="motion.txt.html#is" class="d">is</a> "<span class="s">{arg}</span>"<a href="motion.txt.html#%27" class="d">'</a>
			  enddef
			  SecondForm()
			  def ThirdForm(arg2: number <a href="change.txt.html#%3D" class="d">=</a> 9): void
			      echo $'3. default value of arg2 <a href="motion.txt.html#is" class="d">is</a> <span class="s">{arg2}</span>'
			  enddef
			  ThirdForm()
<a href="change.txt.html#%3C" class="d">&lt;</a>							<span id="E1123" class="t">E1123</span>
			Arguments in <a href="insert.txt.html#a" class="d">a</a> builtin function called in <a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span>
			function <a href="vim_faq.txt.html#must" class="d">must</a> have commas between arguments: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1123(a: number, <a href="eval.txt.html#b%3A" class="d">b:</a> number): void
			      echo max(a b)
			      <a href="pattern.txt.html#%23" class="d">#</a> E1123: Missing comma before argument: b)
			  enddef
			  F_1123(1, 2)
<a href="change.txt.html#%3C" class="d">&lt;</a>							<span id="E1003" class="t">E1003</span> <span id="E1027" class="t">E1027</span> <span id="E1096" class="t">E1096</span>
			The type of value used with <span class="e">:return</span> <a href="vim_faq.txt.html#must" class="d">must</a> match
			<span class="s">{return-type}</span>.  When <span class="s">{return-type}</span> <a href="motion.txt.html#is" class="d">is</a> omitted or <a href="motion.txt.html#is" class="d">is</a>
			"void" the function <a href="motion.txt.html#is" class="d">is</a> not allowed to return
			anything.  Examples: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1003(): bool
			      return  <a href="pattern.txt.html#%23" class="d">#</a> E1003: Missing return value
			  enddef
			  F_1003()
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1027(): bool
			      echo <a href="vim9.txt.html#false" class="d">false</a>  <a href="pattern.txt.html#%23" class="d">#</a> E1027: Missing return statement
			  enddef
			  F_1027()
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1096(): void
			      return <a href="vim9.txt.html#false" class="d">false</a>  <a href="pattern.txt.html#%23" class="d">#</a> E1096: Returning <a href="insert.txt.html#a" class="d">a</a> value <a href="userfunc.txt.html#..." class="d">...</a>
			  enddef
			  F_1096()
<a href="change.txt.html#%3C" class="d">&lt;</a>							<span id="E1056" class="t">E1056</span> <span id="E1059" class="t">E1059</span>
			When "<a href="cmdline.txt.html#%3A" class="d">:</a> <span class="s">{return-type}</span>" <a href="motion.txt.html#is" class="d">is</a> specified, <span class="s">{return-type}</span>
			cannot be omitted (leaving <a href="insert.txt.html#a" class="d">a</a> hanging colon).  The "<a href="cmdline.txt.html#%3A" class="d">:</a> "
			also cannot be preceded by white space.  Examples: 
<span class="e"></span>
<span class="e">			  def F_1056():</span>
<span class="e">                              # E1056: Expected a type:</span>
<span class="e">			  enddef</span>
<span class="e">			  def F_1059() : bool</span>
<span class="e">                              # E1059: No white space allowed before colon:...</span>
<span class="e">			  enddef</span>

			The function will be compiled into instructions when
			called or when either <span class="e">:defcompile</span> or <span class="e">:disassemble</span> <a href="motion.txt.html#is" class="d">is</a>
			used.  (For an example, see <a href="vim9.txt.html#%3Adisassemble" class="l">:disassemble</a>.)  <a href="autocmd.txt.html#Syntax" class="d">Syntax</a>
			and type <a href="message.txt.html#errors" class="d">errors</a> will be produced <a href="motion.txt.html#at" class="d">at</a> that time.

							<span id="E1058" class="t">E1058</span>
			It <a href="motion.txt.html#is" class="d">is</a> possible to nest <span class="e">:def</span> inside another <span class="e">:def</span> or
			<span class="e">:function</span> only up to 49 levels deep.  At 50 or more
			levels, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#E1058" class="l">E1058</a> error.

							<span id="E1117" class="t">E1117</span>
			[!] <a href="motion.txt.html#is" class="d">is</a> allowed only in legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> because <a href="motion.txt.html#it" class="d">it</a>
			permits function redefinition (as with <span class="e">:function</span>!).
			In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, <a href="change.txt.html#%21" class="d">!</a> <a href="motion.txt.html#is" class="d">is</a> not allowed because <a href="map.txt.html#script-local" class="d">script-local</a>
			<a href="eval.txt.html#functions" class="d">functions</a> cannot be deleted or redefined, though they
			can be removed by reloading the script.  Also, nested
			<a href="eval.txt.html#functions" class="d">functions</a> cannot use <a href="change.txt.html#%21" class="d">!</a> for redefinition.  Examples: 
<span class="e"></span>
<span class="e">			  " Legacy Vim script :def! example</span>
<span class="e">			  def! LegacyFunc()</span>
<span class="e">			      echo "def! is allowed in a legacy Vim script"</span>
<span class="e">			  enddef</span>
<span class="e">			  call LegacyFunc()</span>
 &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def Func()
			      def! InnerFunc()
			          <a href="pattern.txt.html#%23" class="d">#</a> E1117: Cannot use <a href="change.txt.html#%21" class="d">!</a> with nested <a href="vim9.txt.html#%3Adef" class="d">:def</a>
			      enddef
			  enddef
			  Func()
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def! F_477(): void  <a href="pattern.txt.html#%23" class="d">#</a> E477: No <a href="change.txt.html#%21" class="d">!</a> allowed
			  enddef
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1084(): void
			  enddef
			  delfunction! F_1084
			  <a href="pattern.txt.html#%23" class="d">#</a> E1084: Cannot delete <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> function F_1084
<a href="change.txt.html#%3C" class="d">&lt;</a>
			<span class="n">Note:</span> The generic error <span id="E1028" class="t">E1028</span> <a href="motion.txt.html#%28" class="d">(</a>"Compiling <a href="vim9.txt.html#%3Adef" class="d">:def</a>
			function failed"<a href="motion.txt.html#%29" class="d">)</a> indicates an undeterminable error
			during compilation.  If reproducible, <a href="motion.txt.html#it" class="d">it</a> may be
			reported <a href="motion.txt.html#at" class="d">at</a> <a class="u" href="https://github.com/vim/vim/issues">https://github.com/vim/vim/issues</a> <a href="motion.txt.html#as" class="d">as</a>
			<a href="motion.txt.html#it" class="d">it</a> could represent <a href="insert.txt.html#a" class="d">a</a> gap in Vim's error reporting.

					<span id="%3Aenddef" class="t">:enddef</span> <span id="E1057" class="t">E1057</span> <span id="E1152" class="t">E1152</span> <span id="E1173" class="t">E1173</span>
<a href="vim9.txt.html#%3Aenddef" class="d">:enddef</a>			End of <a href="insert.txt.html#a" class="d">a</a> function defined with <span class="e">:def</span>.  It should be on
			<a href="insert.txt.html#a" class="d">a</a> line by itself.  Examples: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def MyFunc()
			  echo 'Do Something' | enddef
			  <a href="pattern.txt.html#%23" class="d">#</a> E1057: Missing <a href="vim9.txt.html#%3Aenddef" class="d">:enddef</a>
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1173()
			  enddef echo 'X'
			  <a href="pattern.txt.html#%23" class="d">#</a> E1173: Text found after enddef: echo 'X'
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1152()
			      function X()
			      enddef  <a href="pattern.txt.html#%23" class="d">#</a> E1152: Mismatched enddef
			  enddef
<a href="change.txt.html#%3C" class="d">&lt;</a>
You may also find this wiki useful.  It was written by an early adopter of
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> script: <a class="u" href="https://github.com/lacygoill/wiki/blob/master/vim/vim9.md">https://github.com/lacygoill/wiki/blob/master/vim/vim9.md</a>

If the <a href="usr_41.txt.html#script" class="d">script</a> the <span class="e">:def</span> function <a href="motion.txt.html#is" class="d">is</a> defined in <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, <a href="map.txt.html#script-local" class="d">script-local</a>
<a href="eval.txt.html#variables" class="d">variables</a> <a href="vim_faq.txt.html#must" class="d">must</a> be accessed without using the "s:" prefix.  They <a href="vim_faq.txt.html#must" class="d">must</a> be
defined before the function <a href="motion.txt.html#is" class="d">is</a> compiled and there <a href="motion.txt.html#is" class="d">is</a> no way to avoid <a href="message.txt.html#errors" class="d">errors</a>
(e.g., by using <a href="builtin.txt.html#exists%28%29" class="l">exists()</a><a href="motion.txt.html#%29" class="d">)</a> to conditionally skip undeclared variables.
For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def MyVim9def()
	    echo unus       <a href="pattern.txt.html#%23" class="d">#</a> Echoes 1
	    <a href="pattern.txt.html#%23" class="d">#</a> echo s:unus   <a href="pattern.txt.html#%23" class="d">#</a> This would be <a href="vim9.txt.html#E1268" class="d">E1268</a> (Cannot use s: in Vim9)
	    if exists('duo')
	        <a href="pattern.txt.html#%23" class="d">#</a> echo duo  <a href="pattern.txt.html#%23" class="d">#</a> This would be <a href="eval.txt.html#E1001" class="d">E1001</a> (Variable not found: duo)
	    endif
	enddef
	var unus: number <a href="change.txt.html#%3D" class="d">=</a> 1
	MyVim9def()         <a href="pattern.txt.html#%23" class="d">#</a> MyVim9def <a href="motion.txt.html#is" class="d">is</a> compiled <a href="motion.txt.html#%28" class="d">(</a>"duo" does not exist yet)
	var duo: number <a href="change.txt.html#%3D" class="d">=</a> 2
<a href="change.txt.html#%3C" class="d">&lt;</a>
If the <a href="usr_41.txt.html#script" class="d">script</a> the <span class="e">:def</span> function <a href="motion.txt.html#is" class="d">is</a> defined in <a href="motion.txt.html#is" class="d">is</a> legacy Vim script,
<a href="map.txt.html#script-local" class="d">script-local</a> <a href="eval.txt.html#variables" class="d">variables</a> may be accessed with or without the "s:" prefix.
However, using "s:" may defer variable resolution to runtime, avoiding
compilation <a href="message.txt.html#errors" class="d">errors</a> for <a href="eval.txt.html#variables" class="d">variables</a> that may not exist yet, <a href="motion.txt.html#as" class="d">as</a> this example
explains: 
<span class="e"></span>
<span class="e">	" legacy Vim script</span>
<span class="e">	def! MyLegacyDef(): void</span>
<span class="e">	    echo [unus, s:unus]   # Echoes [1, 1]</span>
<span class="e">	    # (If uncommented) First sourcing of 'echo s:duo' is E121 and</span>
<span class="e">	    # causes a compilation error; subsequent sourcing echoes 2:</span>
<span class="e">	    # echo s:duo</span>
<span class="e">	    if exists("s:duo")</span>
<span class="e">	        # First sourcing: skips echo; subsequent sourcing: echoes 2</span>
<span class="e">	        echo s:duo</span>
<span class="e">	    endif</span>
<span class="e">	    if exists("duo")</span>
<span class="e">	        # (If uncommented) First sourcing of 'echo duo' is E1001 and</span>
<span class="e">	        # causes a compilation error; subsequent sourcing echoes 2:</span>
<span class="e">	        # echo duo</span>
<span class="e">	    endif</span>
<span class="e">	enddef</span>
<span class="e">	let s:unus = 1</span>
<span class="e">	call MyLegacyDef()  " Calls MyLegacyDef() and compiles if not already</span>
<span class="e">	let s:duo = 2</span>
							<span id="E1269" class="t">E1269</span>
Script-local <a href="eval.txt.html#variables" class="d">variables</a> in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="vim_faq.txt.html#must" class="d">must</a> be declared <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a>
level.  They cannot be created in <a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span> function and may not be declared
in <a href="insert.txt.html#a" class="d">a</a> legacy function with the "s:" prefix.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	function F_1269()
	    let s:i_wish <a href="change.txt.html#%3D" class="d">=</a> <a href="eval.txt.html#v%3Atrue" class="d">v:true</a>
	endfunction
	F_1269()
	<a href="pattern.txt.html#%23" class="d">#</a> E1269: Cannot create <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> variable in <a href="insert.txt.html#a" class="d">a</a> function: s:i_wish
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="%3Adefc" class="t">:defc</span> <span id="%3Adefcompile" class="t">:defcompile</span>
:defc[ompile]		Compile <a href="eval.txt.html#functions" class="d">functions</a> and classes <a href="motion.txt.html#%28" class="d">(</a><a href="vim9class.txt.html#class-compile" class="l">class-compile</a><a href="motion.txt.html#%29" class="d">)</a>
			defined in the current <a href="usr_41.txt.html#script" class="d">script</a> that were not compiled
			yet.  This will report any <a href="message.txt.html#errors" class="d">errors</a> found during
			compilation.

			Example: When the three lines (up to and including
			<span class="e">enddef</span>) are sourced, there <a href="motion.txt.html#is" class="d">is</a> no error because the
			<a href="vim9.txt.html#Vim9" class="d">Vim9</a> <span class="e">:def</span> function <a href="motion.txt.html#is" class="d">is</a> not compiled.  However, if all
			four lines are sourced, compilation fails: &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  def F_1027(): <a href="eval.txt.html#string" class="d">string</a>
			  enddef
			  defcompile F_1027  <a href="pattern.txt.html#%23" class="d">#</a> E1027: Missing return statement

:defc[ompile] MyClass	Compile all methods in <a href="insert.txt.html#a" class="d">a</a> class.  (See <a href="vim9.txt.html#%3Adisassemble" class="l">:disassemble</a>
			for an example.)

:defc[ompile] <span class="s">{func}</span>
:defc[ompile] debug <span class="s">{func}</span>
:defc[ompile] <a href="repeat.txt.html#profile" class="d">profile</a> <span class="s">{func}</span>
			Compile function <span class="s">{func}</span>, if needed.  Use "debug" and
			"<a href="repeat.txt.html#profile" class="d">profile</a>" to specify the compilation mode.
			This will report any <a href="message.txt.html#errors" class="d">errors</a> found during compilation.
			<span class="s">{func}</span> can also be "ClassName.functionName" to
			compile <a href="insert.txt.html#a" class="d">a</a> function or <a href="eval.txt.html#method" class="d">method</a> in <a href="insert.txt.html#a" class="d">a</a> class.
			<span class="s">{func}</span> can also be "ClassName" to compile all
			<a href="eval.txt.html#functions" class="d">functions</a> and methods in <a href="insert.txt.html#a" class="d">a</a> class.

						<span id="%3Adisa" class="t">:disa</span> <span id="%3Adisassemble" class="t">:disassemble</span>
:disa[ssemble] <span class="s">{func}</span>	Show the instructions generated for <span class="s">{func}</span>.
			This <a href="motion.txt.html#is" class="d">is</a> for debugging and testing.
			If <span class="s">{func}</span> <a href="motion.txt.html#is" class="d">is</a> not found, error <span id="E1061" class="t">E1061</span> occurs.
			<span class="s">{func}</span> can also be "ClassName.functionName" to
			disassemble <a href="insert.txt.html#a" class="d">a</a> function in <a href="insert.txt.html#a" class="d">a</a> class.
			The following example demonstrates using <span class="e">:defcompile</span>
			with <a href="insert.txt.html#a" class="d">a</a> <a href="vim9class.txt.html#class" class="l">class</a> and <span class="e">:disassemble</span> with <a href="insert.txt.html#a" class="d">a</a>
			"ClassName.functionName" (positioning the cursor on
			the last line of the visually sourced script): &gt;vim9

			  <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			  <a href="vim9class.txt.html#class" class="d">class</a> Line
			      var lnum: number
			      def new(this.lnum)
			      enddef
			      def SetLnum()
			          cursor(this.lnum, 52)
			      enddef
			  endclass
			  defcompile Line
			  disassemble Line.SetLnum
			  var vlast: Line <a href="change.txt.html#%3D" class="d">=</a> Line.new(line("<a href="motion.txt.html#%27%3E" class="d">'&gt;</a>"))
			  vlast.SetLnum()  <a href="pattern.txt.html#%23" class="d">#</a> Cursor <a href="motion.txt.html#is" class="d">is</a> positioned here-&gt;_

:disa[ssemble] <a href="repeat.txt.html#profile" class="d">profile</a> <span class="s">{func}</span>
			Like <span class="e">:disassemble</span> but with the instructions used for
			profiling.

:disa[ssemble] debug <span class="s">{func}</span>
			Like <span class="e">:disassemble</span> but with the instructions used for
			debugging.

  <span class="n">Note:</span> For command line completion of <span class="s">{func}</span>, <a href="map.txt.html#script-local" class="d">script-local</a> <a href="eval.txt.html#functions" class="d">functions</a>
	are shown with their <a href="map.txt.html#%3CSNR%3E" class="s">&lt;SNR&gt;</a>.  Depending on options, including
	<a href="builtin.txt.html#wildmenumode%28%29" class="l">wildmenumode()</a><a href="motion.txt.html#%2C" class="d">,</a> completion may work with "s:"<a href="motion.txt.html#%2C" class="d">,</a> "&lt;S"<a href="motion.txt.html#%2C" class="d">,</a> or the function
	name directly.  (For example, in Vim started with <a href="starting.txt.html#-u" class="l">-u</a> NONE, "<a href="vim9.txt.html#%3Adisa" class="d">:disa</a> s:"
	and <a href="cmdline.txt.html#c_CTRL-E" class="l">c_CTRL-E</a> lists <a href="map.txt.html#script-local" class="d">script-local</a> function names.)


<span class="h">Limitations </span>

Variables local to <span class="e">:def</span> <a href="eval.txt.html#functions" class="d">functions</a> are not visible to <a href="eval.txt.html#string" class="d">string</a> evaluation.
The following example shows that the <a href="map.txt.html#script-local" class="d">script-local</a> constant "SCRIPT_LOCAL" <a href="motion.txt.html#is" class="d">is</a>
visible whereas the function-local constant "DEF_LOCAL" <a href="motion.txt.html#is" class="d">is</a> not: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	const SCRIPT_LOCAL <a href="change.txt.html#%3D" class="d">=</a> ['A', 'script-local', <a href="options.txt.html#%27list%27" class="o">'list'</a>]
	def MapList(scope: string): list&lt;string&gt;
	    const DEF_LOCAL: list&lt;string&gt; <a href="change.txt.html#%3D" class="d">=</a> ['A', 'def-local', <a href="options.txt.html#%27list%27" class="o">'list'</a>]
	    if scope <a href="change.txt.html#%3D%3D" class="d">==</a> 'script local'
	        return [1]-&gt;map('SCRIPT_LOCAL[v:val]')
	    else
	        return [1]-&gt;map('DEF_LOCAL[v:val]')
	    endif
	enddef
	echo 'script local'-&gt;MapList()	<a href="pattern.txt.html#%23" class="d">#</a> Echoes ['script-local']
	echo 'def local'-&gt;MapList()	<a href="pattern.txt.html#%23" class="d">#</a> E121: Undefined variable: DEF_LOCAL
<a href="change.txt.html#%3C" class="d">&lt;</a>
The map argument <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> expression, which <a href="motion.txt.html#is" class="d">is</a> evaluated without the
function scope.  Instead, in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, use <a href="insert.txt.html#a" class="d">a</a> lambda: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def MapList(): list&lt;string&gt;
	    const DEF_LOCAL: list&lt;string&gt; <a href="change.txt.html#%3D" class="d">=</a> ['A', 'def-local', <a href="options.txt.html#%27list%27" class="o">'list'</a>]
	    return [1]-&gt;map((_, v) =&gt; DEF_LOCAL[v])
	enddef
	echo MapList()			<a href="pattern.txt.html#%23" class="d">#</a> Echoes ['def-local']
<a href="change.txt.html#%3C" class="d">&lt;</a>
For commands that are not compiled, such <a href="motion.txt.html#as" class="d">as</a> <span class="e">:edit</span>, <a href="editing.txt.html#backtick-expansion" class="l">backtick-expansion</a> can
be used and <a href="motion.txt.html#it" class="d">it</a> can use the local scope.  Example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def EditNewBlah()
	    var fname: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> 'blah.txt'
	    split
	    edit <span class="e">=fname</span>
	enddef
	EditNewBlah()  <a href="pattern.txt.html#%23" class="d">#</a> <a href="insert.txt.html#A" class="d">A</a> new split <a href="motion.txt.html#is" class="d">is</a> created <a href="motion.txt.html#as" class="d">as</a> buffer 'blah.txt'
<a href="change.txt.html#%3C" class="d">&lt;</a>
Closures defined in <a href="insert.txt.html#a" class="d">a</a> loop can either share <a href="insert.txt.html#a" class="d">a</a> variable or each have their own
copy, depending on where the variable <a href="motion.txt.html#is" class="d">is</a> declared.  With <a href="insert.txt.html#a" class="d">a</a> variable declared
outside the loop, all closures <a href="intro.txt.html#reference" class="d">reference</a> the same shared variable.
The following example demonstrates the consequences, with the "outloop"
variable existing only once: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var flist: list&lt;func&gt;
	def ClosureEg(n: number): void
	    var outloop: number <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#0" class="d">0</a>  <a href="pattern.txt.html#%23" class="d">#</a> outloop <a href="motion.txt.html#is" class="d">is</a> declared outside the loop!
	    for <a href="insert.txt.html#i" class="d">i</a> in range(n)
	        outloop <a href="change.txt.html#%3D" class="d">=</a> <a href="insert.txt.html#i" class="d">i</a>
	        flist[i] <a href="change.txt.html#%3D" class="d">=</a> (): number =&gt; outloop  <a href="pattern.txt.html#%23" class="d">#</a> Closures <a href="intro.txt.html#ref" class="d">ref</a> the same var
	    endfor
	    echo range(n)-&gt;map((i, _) =&gt; flist[i]())
	enddef
	ClosureEg(4)  <a href="pattern.txt.html#%23" class="d">#</a> Echoes [3, 3, 3, 3]
<a href="change.txt.html#%3C" class="d">&lt;</a>
All closures <a href="change.txt.html#put" class="d">put</a> in the <a href="eval.txt.html#list" class="d">list</a> refer to the same instance, which, in the end,
<a href="motion.txt.html#is" class="d">is</a> 3.

However, when the variable <a href="motion.txt.html#is" class="d">is</a> declared inside the loop, each <a href="eval.txt.html#closure" class="d">closure</a> gets its
own copy, <a href="motion.txt.html#as" class="d">as</a> shown in this example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var flist: list&lt;func&gt;
	def ClosureEg(n: number): void
	    for <a href="insert.txt.html#i" class="d">i</a> in range(n)
	        var inloop: number <a href="change.txt.html#%3D" class="d">=</a> <a href="insert.txt.html#i" class="d">i</a>  <a href="pattern.txt.html#%23" class="d">#</a> inloop <a href="motion.txt.html#is" class="d">is</a> declared inside the loop
	        flist[i] <a href="change.txt.html#%3D" class="d">=</a> (): number =&gt; inloop  <a href="pattern.txt.html#%23" class="d">#</a> Closures <a href="intro.txt.html#ref" class="d">ref</a> each inloop
	    endfor
	    echo range(n)-&gt;map((i, _) =&gt; flist[i]())
	enddef
	ClosureEg(4)  <a href="pattern.txt.html#%23" class="d">#</a> Echoes [0, 1, 2, 3]

Another way to have <a href="insert.txt.html#a" class="d">a</a> separate context for each <a href="eval.txt.html#closure" class="d">closure</a> <a href="motion.txt.html#is" class="d">is</a> to call <a href="insert.txt.html#a" class="d">a</a>
function to define it: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def GetClosure(i: number): func
	    var infunc: number <a href="change.txt.html#%3D" class="d">=</a> <a href="insert.txt.html#i" class="d">i</a>
	    return (): number =&gt; infunc
	enddef
	var flist: list&lt;func&gt;
	def ClosureEg(n: number): void
	    for <a href="insert.txt.html#i" class="d">i</a> in range(n)
	        flist[i] <a href="change.txt.html#%3D" class="d">=</a> GetClosure(i)
	    endfor
	    echo range(n)-&gt;map((i, _) =&gt; flist[i]())
	enddef
	ClosureEg(4)  <a href="pattern.txt.html#%23" class="d">#</a> Echoes [0, 1, 2, 3]
<a href="change.txt.html#%3C" class="d">&lt;</a>							<span id="E1271" class="t">E1271</span>
<a href="insert.txt.html#A" class="d">A</a> <a href="eval.txt.html#closure" class="d">closure</a> <a href="vim_faq.txt.html#must" class="d">must</a> be compiled in the context that <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> defined in, so that
<a href="eval.txt.html#variables" class="d">variables</a> in that context can be found.  This mostly happens correctly,
except when <a href="insert.txt.html#a" class="d">a</a> function <a href="motion.txt.html#is" class="d">is</a> marked for debugging with <span class="e">:breakadd</span> after <a href="motion.txt.html#it" class="d">it</a> was
compiled.  Make sure to define the breakpoint before compiling the outer
function.
							<span id="E1248" class="t">E1248</span>
In some situations, such <a href="motion.txt.html#as" class="d">as</a> when <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="eval.txt.html#closure" class="d">closure</a> which captures local <a href="eval.txt.html#variables" class="d">variables</a>
<a href="motion.txt.html#is" class="d">is</a> converted to <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> and then executed, an error occurs.  This happens
because the <a href="eval.txt.html#string" class="d">string</a> execution context cannot access the local <a href="eval.txt.html#variables" class="d">variables</a> from
the original context where the <a href="eval.txt.html#closure" class="d">closure</a> was defined.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def F_1248(): void
	    var n: number
	    var F: func <a href="change.txt.html#%3D" class="d">=</a> () =&gt; <a href="motion.txt.html#%7B" class="d">{</a>
	        <a href="pattern.txt.html#n" class="d">n</a> += 1
	    <a href="motion.txt.html#%7D" class="d">}</a>
	    try
	        execute printf("call %s()"<a href="motion.txt.html#%2C" class="d">,</a> F)
	    catch
	        echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a>
	    endtry
	enddef
	F_1248()  <a href="pattern.txt.html#%23" class="d">#</a> Vim(call):E1248: Closure called from invalid context

In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, <a href="insert.txt.html#a" class="d">a</a> loop variable <a href="motion.txt.html#is" class="d">is</a> invalid after the loop <a href="motion.txt.html#is" class="d">is</a> closed.
For example, this <a href="builtin.txt.html#timer" class="d">timer</a> will echo <a href="motion.txt.html#0" class="d">0</a> to 2 on separate lines.  However, if
the variable "<a href="pattern.txt.html#n" class="d">n</a>" <a href="motion.txt.html#is" class="d">is</a> used after the <span class="e">:endfor</span>, that <a href="motion.txt.html#is" class="d">is</a> an <a href="eval.txt.html#E121" class="l">E121</a> error: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	for <a href="pattern.txt.html#n" class="d">n</a> in range(3)
	    var nr: number <a href="change.txt.html#%3D" class="d">=</a> <a href="pattern.txt.html#n" class="d">n</a>
	    timer_start(1000 * n, (_) =&gt; <a href="motion.txt.html#%7B" class="d">{</a>
	        echowindow nr
	    })
	endfor
	try
	    echowindow <a href="pattern.txt.html#n" class="d">n</a>
	catch
	    echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a>
	endtry
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">Note:</span> Using <span class="e">:echowindow</span> <a href="motion.txt.html#is" class="d">is</a> useful in <a href="insert.txt.html#a" class="d">a</a> <a href="builtin.txt.html#timer" class="d">timer</a> because <a href="message.txt.html#messages" class="d">messages</a> <a href="motion.txt.html#go" class="d">go</a>
		into <a href="insert.txt.html#a" class="d">a</a> <a href="popup.txt.html#popup" class="d">popup</a> and will not interfere with what the user <a href="motion.txt.html#is" class="d">is</a>
		doing when <a href="motion.txt.html#it" class="d">it</a> triggers.


<span class="h">Converting a :function to a :def</span>
					<span id="convert_legacy_function_to_vim9" class="t">convert_legacy_function_to_vim9</span>
					<span id="convert_%3Afunction_to_%3Adef" class="t">convert_:function_to_:def</span>
There are many changes that need to be made to convert <a href="insert.txt.html#a" class="d">a</a> <span class="e">:function</span> to
<a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span> function.  The following are some of them:

<a href="motion.txt.html#-" class="d">-</a> Change <span class="e">let</span> used to declare <a href="eval.txt.html#variables" class="d">variables</a> to one of <span class="e">var</span>, <span class="e">const</span>, or <span class="e">final</span>,
  and remove the "s:" from each <a href="eval.txt.html#script-variable" class="l">script-variable</a><a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> Change <span class="e">func</span> or <span class="e">function</span> to <span class="e">def</span>.
<a href="motion.txt.html#-" class="d">-</a> Change <span class="e">endfunc</span> or <span class="e">endfunction</span> to <span class="e">enddef</span>.
<a href="motion.txt.html#-" class="d">-</a> Add the applicable type (or "any"<a href="motion.txt.html#%29" class="d">)</a> to each function argument.
<a href="motion.txt.html#-" class="d">-</a> Remove "a:" from each <a href="userfunc.txt.html#function-argument" class="l">function-argument</a><a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> Remove inapplicable <a href="options.txt.html#options" class="d">options</a> such <a href="motion.txt.html#as" class="d">as</a> <a href="userfunc.txt.html#%3Afunc-range" class="l">:func-range</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="userfunc.txt.html#%3Afunc-abort" class="l">:func-abort</a><a href="motion.txt.html#%2C" class="d">,</a>
  <a href="userfunc.txt.html#%3Afunc-dict" class="l">:func-dict</a><a href="motion.txt.html#%2C" class="d">,</a> and <a href="userfunc.txt.html#%3Afunc-closure" class="l">:func-closure</a><a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> If the function returns something, add the return type.  (Ideally, add
  "void" if <a href="motion.txt.html#it" class="d">it</a> does not return anything.)
<a href="motion.txt.html#-" class="d">-</a> Remove line continuation backslashes from places they are not required.
<a href="motion.txt.html#-" class="d">-</a> Remove <span class="e">let</span> for assigning values to <a href="eval.txt.html#g%3A" class="l">g:</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="eval.txt.html#b%3A" class="l">b:</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="eval.txt.html#w%3A" class="l">w:</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="eval.txt.html#t%3A" class="l">t:</a><a href="motion.txt.html#%2C" class="d">,</a> or <a href="eval.txt.html#l%3A" class="l">l:</a> variables.
<a href="motion.txt.html#-" class="d">-</a> Rewrite <a href="eval.txt.html#lambda" class="l">lambda</a> expressions in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> (see <a href="vim9.txt.html#vim9-lambda" class="l">vim9-lambda</a>).
<a href="motion.txt.html#-" class="d">-</a> Change comments to start with <a href="pattern.txt.html#%23" class="d">#</a> (preceded by white space) instead of "<a href="repeat.txt.html#." class="d">.</a>
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#Insert" class="d">Insert</a> white <a href="intro.txt.html#space" class="d">space</a> in expressions where required (see <a href="vim9.txt.html#vim9-white-space" class="l">vim9-white-space</a>).
<a href="motion.txt.html#-" class="d">-</a> Change "<a href="repeat.txt.html#." class="d">.</a>" used for <a href="eval.txt.html#string" class="d">string</a> concatenation to " .. "<a href="repeat.txt.html#." class="d">.</a>  (Alternatively, use
  an <a href="eval.txt.html#interpolated-string" class="l">interpolated-string</a>.)

The following legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> and <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> examples demonstrate all
those differences.  First, legacy Vim script: 
<span class="e"></span>
<span class="e">	let s:lnum=0</span>
<span class="e">	function Leg8(arg) abort</span>
<span class="e">	    let l:pre=['Result',</span>
<span class="e">	      \': ']</span>
<span class="e">	    let b:arg=a:arg</span>
<span class="e">	    let s:lnum+=2</span>
<span class="e">	    let b:arg*=4</span>
<span class="e">	    let l:result={pre-&gt;join(pre,'')}(l:pre)</span>
<span class="e">	    return l:result.(b:arg+s:lnum)"no space before comment</span>
<span class="e">	endfunction</span>
<span class="e">	call Leg8(10)-&gt;popup_notification(#{time: 3000})" Pops up 'Result: 42'</span>
<span class="e"></span>
The equivalent in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var lnum: number
	def Vim9(arg: number): <a href="eval.txt.html#string" class="d">string</a>
	    final pre <a href="change.txt.html#%3D" class="d">=</a> ['Result',
	      ': <a href="motion.txt.html#%27%5D" class="d">']</a>
	    b:arg <a href="change.txt.html#%3D" class="d">=</a> arg
	    lnum += 2
	    b:arg *<a href="change.txt.html#%3D" class="d">=</a> 4
	    const RESULT: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> ((lpre) =&gt; join(lpre, ''))(pre)
	    return RESULT .. (b:arg <a href="motion.txt.html#%2B" class="d">+</a> lnum) <a href="pattern.txt.html#%23" class="d">#</a> <a href="intro.txt.html#space" class="d">space</a> required before <a href="pattern.txt.html#%23" class="d">#</a> comment
	enddef
	Vim9(10)-&gt;popup_notification({time: 3000}) <a href="pattern.txt.html#%23" class="d">#</a> Pops up 'Result: 42'

<a href="change.txt.html#%3C" class="d">&lt;</a>	<span class="n">Note:</span> This example also demonstrates (outside the <span class="e">:def</span> function):
		<a href="motion.txt.html#-" class="d">-</a> Removing "<a href="pattern.txt.html#%23" class="d">#</a>" from the legacy <a href="eval.txt.html#%23%7B%7D" class="l">#{}</a> <a href="motion.txt.html#-" class="d">-</a> see <a href="vim9.txt.html#vim9-literal-dict" class="l">vim9-literal-dict</a>
		<a href="motion.txt.html#-" class="d">-</a> Omitting <span class="e">:call</span> (allowed, though unnecessary in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script)


<span class="h">Calling a :def function in an expr option </span>
							<span id="expr-option-function" class="t">expr-option-function</span>
The value of <a href="insert.txt.html#a" class="d">a</a> few options, such <a href="motion.txt.html#as" class="d">as</a> <a href="options.txt.html#%27foldexpr%27" class="o">'foldexpr'</a>, <a href="motion.txt.html#is" class="d">is</a> an <a href="eval.txt.html#expression" class="d">expression</a> that <a href="motion.txt.html#is" class="d">is</a>
evaluated to get <a href="insert.txt.html#a" class="d">a</a> value.  The evaluation can have quite <a href="insert.txt.html#a" class="d">a</a> bit of overhead.
One way to minimize the overhead, and also to keep the option value simple,
<a href="motion.txt.html#is" class="d">is</a> to define <a href="insert.txt.html#a" class="d">a</a> compiled function and set the option to call <a href="motion.txt.html#it" class="d">it</a> without
arguments.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def MyFoldFunc(): <a href="eval.txt.html#string" class="d">string</a>
	    <a href="pattern.txt.html#%23" class="d">#</a> This matches start of line (^), followed by <a href="insert.txt.html#a" class="d">a</a> digit, <a href="insert.txt.html#a" class="d">a</a> full stop
	    <a href="pattern.txt.html#%23" class="d">#</a> <a href="insert.txt.html#a" class="d">a</a> <a href="intro.txt.html#space" class="d">space</a> or tab, an <a href="change.txt.html#uppercase" class="d">uppercase</a> character, with an empty next line
	    return getline(v:lnum) =~ '^[[:digit:]]\.[[:blank:]][[:upper:]]'
	        &amp;&amp; getline(v:lnum <a href="motion.txt.html#%2B" class="d">+</a> 1)-&gt;empty() <a href="pattern.txt.html#%3F" class="d">?</a> '&gt;1' <a href="cmdline.txt.html#%3A" class="d">:</a> '1'
	enddef
	set foldexpr=MyFoldFunc()
	set foldmethod=expr
	norm! <a href="fold.txt.html#zM" class="d">zM</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
  Warning: This <a href="usr_41.txt.html#script" class="d">script</a> creates and applies <a href="fold.txt.html#folds" class="d">folds</a> <a href="motion.txt.html#at" class="d">at</a> the "Heading 1" level of
	   this <a href="vim9.txt.html#vim9.txt" class="d">vim9.txt</a> <a href="helphelp.txt.html#help" class="d">help</a> buffer.  (You can use <a href="fold.txt.html#zR" class="l">zR</a><a href="motion.txt.html#%2C" class="d">,</a> in <a href="intro.txt.html#Normal" class="d">Normal</a> mode, to
	   open all the <a href="fold.txt.html#folds" class="d">folds</a> after sourcing the script.)


<span class="h">==============================================================================</span>

4. Types					<span id="vim9-types" class="t">vim9-types</span>

The following types, each shown with its corresponding internal <a href="eval.txt.html#v%3At_TYPE" class="l">v:t_TYPE</a>
variable, are supported:

	number					<a href="eval.txt.html#v%3At_number" class="l">v:t_number</a>
	<a href="eval.txt.html#string" class="d">string</a>					<a href="eval.txt.html#v%3At_string" class="l">v:t_string</a>
	func					<a href="eval.txt.html#v%3At_func" class="l">v:t_func</a>
	func: <span class="s">{type}</span>				<a href="eval.txt.html#v%3At_func" class="l">v:t_func</a>
	func({type}, ...)			<a href="eval.txt.html#v%3At_func" class="l">v:t_func</a>
	func({type}, ...): <span class="s">{type}</span>		<a href="eval.txt.html#v%3At_func" class="l">v:t_func</a>
	list&lt;{type}&gt;				<a href="eval.txt.html#v%3At_list" class="l">v:t_list</a>
	dict&lt;{type}&gt;				<a href="eval.txt.html#v%3At_dict" class="l">v:t_dict</a>
	float					<a href="eval.txt.html#v%3At_float" class="l">v:t_float</a>
	bool					<a href="eval.txt.html#v%3At_bool" class="l">v:t_bool</a>
	none					<a href="eval.txt.html#v%3At_none" class="l">v:t_none</a>
	<a href="channel.txt.html#job" class="d">job</a>					<a href="eval.txt.html#v%3At_job" class="l">v:t_job</a>
	<a href="channel.txt.html#channel" class="d">channel</a>					<a href="eval.txt.html#v%3At_channel" class="l">v:t_channel</a>
	<a href="eval.txt.html#blob" class="d">blob</a>					<a href="eval.txt.html#v%3At_blob" class="l">v:t_blob</a>
	<a href="vim9class.txt.html#class" class="d">class</a>					<a href="eval.txt.html#v%3At_class" class="l">v:t_class</a>
	<a href="vim9class.txt.html#object" class="d">object</a>					<a href="eval.txt.html#v%3At_object" class="l">v:t_object</a>
	<a href="vim9class.txt.html#typealias" class="d">typealias</a>				<a href="eval.txt.html#v%3At_typealias" class="l">v:t_typealias</a>
	<a href="vim9class.txt.html#enum" class="d">enum</a>					<a href="eval.txt.html#v%3At_enum" class="l">v:t_enum</a>
	<a href="vim9class.txt.html#enumvalue" class="d">enumvalue</a>				<a href="eval.txt.html#v%3At_enumvalue" class="l">v:t_enumvalue</a>
	tuple&lt;{type}&gt;				<a href="eval.txt.html#v%3At_tuple" class="l">v:t_tuple</a>
	tuple&lt;{type}, <span class="s">{type}</span>, ...&gt;		<a href="eval.txt.html#v%3At_tuple" class="l">v:t_tuple</a>
	tuple&lt;...list&lt;{type}&gt;&gt;			<a href="eval.txt.html#v%3At_tuple" class="l">v:t_tuple</a>
	tuple&lt;{type}, ...list&lt;{type}&gt;&gt;		<a href="eval.txt.html#v%3At_tuple" class="l">v:t_tuple</a>
	void

						 <span id="E1031" class="t">E1031</span> <span id="E1186" class="t">E1186</span>
These types can be used in declarations, though no simple value can have the
"void" type.  Trying to use <a href="insert.txt.html#a" class="d">a</a> void <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> value results in an error.  Examples: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def NoReturnValue(): void
	enddef
	try
	    const X: any <a href="change.txt.html#%3D" class="d">=</a> NoReturnValue()
	catch
	    echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a>	  <a href="pattern.txt.html#%23" class="d">#</a> E1031: Cannot use void value
	    try
	        echo NoReturnValue()
	    catch
	        echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a>  <a href="pattern.txt.html#%23" class="d">#</a> E1186: Expression does not result in <a href="insert.txt.html#a" class="d">a</a> <a href="userfunc.txt.html#..." class="d">...</a>
	    endtry
	endtry
<a href="change.txt.html#%3C" class="d">&lt;</a>						<span id="E1008" class="t">E1008</span> <span id="E1009" class="t">E1009</span> <span id="E1010" class="t">E1010</span> <span id="E1012" class="t">E1012</span>
Ill-formed declarations and mismatching types result in errors.  The following
are examples of <a href="message.txt.html#errors" class="d">errors</a> E1008, E1009, E1010, and E1012: &gt;vim9

	vim9cmd var <a href="eval.txt.html#l%3A" class="d">l:</a> <a href="eval.txt.html#list" class="d">list</a>
	vim9cmd var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;number
	vim9cmd var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;invalidtype&gt;
	vim9cmd var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> ['42']
<a href="change.txt.html#%3C" class="d">&lt;</a>
There <a href="motion.txt.html#is" class="d">is</a> no array type.  Instead, use either <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> or <a href="insert.txt.html#a" class="d">a</a> tuple.  Those types
may also be literals (constants).  In the following example, [5, 6] <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a>
literal and (7, <a href="motion.txt.html#%29" class="d">)</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#tuple" class="d">tuple</a> literal.  The echoed <a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> literal too: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> [1, 2]
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;...list&lt;number&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> (3, 4)
	echo [l, t, [5, 6], (7, )]
<a href="change.txt.html#%3C" class="d">&lt;</a>
							<span id="tuple-type" class="t">tuple-type</span>
<a href="insert.txt.html#A" class="d">A</a> <a href="eval.txt.html#tuple" class="d">tuple</a> type may be declared in the following ways:
tuple&lt;number&gt;			<a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#tuple" class="d">tuple</a> with <a href="insert.txt.html#a" class="d">a</a> single item of type <a href="eval.txt.html#Number" class="l">Number</a>
tuple&lt;number, string&gt;		<a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#tuple" class="d">tuple</a> with two items of type <a href="eval.txt.html#Number" class="l">Number</a> and
				<a href="eval.txt.html#String" class="l">String</a>
tuple&lt;number, float, bool&gt;	<a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#tuple" class="d">tuple</a> with three items of type <a href="eval.txt.html#Number" class="l">Number</a><a href="motion.txt.html#%2C" class="d">,</a>
				<a href="eval.txt.html#Float" class="l">Float</a> and <a href="eval.txt.html#Boolean" class="l">Boolean</a>
tuple&lt;...list&lt;number&gt;&gt;		<a href="insert.txt.html#a" class="d">a</a> variadic <a href="eval.txt.html#tuple" class="d">tuple</a> with zero or more items of
				type <a href="eval.txt.html#Number" class="l">Number</a>
tuple&lt;number, ...list&lt;string&gt;&gt;	<a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#tuple" class="d">tuple</a> with an item of type <a href="eval.txt.html#Number" class="l">Number</a> followed
				by zero or more items of type <a href="eval.txt.html#String" class="l">String</a>

Examples: 
<span class="e">    var myTuple: tuple&lt;number&gt; = (20,)</span>
<span class="e">    var myTuple: tuple&lt;number, string&gt; = (30, 'vim')</span>
<span class="e">    var myTuple: tuple&lt;number, float, bool&gt; = (40, 1.1, true)</span>
<span class="e">    var myTuple: tuple&lt;...list&lt;string&gt;&gt; = ('a', 'b', 'c')</span>
<span class="e">    var myTuple: tuple&lt;number, ...list&lt;string&gt;&gt; = (3, 'a', 'b', 'c')</span>

						<span id="variadic-tuple" class="t">variadic-tuple</span> <span id="E1539" class="t">E1539</span>
<a href="insert.txt.html#A" class="d">A</a> variadic <a href="eval.txt.html#tuple" class="d">tuple</a> has zero or more items of the same type.  The type of <a href="insert.txt.html#a" class="d">a</a>
variadic <a href="eval.txt.html#tuple" class="d">tuple</a> <a href="vim_faq.txt.html#must" class="d">must</a> <a href="intro.txt.html#end" class="d">end</a> with <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> type.  Examples: 
<span class="e">    var myTuple: tuple&lt;...list&lt;number&gt;&gt; = (1, 2, 3)</span>
<span class="e">    var myTuple: tuple&lt;...list&lt;string&gt;&gt; = ('a', 'b', 'c')</span>
<span class="e">    var myTuple: tuple&lt;...list&lt;bool&gt;&gt; = ()</span>

				    <span id="vim9-func-declaration" class="t">vim9-func-declaration</span> <span id="E1005" class="t">E1005</span> <span id="E1007" class="t">E1007</span>
				    <span id="vim9-partial-declaration" class="t">vim9-partial-declaration</span>
				    <span id="vim9-func-type" class="t">vim9-func-type</span>
<a href="insert.txt.html#A" class="d">A</a> function (or partial) may be declared in the following ways:
func				any kind of function reference, no type
				checking for arguments or return value
func: void			any number and type of arguments, no return
				value
func: <span class="s">{type}</span>			any number and type of arguments with specific
				return type

func()				function with no argument, does not return <a href="insert.txt.html#a" class="d">a</a>
				value
func(): void			same
func(): <span class="s">{type}</span>			function with no argument and return type

func({type})			function with argument type, does not return
				<a href="insert.txt.html#a" class="d">a</a> value
func({type}): <span class="s">{type}</span>		function with argument type and return type
func(?{type})			function with type of optional argument, does
				not return <a href="insert.txt.html#a" class="d">a</a> value
func(...list&lt;{type}&gt;)		function with type of <a href="eval.txt.html#list" class="d">list</a> for variable number
				of arguments, does not return <a href="insert.txt.html#a" class="d">a</a> value
func({type}, ?{type}, ...list&lt;{type}&gt;): <span class="s">{type}</span>
				function with:
				<a href="motion.txt.html#-" class="d">-</a> type of mandatory argument
				<a href="motion.txt.html#-" class="d">-</a> type of optional argument
				<a href="motion.txt.html#-" class="d">-</a> type of <a href="eval.txt.html#list" class="d">list</a> for variable number of
				  arguments
				<a href="motion.txt.html#-" class="d">-</a> return type

If the return type <a href="motion.txt.html#is" class="d">is</a> "void" the function does not return <a href="insert.txt.html#a" class="d">a</a> value.

The <a href="intro.txt.html#reference" class="d">reference</a> can also be <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#Partial" class="l">Partial</a><a href="motion.txt.html#%2C" class="d">,</a> in which <a href="change.txt.html#case" class="d">case</a> <a href="motion.txt.html#it" class="d">it</a> stores extra arguments
and/or <a href="insert.txt.html#a" class="d">a</a> dictionary, which are not visible to the caller.  Since they are
called in the same way, the declaration <a href="motion.txt.html#is" class="d">is</a> the same.  This interactive example
prompts for <a href="insert.txt.html#a" class="d">a</a> circle's radius and returns its area to two decimal places,
using <a href="insert.txt.html#a" class="d">a</a> partial: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def CircleArea(pi: float, radius: float): float
	    return pi * radius-&gt;pow(2)
	enddef
	const AREA: func(float): float <a href="change.txt.html#%3D" class="d">=</a> CircleArea-&gt;function([3.14])
	const RADIUS: float <a href="change.txt.html#%3D" class="d">=</a> "Enter <a href="insert.txt.html#a" class="d">a</a> radius value: "-&gt;input()-&gt;str2float()
	echo <a href="motion.txt.html#%24" class="d">$</a>"\nThe area of <a href="insert.txt.html#a" class="d">a</a> circle with <a href="insert.txt.html#a" class="d">a</a> radius of <span class="s">{RADIUS}</span> <a href="motion.txt.html#is" class="d">is</a> " ..
	     <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{AREA(RADIUS)}</span> <a href="motion.txt.html#%28" class="d">(</a>π to two d.p.)"
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="vim9-typealias-type" class="t">vim9-typealias-type</span>
Custom types <a href="motion.txt.html#%28" class="d">(</a><a href="vim9class.txt.html#typealias" class="l">typealias</a><a href="motion.txt.html#%29" class="d">)</a> can be defined with <span class="e">:type</span>.  They <a href="vim_faq.txt.html#must" class="d">must</a> start with
<a href="insert.txt.html#a" class="d">a</a> capital <a href="print.txt.html#letter" class="d">letter</a> (which avoids name clashes with either current or future
builtin types) similar to user functions.  This example creates <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> of
perfect squares and reports on <a href="builtin.txt.html#type%28%29" class="l">type()</a> (14, <a href="insert.txt.html#a" class="d">a</a> typealias) and the <a href="builtin.txt.html#typename%28%29" class="l">typename()</a><a href="cmdline.txt.html#%3A" class="d">:</a> &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	type Ln <a href="change.txt.html#%3D" class="d">=</a> list&lt;number&gt;
	final perfect_squares: Ln <a href="change.txt.html#%3D" class="d">=</a> [1, 4, 9, 16, 25]
	echo "Typename (Ln): " ..
	     <a href="motion.txt.html#%24" class="d">$</a>"<a href="builtin.txt.html#type%28%29" class="d">type()</a> <a href="motion.txt.html#is" class="d">is</a> <span class="s">{Ln-&gt;type()}</span> and <a href="builtin.txt.html#typename%28%29" class="d">typename()</a> <a href="motion.txt.html#is" class="d">is</a> <span class="s">{Ln-&gt;typename()}</span>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="E1105" class="t">E1105</span>
<a href="insert.txt.html#A" class="d">A</a> <a href="vim9class.txt.html#typealias" class="d">typealias</a> itself cannot be converted to <a href="insert.txt.html#a" class="d">a</a> string: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	type Ln <a href="change.txt.html#%3D" class="d">=</a> list&lt;number&gt;
	const FAILS: func <a href="change.txt.html#%3D" class="d">=</a> (): <a href="eval.txt.html#string" class="d">string</a> =&gt; <a href="motion.txt.html#%7B" class="d">{</a>
	    echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{Ln}</span>"  <a href="pattern.txt.html#%23" class="d">#</a> E1105: Cannot convert <a href="vim9class.txt.html#typealias" class="d">typealias</a> to <a href="eval.txt.html#string" class="d">string</a>
	    <a href="motion.txt.html#%7D" class="d">}</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
				    <span id="vim9-class-type" class="t">vim9-class-type</span>  <span id="vim9-interface-type" class="t">vim9-interface-type</span>
				    <span id="vim9-object-type" class="t">vim9-object-type</span>
<a href="insert.txt.html#A" class="d">A</a> <a href="vim9class.txt.html#class" class="l">class</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="vim9class.txt.html#object" class="l">object</a><a href="motion.txt.html#%2C" class="d">,</a> and <a href="vim9class.txt.html#interface" class="l">interface</a> may all be used <a href="motion.txt.html#as" class="d">as</a> types.  The following
interactive example prompts for <a href="insert.txt.html#a" class="d">a</a> float value and returns the area of two
different shapes.  It also reports on the <a href="builtin.txt.html#type%28%29" class="l">type()</a> and <a href="builtin.txt.html#typename%28%29" class="l">typename()</a> of the
classes, objects, and interface: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="vim9class.txt.html#interface" class="d">interface</a> Shape
	    def InfoArea(): tuple&lt;string, float&gt;
	endinterface
	<a href="vim9class.txt.html#class" class="d">class</a> Circle <a href="vim9class.txt.html#implements" class="d">implements</a> Shape
	    var radius: float
	    def InfoArea(): tuple&lt;string, float&gt;
	        return ('Circle <a href="motion.txt.html#%28" class="d">(</a>π × <a href="change.txt.html#r" class="d">r</a>²)', 3.141593 * this.radius-&gt;pow(2))
	    enddef
	endclass
	<a href="vim9class.txt.html#class" class="d">class</a> Square <a href="vim9class.txt.html#implements" class="d">implements</a> Shape
	    var side: float
	    def InfoArea(): tuple&lt;string, float&gt;
	        return ('Square (s²)', this.side-&gt;pow(2))
	    enddef
	endclass
	const INPUT: float <a href="change.txt.html#%3D" class="d">=</a> "Enter <a href="insert.txt.html#a" class="d">a</a> float value: "-&gt;input()-&gt;str2float()
	echo "\nAreas of shapes:"
	var myCircle: object&lt;Circle&gt; <a href="change.txt.html#%3D" class="d">=</a> Circle.new(INPUT)
	var mySquare: object&lt;Square&gt; <a href="change.txt.html#%3D" class="d">=</a> Square.new(INPUT)
	final shapes: list&lt;Shape&gt; <a href="change.txt.html#%3D" class="d">=</a> [myCircle, mySquare]
	for shape in shapes
	    const [N: string, A: float] <a href="change.txt.html#%3D" class="d">=</a> shape.InfoArea()
	    echo <a href="motion.txt.html#%24" class="d">$</a>"\t- <span class="s">{N}</span> has area of <span class="s">{A}</span>"
	endfor
	echo "\n\t\ttype()\ttypename()\n\t\t------\t----------"
	echo <a href="motion.txt.html#%24" class="d">$</a>"Circle\t\t{Circle-&gt;type()}\t{Circle-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"Square\t\t{Square-&gt;type()}\t{Square-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"Shape\t\t{Shape-&gt;type()}\t{Shape-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"MyCircle\t{myCircle-&gt;type()}\t{myCircle-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"MySquare\t{mySquare-&gt;type()}\t{mySquare-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"shapes\t\t{shapes-&gt;type()}\t{shapes-&gt;typename()}"
<a href="change.txt.html#%3C" class="d">&lt;</a>
					<span id="vim9-enum-type" class="t">vim9-enum-type</span>  <span id="vim9-enumvalue-type" class="t">vim9-enumvalue-type</span>
An <a href="vim9class.txt.html#enum" class="l">enum</a> may be used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#v%3At_enum" class="l">v:t_enum</a>).  Variables holding <a href="vim9class.txt.html#enum" class="d">enum</a> values
have the <a href="vim9class.txt.html#enumvalue" class="d">enumvalue</a> type <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#v%3At_enumvalue" class="l">v:t_enumvalue</a><a href="motion.txt.html#%29" class="d">)</a> <a href="motion.txt.html#at" class="d">at</a> runtime.  The following
interactive example prompts for <a href="insert.txt.html#a" class="d">a</a> character and returns information about
either <a href="insert.txt.html#a" class="d">a</a> square or <a href="insert.txt.html#a" class="d">a</a> rhombus.  It also reports on the <a href="builtin.txt.html#type%28%29" class="l">type()</a> and <a href="builtin.txt.html#typename%28%29" class="l">typename()</a>
of the <a href="vim9class.txt.html#enum" class="d">enum</a> and enumvalue: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="vim9class.txt.html#enum" class="d">enum</a> Quad
	    Square('four', <span class="o">'only'</span>),
	    Rhombus('opposite', <span class="o">'no'</span>)
	    var eq: <a href="eval.txt.html#string" class="d">string</a>
	    var ra: <a href="eval.txt.html#string" class="d">string</a>
	    def string(): <a href="eval.txt.html#string" class="d">string</a>
	        return <a href="motion.txt.html#%24" class="d">$</a>"\nA <span class="s">{this.name}</span> has " ..
	               <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{this.eq}</span> equal sides and <span class="s">{this.ra}</span> right angles\n\n"
	    enddef
	endenum
	echo "Rhombus (r) or Square (s)?"
	var myQuad: Quad <a href="change.txt.html#%3D" class="d">=</a> <a href="builtin.txt.html#getcharstr%28%29" class="d">getcharstr()</a> =~ '\c^R' <a href="pattern.txt.html#%3F" class="d">?</a> Quad.Rhombus <a href="cmdline.txt.html#%3A" class="d">:</a> Quad.Square
	echo myQuad.string() .. "\ttype()\ttypename()"
	echo <a href="motion.txt.html#%24" class="d">$</a>"Quad  \t{Quad-&gt;type()}  \t{Quad-&gt;typename()}"
	echo <a href="motion.txt.html#%24" class="d">$</a>"myQuad\t{myQuad-&gt;type()}\t{myQuad-&gt;typename()}"
<a href="change.txt.html#%3C" class="d">&lt;</a>
	 <span class="n">Notes:</span> This <a href="usr_41.txt.html#script" class="d">script</a> uses builtin <a href="eval.txt.html#method" class="d">method</a> "<a href="builtin.txt.html#string%28%29" class="d">string()</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="vim9class.txt.html#object-string%28%29" class="l">object-string()</a>).
		The <a href="builtin.txt.html#typename%28%29" class="d">typename()</a> of Quad and myQuad are the same <a href="motion.txt.html#%28" class="d">(</a>"enum&lt;Quad&gt;"<a href="motion.txt.html#%29" class="d">)</a>
		whereas the <a href="builtin.txt.html#type%28%29" class="d">type()</a> <a href="motion.txt.html#is" class="d">is</a> distinguished (myQuad returns 16,
		enumvalue, whereas Quad returns 15, enum).

<span class="h">Variable types and type casting	</span>
							<span id="variable-types" class="t">variable-types</span>
Variables declared in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> or in <a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span> function have <a href="insert.txt.html#a" class="d">a</a> type, either
specified explicitly or inferred from the initialization.

Global, buffer, <a href="windows.txt.html#window" class="d">window</a> and <a href="intro.txt.html#tab" class="d">tab</a> page <a href="eval.txt.html#variables" class="d">variables</a> <a href="diff.txt.html#do" class="d">do</a> not have <a href="insert.txt.html#a" class="d">a</a> specific type.
Consequently, their values may change <a href="motion.txt.html#at" class="d">at</a> any time, possibly <a href="change.txt.html#changing" class="d">changing</a> the type.
Therefore, in compiled code, the "any" type <a href="motion.txt.html#is" class="d">is</a> assumed.

This can be <a href="insert.txt.html#a" class="d">a</a> problem when stricter typing <a href="motion.txt.html#is" class="d">is</a> desired, for example, when
declaring <a href="insert.txt.html#a" class="d">a</a> list: 
<span class="e">	var l: list&lt;number&gt; = [1, b:two]</span>
Since Vim doesn't know the type of "b:two"<a href="motion.txt.html#%2C" class="d">,</a> the <a href="eval.txt.html#expression" class="d">expression</a> becomes list&lt;any&gt;.
<a href="insert.txt.html#A" class="d">A</a> runtime check verifies the <a href="eval.txt.html#list" class="d">list</a> matches the declared type before assignment.

							<span id="type-casting" class="t">type-casting</span>
To get more specific type checking, use type casting.  This checks the
variable's type before building the list, rather than checking whether
<a href="eval.txt.html#list" class="d">list</a> items match the declared type.  For example: 
<span class="e">	var l: list&lt;number&gt; = [1, &lt;number&gt;b:two]</span>

So, here the type cast checks whether "b:two" <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> number and gives an error
if <a href="motion.txt.html#it" class="d">it</a> isn't.

The difference <a href="motion.txt.html#is" class="d">is</a> demonstrated in the following example.  With funcref
variable "NTC"<a href="motion.txt.html#%2C" class="d">,</a> Vim infers the <a href="eval.txt.html#expression" class="d">expression</a> type "[1, b:two]" <a href="motion.txt.html#as" class="d">as</a> list&lt;any&gt;, then
verifies whether <a href="motion.txt.html#it" class="d">it</a> can be assigned to the list&lt;number&gt; return type.  With
funcref variable "TC"<a href="motion.txt.html#%2C" class="d">,</a> the type cast means Vim first checks whether "b:two" <a href="motion.txt.html#is" class="d">is</a>
<a href="insert.txt.html#a" class="d">a</a> <span class="s">&lt;number&gt;</span> type: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	b:two <a href="change.txt.html#%3D" class="d">=</a> '2'
	const NTC: func <a href="change.txt.html#%3D" class="d">=</a> (): list&lt;number&gt; =&gt; <a href="motion.txt.html#%7B" class="d">{</a>
	    return [1, b:two]
	    <a href="motion.txt.html#%7D" class="d">}</a>
	disassemble NTC  <a href="pattern.txt.html#%23" class="d">#</a> 3 CHECKTYPE list&lt;number&gt; stack <span class="s">[-1]</span>
	try
	    NTC()
	catch
	    echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a> .. "\n\n"  <a href="pattern.txt.html#%23" class="d">#</a> expected list&lt;number&gt; but...
	endtry
	const TC: func <a href="change.txt.html#%3D" class="d">=</a> (): list&lt;number&gt; =&gt; <a href="motion.txt.html#%7B" class="d">{</a>
	    return [1, <span class="s">&lt;number&gt;</span>b:two]
	    <a href="motion.txt.html#%7D" class="d">}</a>
	disassemble TC  <a href="pattern.txt.html#%23" class="d">#</a> 2 CHECKTYPE number stack <span class="s">[-1]</span>
	try
	    TC()
	catch
	    echo <a href="eval.txt.html#v%3Aexception" class="d">v:exception</a>  <a href="pattern.txt.html#%23" class="d">#</a> expected number but got <a href="eval.txt.html#string" class="d">string</a>
	endtry
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">Note:</span> Notice how the error <a href="message.txt.html#messages" class="d">messages</a> differ, showing when
	        type checking occurs.

						<span id="E1104" class="t">E1104</span>
The <a href="syntax.txt.html#syntax" class="d">syntax</a> of <a href="insert.txt.html#a" class="d">a</a> type cast <a href="motion.txt.html#is" class="d">is</a> "&lt;{type}&gt;"<a href="repeat.txt.html#." class="d">.</a>  An error occurs if either the
opening "<a href="change.txt.html#%3C" class="d">&lt;</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#E121" class="l">E121</a><a href="motion.txt.html#%29" class="d">)</a> or closing "<a href="change.txt.html#%3E" class="d">&gt;</a>" (E1104) <a href="motion.txt.html#is" class="d">is</a> omitted.  Also, white <a href="intro.txt.html#space" class="d">space</a>
<a href="motion.txt.html#is" class="d">is</a> not allowed either after the "<a href="change.txt.html#%3C" class="d">&lt;</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#E15" class="l">E15</a><a href="motion.txt.html#%29" class="d">)</a> or before the "<a href="change.txt.html#%3E" class="d">&gt;</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#E1068" class="l">E1068</a>), which
avoids ambiguity with smaller-than and greater-than operators.

Although <a href="insert.txt.html#a" class="d">a</a> type casting forces explicit type checking, <a href="motion.txt.html#it" class="d">it</a> neither changes the
value of, nor the type of, <a href="insert.txt.html#a" class="d">a</a> variable.  If you need to alter the type, use <a href="insert.txt.html#a" class="d">a</a>
function such <a href="motion.txt.html#as" class="d">as</a> <a href="builtin.txt.html#string%28%29" class="l">string()</a> to convert to <a href="insert.txt.html#a" class="d">a</a> string, or <a href="builtin.txt.html#str2nr%28%29" class="l">str2nr()</a> to convert <a href="insert.txt.html#a" class="d">a</a>
<a href="eval.txt.html#string" class="d">string</a> to <a href="insert.txt.html#a" class="d">a</a> number.

If type casting <a href="motion.txt.html#is" class="d">is</a> applied to <a href="insert.txt.html#a" class="d">a</a> chained expression, <a href="motion.txt.html#it" class="d">it</a> <a href="vim_faq.txt.html#must" class="d">must</a> be compatible with
the final result.  Examples: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> These type casts work
	echo &lt;list&lt;any&gt;&gt;[3, 2, 1]-&gt;extend(['Go!'])
	echo <span class="s">&lt;string&gt;</span>[3, 2, 1]-&gt;extend(['Go!'])-&gt;string()
	echo &lt;tuple&lt;...list&lt;number&gt;&gt;&gt;[3, 2, 1]-&gt;list2tuple()
	<a href="pattern.txt.html#%23" class="d">#</a> This type cast fails
	echo <span class="s">&lt;number&gt;</span>[3, 2, 1]-&gt;extend(['Go!'])-&gt;string()
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="E1272" class="t">E1272</span>
If <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#is" class="d">is</a> used in <a href="insert.txt.html#a" class="d">a</a> context where types are not expected you can get
E1272.  For example: 
<span class="e">	:vim9cmd echo islocked('x: string')</span>
  <span class="n">Note:</span> This <a href="vim_faq.txt.html#must" class="d">must</a> be executed from Vim's command line, not sourced.

						<span id="E1363" class="t">E1363</span>
If <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#is" class="d">is</a> incomplete, such <a href="motion.txt.html#as" class="d">as</a> when an object's <a href="vim9class.txt.html#class" class="d">class</a> <a href="motion.txt.html#is" class="d">is</a> unknown, <a href="vim9.txt.html#E1363" class="d">E1363</a>
results.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var <a href="vim9.txt.html#E1363" class="d">E1363</a> <a href="change.txt.html#%3D" class="d">=</a> null_class.member  <a href="pattern.txt.html#%23" class="d">#</a> E1363: Incomplete type
<a href="change.txt.html#%3C" class="d">&lt;</a>
Another <a href="vim9.txt.html#null" class="d">null</a> object-related error <a href="motion.txt.html#is" class="d">is</a> <a href="vim9class.txt.html#E1360" class="l">E1360</a><a href="cmdline.txt.html#%3A" class="d">:</a> &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var obj <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_object" class="d">null_object</a>
	var <a href="vim9class.txt.html#E1360" class="d">E1360</a> <a href="change.txt.html#%3D" class="d">=</a> obj.MyMethod()  <a href="pattern.txt.html#%23" class="d">#</a> E1360: Using <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a> <a href="vim9class.txt.html#object" class="d">object</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">Type inference </span>
							<span id="type-inference" class="t">type-inference</span>
Declaring types explicitly provides many benefits, including targeted type
checking and clearer error messages.  Nonetheless, Vim often can infer types
automatically when they are omitted.  For example, each of these variables'
types are inferred, with the <a href="builtin.txt.html#type%28%29" class="l">type()</a> and <a href="builtin.txt.html#typename%28%29" class="l">typename()</a> echoed showing those
inferred types: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	echo "\t type()\t <a href="builtin.txt.html#typename%28%29" class="d">typename()</a>"
	var <a href="motion.txt.html#b" class="d">b</a> <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#true" class="d">true</a>    | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{b}</span> \t <span class="s">{b-&gt;type()}</span> \t <span class="s">{b-&gt;typename()}</span>"
	var <a href="motion.txt.html#f" class="d">f</a> <a href="change.txt.html#%3D" class="d">=</a> 4.2     | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{f}</span> \t <span class="s">{f-&gt;type()}</span> \t <span class="s">{f-&gt;typename()}</span>"
	var <a href="motion.txt.html#l" class="d">l</a> <a href="change.txt.html#%3D" class="d">=</a> [1, 2]  | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{l}</span> \t <span class="s">{l-&gt;type()}</span> \t <span class="s">{l-&gt;typename()}</span>"
	var <a href="pattern.txt.html#n" class="d">n</a> <a href="change.txt.html#%3D" class="d">=</a> <a href="usr_42.txt.html#42" class="d">42</a>      | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{n}</span> \t <span class="s">{n-&gt;type()}</span> \t <span class="s">{n-&gt;typename()}</span>"
	var <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D" class="d">=</a> <span class="o">'yes'</span>   | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{s}</span> \t <span class="s">{s-&gt;type()}</span> \t <span class="s">{s-&gt;typename()}</span>"
	var <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D" class="d">=</a> (42, <a href="motion.txt.html#%29" class="d">)</a>  | echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{t}</span> \t <span class="s">{t-&gt;type()}</span> \t <span class="s">{t-&gt;typename()}</span>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
The type of <a href="insert.txt.html#a" class="d">a</a> list, tuple, or dictionary <a href="motion.txt.html#is" class="d">is</a> inferred from the common type of
its values.  When the values are all the same type, that type <a href="motion.txt.html#is" class="d">is</a> used.
If there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> mix of types, the "any" type <a href="motion.txt.html#is" class="d">is</a> used.  In the following example,
the echoed <a href="builtin.txt.html#typename%28%29" class="l">typename()</a> for each literal demonstrates these points: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	echo [1, 2]-&gt;typename()				 <a href="pattern.txt.html#%23" class="d">#</a> list&lt;number&gt;
	echo [1, 'x']-&gt;typename()			 <a href="pattern.txt.html#%23" class="d">#</a> list&lt;any&gt;
	echo <span class="s">{ints: [1, 2], bools: [false]}</span>-&gt;typename()	 <a href="pattern.txt.html#%23" class="d">#</a> dict&lt;list&lt;any&gt;&gt;
	echo (true, false)-&gt;typename()			 <a href="pattern.txt.html#%23" class="d">#</a> tuple&lt;bool, bool&gt;
<a href="change.txt.html#%3C" class="d">&lt;</a>
The common type of function references, when they <a href="diff.txt.html#do" class="d">do</a> not all have the same
number of arguments, <a href="motion.txt.html#is" class="d">is</a> indicated with "(...)"<a href="motion.txt.html#%2C" class="d">,</a> meaning the number of
arguments <a href="motion.txt.html#is" class="d">is</a> unequal.  This <a href="usr_41.txt.html#script" class="d">script</a> demonstrates <a href="insert.txt.html#a" class="d">a</a> "list&lt;func(...): void&gt;"<a href="cmdline.txt.html#%3A" class="d">:</a> &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def Foo(x: bool): void
	enddef
	def Bar(x: bool, y: bool): void
	enddef
	var funclist <a href="change.txt.html#%3D" class="d">=</a> [Foo, Bar]
	echo funclist-&gt;typename()
<a href="change.txt.html#%3C" class="d">&lt;</a>
Script-local <a href="eval.txt.html#variables" class="d">variables</a> in <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> are type checked.  The type <a href="motion.txt.html#is" class="d">is</a>
also checked for <a href="eval.txt.html#variables" class="d">variables</a> declared in <a href="insert.txt.html#a" class="d">a</a> legacy function.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var my_local <a href="change.txt.html#%3D" class="d">=</a> (1, 2)
	function Legacy()
	    let b:legacy <a href="change.txt.html#%3D" class="d">=</a> [1, 2]
	endfunction
	Legacy()
	echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{my_local}</span> <a href="motion.txt.html#is" class="d">is</a> type <span class="s">{my_local-&gt;type()}</span> ({my_local-&gt;typename()})"
	echo <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{b:legacy}</span> <a href="motion.txt.html#is" class="d">is</a> type <span class="s">{b:legacy-&gt;type()}</span> ({b:legacy-&gt;typename()})"
<a href="change.txt.html#%3C" class="d">&lt;</a>
							<span id="E1013" class="t">E1013</span>
When <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#is" class="d">is</a> declared for <a href="insert.txt.html#a" class="d">a</a> List, Tuple, or Dictionary, the type <a href="motion.txt.html#is" class="d">is</a> attached
to it.  Similarly, if <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#is" class="d">is</a> not declared, the type Vim infers <a href="motion.txt.html#is" class="d">is</a> attached.
In either case, if an <a href="eval.txt.html#expression" class="d">expression</a> attempts to change the type, <a href="vim9.txt.html#E1013" class="d">E1013</a> results.
This example has its type inferred and demonstrates E1013: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var lb <a href="change.txt.html#%3D" class="d">=</a> [true, true]	<a href="pattern.txt.html#%23" class="d">#</a> Two bools, so Vim infers list&lt;bool&gt; type
	echo lb-&gt;typename()	<a href="pattern.txt.html#%23" class="d">#</a> Echoes list&lt;bool&gt;
	lb-&gt;extend([0])		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#E1013" class="d">E1013</a> Argument 2: type mismatch, <a href="userfunc.txt.html#..." class="d">...</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
If you want <a href="insert.txt.html#a" class="d">a</a> permissive list, either explicitly use <span class="s">&lt;any&gt;</span> or declare an
empty <a href="eval.txt.html#list" class="d">list</a> initially (or both, i.e., `list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> []`).  Examples: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	final la: list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	echo la-&gt;extend(['two', 1])
	final le <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	echo le-&gt;extend(la)
<a href="change.txt.html#%3C" class="d">&lt;</a>
Similarly for <a href="insert.txt.html#a" class="d">a</a> permissive dictionary: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	final da: dict&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="intro.txt.html#%7B%7D" class="d">{}</a>
	echo da-&gt;extend({2: 2, 1: 'One'})
	final de <a href="change.txt.html#%3D" class="d">=</a> <a href="intro.txt.html#%7B%7D" class="d">{}</a>
	echo de-&gt;extend(da)-&gt;string()
<a href="change.txt.html#%3C" class="d">&lt;</a>
And, although tuples themselves are immutable, permissive <a href="eval.txt.html#tuple" class="d">tuple</a> concatenation
can be achieved with either "any" or an empty tuple: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var t_any: tuple&lt;...list&lt;any&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> (3, '2')
	t_any <a href="change.txt.html#%3D" class="d">=</a> t_any <a href="motion.txt.html#%2B" class="d">+</a> (true, <a href="motion.txt.html#%29" class="d">)</a>
	echo t_any
	var t_dec_empty <a href="change.txt.html#%3D" class="d">=</a> ()
	t_dec_empty <a href="change.txt.html#%3D" class="d">=</a> t_dec_empty <a href="motion.txt.html#%2B" class="d">+</a> (3, '2', true)
	echo t_dec_empty
<a href="change.txt.html#%3C" class="d">&lt;</a>
If <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> literal or dictionary literal <a href="motion.txt.html#is" class="d">is</a> not bound to <a href="insert.txt.html#a" class="d">a</a> variable, its type
may change, <a href="motion.txt.html#as" class="d">as</a> this example shows: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	echo [3, 2, 1]-&gt;typename()			 <a href="pattern.txt.html#%23" class="d">#</a> list&lt;number&gt;
	echo [3, 2, 1]-&gt;extend(['Zero'])-&gt;typename()	 <a href="pattern.txt.html#%23" class="d">#</a> list&lt;any&gt;
	echo <span class="s">{1: ['One']}</span>-&gt;typename()			 <a href="pattern.txt.html#%23" class="d">#</a> dict&lt;list&lt;string&gt;&gt;
	echo <span class="s">{1: ['One']}</span>-&gt;extend(<span class="s">{2: [2]}</span>)-&gt;typename()	 <a href="pattern.txt.html#%23" class="d">#</a> dict&lt;list&lt;any&gt;&gt;
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">Stricter type checking </span>
						<span id="type-checking" class="t">type-checking</span>
In legacy Vim script, where <a href="insert.txt.html#a" class="d">a</a> number was expected, <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> would be
automatically converted to <a href="insert.txt.html#a" class="d">a</a> number.  This was convenient for an actual number
such <a href="motion.txt.html#as" class="d">as</a> "123"<a href="motion.txt.html#%2C" class="d">,</a> but leads to unexpected problems (and no error message) if the
<a href="eval.txt.html#string" class="d">string</a> doesn't start with <a href="insert.txt.html#a" class="d">a</a> number.  Quite often this leads to hard-to-find
bugs.  For example, in legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> this echoes "1"<a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e"></span>
<span class="e">	echo 123 == '123'</span>

However, if an unintended <a href="intro.txt.html#space" class="d">space</a> <a href="motion.txt.html#is" class="d">is</a> included, "<a href="motion.txt.html#0" class="d">0</a>" <a href="motion.txt.html#is" class="d">is</a> echoed: 
<span class="e"></span>
<span class="e">	echo 123 == ' 123'</span>

						<span id="E1206" class="t">E1206</span>
In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> this has been made stricter.  In most places <a href="motion.txt.html#it" class="d">it</a> works just <a href="motion.txt.html#as" class="d">as</a>
before if the value used matches the expected type.  For example, in both
legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> and <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> trying to use anything other than <a href="insert.txt.html#a" class="d">a</a>
dictionary when <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> required: 
<span class="e"></span>
<span class="e">	echo [8, 9]-&gt;keys()</span>
<span class="e">	vim9cmd echo [8, 9]-&gt;keys()	 # E1206: Dictionary required</span>

						<span id="E1023" class="t">E1023</span> <span id="E1024" class="t">E1024</span> <span id="E1029" class="t">E1029</span> <span id="E1030" class="t">E1030</span>
						<span id="E1174" class="t">E1174</span> <span id="E1175" class="t">E1175</span> <span id="E1210" class="t">E1210</span> <span id="E1212" class="t">E1212</span>
However, sometimes there will be an error in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, which breaks
backwards compatibility.  The following examples illustrate <a href="various.txt.html#various" class="d">various</a> places
this happens.  The legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> behavior, which does not fail, <a href="motion.txt.html#is" class="d">is</a> shown
first.  It <a href="motion.txt.html#is" class="d">is</a> followed by the error that occurs if the same command <a href="motion.txt.html#is" class="d">is</a> used
in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script.

  <a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> number (except <a href="motion.txt.html#0" class="d">0</a> or 1) where <a href="insert.txt.html#a" class="d">a</a> bool <a href="motion.txt.html#is" class="d">is</a> expected: 
<span class="e"></span>
<span class="e">	echo v:version ? v:true : v:false</span>
<span class="e">	vim9cmd echo v:version ? true : false  # E1023: Using a Number as a...</span>

  <a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> number where <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#is" class="d">is</a> expected: 
<span class="e"></span>
<span class="e">	echo filter([1, 2], 0)</span>
<span class="e">	vim9cmd echo filter([1, 2], 0)  # E1024: Using a Number as a String</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> number where <a href="insert.txt.html#a" class="d">a</a> number <a href="motion.txt.html#is" class="d">is</a> expected: 
<span class="e"></span>
<span class="e">	" In this example, Vim script treats v:false as 0</span>
<span class="e">	function Not1029()</span>
<span class="e">	  let b:l = [42] | unlet b:l[v:false]</span>
<span class="e">	endfunction</span>
<span class="e">	call Not1029() | echo b:l</span>
 &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def E1029(): void
	  b:l <a href="change.txt.html#%3D" class="d">=</a> <span class="s">[42]</span> | unlet b:l[false]
	enddef
	E1029()  <a href="pattern.txt.html#%23" class="d">#</a> E1029: Expected number but got bool
<a href="change.txt.html#%3C" class="d">&lt;</a>
  <a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> number: 
<span class="e"></span>
<span class="e">	let b:l = [42] | unlet b:l['#'] | echo b:l</span>
<span class="e">	vim9cmd b:l = [42] | vim9cmd unlet b:l['#']  # E1030: Using a string...</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> where an argument requires <a href="insert.txt.html#a" class="d">a</a> string: &gt;vim9

	echo substitute('Hallo', 'a', 'e', v:true)
	vim9cmd echo substitute('Hallo', 'a', 'e', true)  <a href="pattern.txt.html#%23" class="d">#</a> E1174: String...
<a href="change.txt.html#%3C" class="d">&lt;</a>
  <a href="motion.txt.html#-" class="d">-</a> Using an empty <a href="eval.txt.html#string" class="d">string</a> in an argument that requires <a href="insert.txt.html#a" class="d">a</a> non-empty string: &gt;vim9

	echo exepath('')
	vim9cmd echo exepath('') <a href="pattern.txt.html#%23" class="d">#</a> E1175: Non-empty <a href="eval.txt.html#string" class="d">string</a> required for arg...
<a href="change.txt.html#%3C" class="d">&lt;</a>
  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> number when <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> required: 
<span class="e"></span>
<span class="e">	echo gettabinfo('a')</span>
<span class="e">	vim9cmd echo gettabinfo('a')  # E1210: Number required for argument 1</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> bool when <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> required: 
<span class="e"></span>
<span class="e">	echo char2nr('¡', 2)</span>
<span class="e">	vim9cmd echo char2nr('¡', 2)  # E1212: Bool required for argument 2</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> number when <a href="insert.txt.html#a" class="d">a</a> number <a href="motion.txt.html#is" class="d">is</a> required <a href="motion.txt.html#%28" class="d">(</a><a href="options.txt.html#E521" class="l">E521</a>): 
<span class="e"></span>
<span class="e">	let &amp;laststatus='2'</span>
<span class="e">	vim9cmd &amp;laststatus = '2'</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> when <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#is" class="d">is</a> required <a href="motion.txt.html#%28" class="d">(</a><a href="message.txt.html#E928" class="l">E928</a>): 
<span class="e"></span>
<span class="e">	let &amp;langmenu = 42</span>
<span class="e">	vim9cmd &amp;langmenu = 42  # E928: String required</span>

  <a href="motion.txt.html#-" class="d">-</a> Comparing <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#Special" class="l">Special</a> with <a href="options.txt.html#%27is%27" class="o">'is'</a> fails in some instances <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#E1037" class="l">E1037</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="eval.txt.html#E1072" class="l">E1072</a>): 
<span class="e"></span>
<span class="e">	" 1 is echoed because these are both true</span>
<span class="e">	echo v:null is v:null &amp;&amp; v:none is v:none</span>
<span class="e">	" 0 is echoed because all these expressions are false</span>
<span class="e">	echo v:none is v:null || v:none is 8 || v:true is v:none</span>
<span class="e">	" All these are errors in Vim9 script</span>
<span class="e">	vim9cmd echo v:null is v:null # E1037: Cannot use 'is' with special</span>
<span class="e">	vim9cmd echo v:none is v:none # E1037: Cannot use 'is' with special</span>
<span class="e">	vim9cmd echo v:none is v:null # E1037: Cannot use 'is' with special</span>
<span class="e">	vim9cmd echo v:none is 8      # E1072: Cannot compare special with numb</span>
<span class="e">	vim9cmd echo v:true is v:none # E1072: Cannot compare bool with special</span>

	  <span class="n">Note:</span> Although the last two <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> examples above error using
		<span class="e">v:none</span>, they return <span class="e">false</span> using <span class="e">null</span> (which <a href="motion.txt.html#is" class="d">is</a> the same
		<a href="motion.txt.html#as" class="d">as</a> <span class="e">v:null</span> <a href="motion.txt.html#-" class="d">-</a> see <a href="eval.txt.html#v%3Anull" class="l">v:null</a>): &gt;vim9

			<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
			echo <a href="vim9.txt.html#null" class="d">null</a> <a href="motion.txt.html#is" class="d">is</a> 8		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a>
			echo <a href="vim9.txt.html#true" class="d">true</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#null" class="d">null</a>	<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
  <a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> where <a href="insert.txt.html#a" class="d">a</a> bool <a href="motion.txt.html#is" class="d">is</a> required <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#E1135" class="l">E1135</a>): 
<span class="e"></span>
<span class="e">	echo '42' ? v:true : v:false</span>
<span class="e">	vim9cmd echo '42' ? true : false  # E1135: Using a String as a Bool</span>

  <a href="motion.txt.html#-" class="d">-</a> Using <a href="insert.txt.html#a" class="d">a</a> bool <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> number <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#E1138" class="l">E1138</a>): 
<span class="e"></span>
<span class="e">	let &amp;laststatus=v:true</span>
<span class="e">	vim9cmd &amp;laststatus = true</span>

  <a href="motion.txt.html#-" class="d">-</a> Not using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> where an argument requires <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#E1174" class="l">E1174</a><a href="motion.txt.html#%29" class="d">)</a> 
<span class="e"></span>
<span class="e">	echo substitute('Hallo', 'a', 'e', v:true)</span>
<span class="e">	vim9cmd echo substitute('Hallo', 'a', 'e', true)  # E1174: String...</span>

One consequence <a href="motion.txt.html#is" class="d">is</a> that the item type of <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> or <a href="eval.txt.html#dict" class="d">dict</a> given to <a href="builtin.txt.html#map%28%29" class="l">map()</a> <a href="vim_faq.txt.html#must" class="d">must</a>
not change when its type <a href="motion.txt.html#is" class="d">is</a> either declared or inferred.  For example, this
gives an error in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, whereas in legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> allowed: 
<span class="e"></span>
<span class="e">	" legacy Vim script changes s:mylist to ['item 0', 'item 1']</span>
<span class="e">	let s:mylist = [0, 1]</span>
<span class="e">	call map(s:mylist, {i -&gt; $"item {i}"})</span>
<span class="e">	echo s:mylist</span>
 &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var mylist <a href="change.txt.html#%3D" class="d">=</a> [0, 1]                <a href="pattern.txt.html#%23" class="d">#</a> Vim infers mylist <a href="motion.txt.html#is" class="d">is</a> list&lt;number&gt;
	map(mylist, (i, _) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"item <span class="s">{i}</span>"<a href="motion.txt.html#%29" class="d">)</a> <a href="pattern.txt.html#%23" class="d">#</a> E1012: type mismatch...
<a href="change.txt.html#%3C" class="d">&lt;</a>
The error occurs because <span class="e">map()</span> tries to modify the <a href="eval.txt.html#list" class="d">list</a> elements to strings,
which conflicts with the declared type.

Use <a href="builtin.txt.html#mapnew%28%29" class="l">mapnew()</a> instead.  It creates <a href="insert.txt.html#a" class="d">a</a> new list, and Vim infers its type if <a href="motion.txt.html#it" class="d">it</a>
<a href="motion.txt.html#is" class="d">is</a> not specified.  Inferred and declared types are shown in this example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var mylist <a href="change.txt.html#%3D" class="d">=</a> [0, 1]
	var infer <a href="change.txt.html#%3D" class="d">=</a> mylist-&gt;mapnew((i, _) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"item <span class="s">{i}</span>"<a href="motion.txt.html#%29" class="d">)</a>
	echo [infer, infer-&gt;typename()]
	var declare: list&lt;string&gt; <a href="change.txt.html#%3D" class="d">=</a> mylist-&gt;mapnew((i, _) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"item <span class="s">{i}</span>"<a href="motion.txt.html#%29" class="d">)</a>
	echo [declare, declare-&gt;typename()]
<a href="change.txt.html#%3C" class="d">&lt;</a>
The key concept here is, <a href="eval.txt.html#variables" class="d">variables</a> with declared or inferred types cannot
have the types of the elements within their containers change.  However, type
"changes" are allowed for either:
  <a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> container literal (not bound to <a href="insert.txt.html#a" class="d">a</a> variable), or
  <a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#a" class="d">a</a> container where <a href="builtin.txt.html#copy%28%29" class="l">copy()</a> or <a href="builtin.txt.html#deepcopy%28%29" class="l">deepcopy()</a> <a href="motion.txt.html#is" class="d">is</a> used in <a href="eval.txt.html#method" class="d">method</a> chaining.
Both are demonstrated in this example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> <a href="eval.txt.html#list" class="d">list</a> literal
	echo [1, 2]-&gt;map((_, v) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"#{v}"<a href="motion.txt.html#%29" class="d">)</a>
	echo [1, 2]-&gt;map((_, v) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"#{v}")-&gt;typename()
	<a href="pattern.txt.html#%23" class="d">#</a> <a href="builtin.txt.html#deepcopy%28%29" class="d">deepcopy()</a> in <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#method" class="d">method</a> chain
	var mylist <a href="change.txt.html#%3D" class="d">=</a> [1, 2]
	echo mylist-&gt;deepcopy()-&gt;map((_, v) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"#{v}"<a href="motion.txt.html#%29" class="d">)</a>
	echo mylist-&gt;deepcopy()-&gt;map((_, v) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"#{v}")-&gt;typename()
	echo mylist
<a href="change.txt.html#%3C" class="d">&lt;</a>
The reasoning behind this is, when <a href="insert.txt.html#a" class="d">a</a> type <a href="motion.txt.html#is" class="d">is</a> either declared or inferred
and the <a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#is" class="d">is</a> passed around and changed, the declaration/inference <a href="vim_faq.txt.html#must" class="d">must</a>
always hold so that you can rely on the type to match the declared/inferred
type.  For either <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> literal or <a href="insert.txt.html#a" class="d">a</a> fully copied list, that type safety <a href="motion.txt.html#is" class="d">is</a>
not needed because the original <a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#is" class="d">is</a> unchanged (as "echo mylist" shows,
above).

If the item type was not declared or determined to be "<span class="s">&lt;any&gt;</span>"<a href="motion.txt.html#%2C" class="d">,</a> <a href="motion.txt.html#it" class="d">it</a> will not
change, even if all items later become the same type.  However, when <span class="e">mapnew()</span>
<a href="motion.txt.html#is" class="d">is</a> used, inference means that the new <a href="eval.txt.html#list" class="d">list</a> will reflect the type(s) present.
For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> list&lt;any&gt;
	var mylist <a href="change.txt.html#%3D" class="d">=</a> [1, '2']			<a href="pattern.txt.html#%23" class="d">#</a> mixed types, i.e., list&lt;any&gt;
	echo (mylist, mylist-&gt;typename())	<a href="pattern.txt.html#%23" class="d">#</a> ([1, '2'], 'list&lt;any&gt;')
	mylist-&gt;map((_, v) =&gt; <a href="motion.txt.html#%24" class="d">$</a>"item <span class="s">{v}</span>"<a href="motion.txt.html#%29" class="d">)</a>	<a href="pattern.txt.html#%23" class="d">#</a> all items are now strings
	echo (mylist, mylist-&gt;typename())	<a href="pattern.txt.html#%23" class="d">#</a> both strings, but list&lt;any&gt;
	<a href="pattern.txt.html#%23" class="d">#</a> <a href="builtin.txt.html#mapnew%28%29" class="d">mapnew()</a>
	var newlist <a href="change.txt.html#%3D" class="d">=</a> mylist-&gt;mapnew((_, v) =&gt; v)
	echo (newlist, newlist-&gt;typename())	<a href="pattern.txt.html#%23" class="d">#</a> newlist <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> list&lt;string&gt;
<a href="change.txt.html#%3C" class="d">&lt;</a>
Using <a href="builtin.txt.html#extend%28%29" class="l">extend()</a> and <a href="builtin.txt.html#extendnew%28%29" class="l">extendnew()</a> <a href="motion.txt.html#is" class="d">is</a> similar, i.e., <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> literal may use
the former, so, this <a href="motion.txt.html#is" class="d">is</a> okay: &gt;vim9

	vim9cmd echo [1, 2]-&gt;extend(['3'])	<a href="pattern.txt.html#%23" class="d">#</a> [1, 2, 3]
<a href="change.txt.html#%3C" class="d">&lt;</a>
whereas, this <a href="motion.txt.html#is" class="d">is</a> not: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var mylist: list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> [1, 2]
	echo mylist-&gt;extend(['3'])	   <a href="pattern.txt.html#%23" class="d">#</a> E1013: Argument 2: type mismatch
<a href="change.txt.html#%3C" class="d">&lt;</a>
Using <a href="builtin.txt.html#extendnew%28%29" class="l">extendnew()</a> <a href="motion.txt.html#is" class="d">is</a> needed for extending an existing typed list, except
where the extension matches the list's type (or <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> "any").  For example,
first extending with an element of the same type, then extending with <a href="insert.txt.html#a" class="d">a</a>
different type: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var mylist: list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> [1, 2]
	mylist-&gt;extend([3])
	echo mylist-&gt;extendnew(['4'])	   <a href="pattern.txt.html#%23" class="d">#</a> [1, 2, 3, '4']

<a href="change.txt.html#%3C" class="d">&lt;</a>								<span id="E1158" class="t">E1158</span>
Using <a href="builtin.txt.html#flatten%28%29" class="l">flatten()</a> <a href="motion.txt.html#is" class="d">is</a> not allowed in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, because <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> intended
always to change the type.  This even applies to <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> literal
(unlike <a href="builtin.txt.html#map%28%29" class="l">map()</a> and <a href="builtin.txt.html#extend%28%29" class="l">extend()</a>).  Instead, use <a href="builtin.txt.html#flattennew%28%29" class="l">flattennew()</a><a href="cmdline.txt.html#%3A" class="d">:</a> &gt;vim9

	vim9cmd [1, [2, 3]]-&gt;flatten()		<a href="pattern.txt.html#%23" class="d">#</a> E1158: Cannot use flatten
	vim9cmd echo [1, [2, 3]]-&gt;flattennew()	<a href="pattern.txt.html#%23" class="d">#</a> [1, 2, 3]
<a href="change.txt.html#%3C" class="d">&lt;</a>
Assigning to <a href="insert.txt.html#a" class="d">a</a> funcref with specified arguments (see <a href="vim9.txt.html#vim9-func-declaration" class="l">vim9-func-declaration</a><a href="motion.txt.html#%29" class="d">)</a>
involves strict type checking of the arguments.  For example, this works: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var F_name_age: func(string, number): <a href="eval.txt.html#string" class="d">string</a>
	F_name_age <a href="change.txt.html#%3D" class="d">=</a> (n: string, a: number): <a href="eval.txt.html#string" class="d">string</a> =&gt; <a href="motion.txt.html#%24" class="d">$</a>"Name: <span class="s">{n}</span>, Age: <span class="s">{a}</span>"
	echo F_name_age('Bob', 42)
<a href="change.txt.html#%3C" class="d">&lt;</a>
whereas this fails with error <a href="vim9.txt.html#E1012" class="l">E1012</a> (type mismatch): &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var F_name_age: func(string, number): <a href="eval.txt.html#string" class="d">string</a>
	F_name_age <a href="change.txt.html#%3D" class="d">=</a> (n: string, a: string): <a href="eval.txt.html#string" class="d">string</a> =&gt; <a href="motion.txt.html#%24" class="d">$</a>"Name: <span class="s">{n}</span>, Age: <span class="s">{a}</span>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
If there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> variable number of arguments they <a href="vim_faq.txt.html#must" class="d">must</a> have the same type, <a href="motion.txt.html#as" class="d">as</a> in
this example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var Fproduct: func(...list&lt;number&gt;): number
	Fproduct <a href="change.txt.html#%3D" class="d">=</a> (...v: list&lt;number&gt;): number =&gt; reduce(v, (a, b) =&gt; <a href="insert.txt.html#a" class="d">a</a> * b)
	echo Fproduct(3, 2, 4)  <a href="pattern.txt.html#%23" class="d">#</a> Echoes 24
<a href="change.txt.html#%3C" class="d">&lt;</a>
And <span class="s">&lt;any&gt;</span> may be used to accommodate mixed types: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var FlatSort: func(...list&lt;any&gt;): any
	FlatSort <a href="change.txt.html#%3D" class="d">=</a> (...v: list&lt;any&gt;) =&gt; flattennew(v)-&gt;sort('n')
	echo FlatSort(true, [[[5, 3], 2], 4])  <a href="pattern.txt.html#%23" class="d">#</a> Echoes [true, 2, 3, 4, 5]
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">Note:</span> Using <span class="s">&lt;any&gt;</span> in <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#lambda" class="d">lambda</a> does not avoid type checking of the
		funcref.  It remains constrained by the declared funcref's
		type and, <a href="motion.txt.html#as" class="d">as</a> these examples show, <a href="insert.txt.html#a" class="d">a</a> runtime or compiling error
		occurs when the types mismatch: &gt;vim9

		    <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
		    var FuncSN: func(string): number
		    FuncSN <a href="change.txt.html#%3D" class="d">=</a> (v: any): number =&gt; v-&gt;str2nr()
		    echo FuncSN('162')-&gt;nr2char()  <a href="pattern.txt.html#%23" class="d">#</a> Echoes ¢
		    echo FuncSN(162)-&gt;nr2char())   <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#E1013" class="d">E1013</a> (runtime error)
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
		    <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
		    var FuncSN: func(string): number
		    FuncSN <a href="change.txt.html#%3D" class="d">=</a> (v: any): number =&gt; v-&gt;str2nr()
		    def FuncSNfail(): void
		        echo FuncSN('162')-&gt;nr2char()  <a href="pattern.txt.html#%23" class="d">#</a> No echo because <a href="userfunc.txt.html#..." class="d">...</a>
		        echo FuncSN(162)-&gt;nr2char()    <a href="pattern.txt.html#%23" class="d">#</a> Error while compiling
		    enddef
		    FuncSNfail()
<a href="change.txt.html#%3C" class="d">&lt;</a>
When the funcref has no arguments specified, there <a href="motion.txt.html#is" class="d">is</a> no type checking.  This
example shows FlexArgs has <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> argument the first time and <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> the
following time: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var FlexArgs: func: <a href="eval.txt.html#string" class="d">string</a>
	FlexArgs <a href="change.txt.html#%3D" class="d">=</a> (s: string): <a href="eval.txt.html#string" class="d">string</a> =&gt; <a href="motion.txt.html#%24" class="d">$</a>"It's countdown time <span class="s">{s}</span>..."
	echo FlexArgs("everyone"<a href="motion.txt.html#%29" class="d">)</a>
	FlexArgs <a href="change.txt.html#%3D" class="d">=</a> (...values: list&lt;string&gt;): <a href="eval.txt.html#string" class="d">string</a> =&gt; join(values, ', <a href="motion.txt.html#%27%29" class="d">')</a>
	echo FlexArgs('3', '2', '1', 'GO!')
<a href="change.txt.html#%3C" class="d">&lt;</a>
				<span id="E1211" class="t">E1211</span> <span id="E1217" class="t">E1217</span> <span id="E1218" class="t">E1218</span> <span id="E1219" class="t">E1219</span> <span id="E1220" class="t">E1220</span> <span id="E1221" class="t">E1221</span> <span id="E1222" class="t">E1222</span>
				<span id="E1223" class="t">E1223</span> <span id="E1224" class="t">E1224</span> <span id="E1225" class="t">E1225</span> <span id="E1226" class="t">E1226</span> <span id="E1228" class="t">E1228</span> <span id="E1235" class="t">E1235</span> <span id="E1238" class="t">E1238</span>
				<span id="E1251" class="t">E1251</span> <span id="E1253" class="t">E1253</span> <span id="E1256" class="t">E1256</span> <span id="E1297" class="t">E1297</span> <span id="E1298" class="t">E1298</span> <span id="E1301" class="t">E1301</span> <span id="E1528" class="t">E1528</span>
				<span id="E1529" class="t">E1529</span> <span id="E1530" class="t">E1530</span> <span id="E1531" class="t">E1531</span> <span id="E1534" class="t">E1534</span>
Types are checked for most builtin <a href="eval.txt.html#functions" class="d">functions</a> to make <a href="motion.txt.html#it" class="d">it</a> easier to spot
mistakes.  The following one-line <a href="vim9.txt.html#%3Avim9" class="l">:vim9</a> commands, calling builtin functions,
demonstrate many of those <a href="vim9.txt.html#type-checking" class="d">type-checking</a> errors: &gt;vim9

	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;list2blob()               <a href="pattern.txt.html#%23" class="d">#</a> E1211: <a href="eval.txt.html#List" class="d">List</a> required for argument 1
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;ch_close()                <a href="pattern.txt.html#%23" class="d">#</a> E1217: <a href="eval.txt.html#Channel" class="d">Channel</a> or <a href="eval.txt.html#Job" class="d">Job</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;job_info()                <a href="pattern.txt.html#%23" class="d">#</a> E1218: <a href="eval.txt.html#Job" class="d">Job</a> required for argument 1
	<a href="vim9.txt.html#vim9" class="d">vim9</a> [9]-&gt;cos()                   <a href="pattern.txt.html#%23" class="d">#</a> E1219: <a href="eval.txt.html#Float" class="d">Float</a> or <a href="eval.txt.html#Number" class="d">Number</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> {}-&gt;remove([])               <a href="pattern.txt.html#%23" class="d">#</a> E1220: <a href="eval.txt.html#String" class="d">String</a> or <a href="eval.txt.html#Number" class="d">Number</a> required
	<a href="vim9.txt.html#vim9" class="d">vim9</a> null_channel-&gt;ch_evalraw(9)  <a href="pattern.txt.html#%23" class="d">#</a> E1221: <a href="eval.txt.html#String" class="d">String</a> or <a href="eval.txt.html#Blob" class="d">Blob</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;col()                     <a href="pattern.txt.html#%23" class="d">#</a> E1222: <a href="eval.txt.html#String" class="d">String</a> or <a href="eval.txt.html#List" class="d">List</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;complete_add()            <a href="pattern.txt.html#%23" class="d">#</a> E1223: <a href="eval.txt.html#String" class="d">String</a> or <a href="eval.txt.html#Dictionary" class="d">Dictionary</a> require
	<a href="vim9.txt.html#vim9" class="d">vim9</a> setbufline(9, 9, {})         <a href="pattern.txt.html#%23" class="d">#</a> E1224: String, <a href="eval.txt.html#Number" class="d">Number</a> or <a href="eval.txt.html#List" class="d">List</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;count(9)                  <a href="pattern.txt.html#%23" class="d">#</a> E1225: String, List, <a href="eval.txt.html#Tuple" class="d">Tuple</a> or <a href="eval.txt.html#Dict" class="d">Dict</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;add(9)                    <a href="pattern.txt.html#%23" class="d">#</a> E1226: <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Blob" class="d">Blob</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;remove(9)                 <a href="pattern.txt.html#%23" class="d">#</a> E1228: List, Dictionary, or <a href="eval.txt.html#Blob" class="d">Blob</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> getcharstr('9')              <a href="pattern.txt.html#%23" class="d">#</a> E1235: Bool or number required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;blob2list()               <a href="pattern.txt.html#%23" class="d">#</a> E1238: <a href="eval.txt.html#Blob" class="d">Blob</a> required for argument 1
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;filter(9)                 <a href="pattern.txt.html#%23" class="d">#</a> E1251: List, Tuple, Dictionary, Blo
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;reverse()                 <a href="pattern.txt.html#%23" class="d">#</a> E1253: String, List, <a href="eval.txt.html#Tuple" class="d">Tuple</a> or <a href="eval.txt.html#Blob" class="d">Blob</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;call(9)                   <a href="pattern.txt.html#%23" class="d">#</a> E1256: <a href="eval.txt.html#String" class="d">String</a> or Function required
	<a href="vim9.txt.html#vim9" class="d">vim9</a> null_dict-&gt;winrestview()     <a href="pattern.txt.html#%23" class="d">#</a> E1297: Non-NULL <a href="eval.txt.html#Dictionary" class="d">Dictionary</a> required
	<a href="vim9.txt.html#vim9" class="d">vim9</a> {}-&gt;prop_add_list(null_list) <a href="pattern.txt.html#%23" class="d">#</a> E1298: Non-NULL <a href="eval.txt.html#List" class="d">List</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> {}-&gt;repeat(9)                <a href="pattern.txt.html#%23" class="d">#</a> E1301: String, Number, List, <a href="eval.txt.html#Tuple" class="d">Tuple</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;index(9)                  <a href="pattern.txt.html#%23" class="d">#</a> E1528: <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Tuple" class="d">Tuple</a> or <a href="eval.txt.html#Blob" class="d">Blob</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;join()                    <a href="pattern.txt.html#%23" class="d">#</a> E1529: <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Tuple" class="d">Tuple</a> required for
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;max()                     <a href="pattern.txt.html#%23" class="d">#</a> E1530: <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Tuple" class="d">Tuple</a> or <a href="eval.txt.html#Dictionary" class="d">Dictionary</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;get(9)                    <a href="pattern.txt.html#%23" class="d">#</a> E1531: Argument of <a href="builtin.txt.html#get%28%29" class="d">get()</a> <a href="vim_faq.txt.html#must" class="d">must</a> be <a href="insert.txt.html#a" class="d">a</a>
	<a href="vim9.txt.html#vim9" class="d">vim9</a> 9-&gt;tuple2list()              <a href="pattern.txt.html#%23" class="d">#</a> E1534: <a href="eval.txt.html#Tuple" class="d">Tuple</a> required for argument
<a href="change.txt.html#%3C" class="d">&lt;</a>
Reserved for future use:			<span id="E1227" class="t">E1227</span> <span id="E1250" class="t">E1250</span> <span id="E1252" class="t">E1252</span>
	E1227: <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Dictionary" class="d">Dictionary</a> required for argument %d
	E1250: Argument of %s <a href="vim_faq.txt.html#must" class="d">must</a> be <a href="insert.txt.html#a" class="d">a</a> List, String, <a href="eval.txt.html#Dictionary" class="d">Dictionary</a> or <a href="eval.txt.html#Blob" class="d">Blob</a>
	E1252: String, <a href="eval.txt.html#List" class="d">List</a> or <a href="eval.txt.html#Blob" class="d">Blob</a> required for argument %d


<span class="h">Categories of variables, defaults and null handling </span>
					<span id="variable-categories" class="t">variable-categories</span> <span id="null-variables" class="t">null-variables</span>
There are three categories of variables:
	primitive	number, float, <a href="options.txt.html#boolean" class="d">boolean</a>
	container	string, blob, list, tuple, <a href="eval.txt.html#dict" class="d">dict</a>
	specialized	function, job, channel, user-defined-object

When declaring <a href="insert.txt.html#a" class="d">a</a> variable without an initializer, an explicit type <a href="vim_faq.txt.html#must" class="d">must</a> be
provided.  Each category has different default <a href="starting.txt.html#initialization" class="d">initialization</a> semantics.

Primitives default to type-specific values.  All primitives are empty but <a href="diff.txt.html#do" class="d">do</a>
not equal <span class="e">null</span>: &gt;vim9

    <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
    var n: number | echo [n, n-&gt;empty(), <a href="pattern.txt.html#n" class="d">n</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [0, 1, false]
    var f: float  | echo [f, f-&gt;empty(), <a href="motion.txt.html#f" class="d">f</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [0.0, 1, false]
    var <a href="eval.txt.html#b%3A" class="d">b:</a> bool   | echo [b, b-&gt;empty(), <a href="motion.txt.html#b" class="d">b</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [false, 1, false]
<a href="change.txt.html#%3C" class="d">&lt;</a>
Containers default to an empty container.  Only an empty <a href="eval.txt.html#string" class="d">string</a> equals <span class="e">null</span>: &gt;vim9

    <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
    var s: <a href="eval.txt.html#string" class="d">string</a>       | echo [s, s-&gt;empty(), <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> ['', 1, true]
    var z: <a href="eval.txt.html#blob" class="d">blob</a>         | echo [z, z-&gt;empty(), <a href="index.txt.html#z" class="d">z</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [0z, 1, false]
    var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;string&gt; | echo [l, l-&gt;empty(), <a href="motion.txt.html#l" class="d">l</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [[], 1, false]
    var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt;   | echo [t, t-&gt;empty(), <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [(), 1, false]
    var d: dict&lt;number&gt; | echo [d, d-&gt;empty(), <a href="change.txt.html#d" class="d">d</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [{}, 1, false]
<a href="change.txt.html#%3C" class="d">&lt;</a>
Specialized types default to equaling <span class="e">null</span>: &gt;vim9

    <a href="vim9.txt.html#vim9script" class="d">vim9script</a>
    var F: func    | echo [F, <a href="motion.txt.html#F" class="d">F</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [function(''), true]
    var j: <a href="channel.txt.html#job" class="d">job</a>     | echo [j, <a href="motion.txt.html#j" class="d">j</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> ['no process', true]
    var c: <a href="channel.txt.html#channel" class="d">channel</a> | echo [c, <a href="change.txt.html#c" class="d">c</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> ['channel fail', true]
    <a href="vim9class.txt.html#class" class="d">class</a> <a href="vim9class.txt.html#Class" class="d">Class</a>
    endclass
    var o: <a href="vim9class.txt.html#Class" class="d">Class</a>   | echo [o, <a href="insert.txt.html#o" class="d">o</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [object of <span class="s">[unknown]</span>, true]
    <a href="vim9class.txt.html#enum" class="d">enum</a> Enum
    endenum
    var e: Enum    | echo [e, <a href="motion.txt.html#e" class="d">e</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null]  <a href="pattern.txt.html#%23" class="d">#</a> [object of <span class="s">[unknown]</span>, true]
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">Note:</span> See <a href="builtin.txt.html#empty%28%29" class="l">empty()</a> for explanations of empty job, empty channel, and
		empty <a href="vim9class.txt.html#object" class="d">object</a> types.

Vim does not have <a href="insert.txt.html#a" class="d">a</a> familiar <a href="vim9.txt.html#null" class="d">null</a> value.  Instead, <a href="motion.txt.html#it" class="d">it</a> has <a href="various.txt.html#various" class="d">various</a> null_&lt;type&gt;
predefined values including <a href="vim9.txt.html#null_string" class="l">null_string</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="vim9.txt.html#null_list" class="l">null_list</a><a href="motion.txt.html#%2C" class="d">,</a> and <a href="vim9.txt.html#null_job" class="l">null_job</a><a href="repeat.txt.html#." class="d">.</a>
Primitives <a href="diff.txt.html#do" class="d">do</a> not have <a href="insert.txt.html#a" class="d">a</a> null_&lt;type&gt;.  Typical use cases for null_&lt;type&gt; are:
    <a href="motion.txt.html#-" class="d">-</a> to clear <a href="insert.txt.html#a" class="d">a</a> variable and release its resources,
    <a href="motion.txt.html#-" class="d">-</a> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> default for <a href="insert.txt.html#a" class="d">a</a> parameter in <a href="insert.txt.html#a" class="d">a</a> function definition (for an example,
      see <a href="vim9.txt.html#null_blob" class="l">null_blob</a>), or
    <a href="motion.txt.html#-" class="d">-</a> assigned to <a href="insert.txt.html#a" class="d">a</a> container or specialized variable to set <a href="motion.txt.html#it" class="d">it</a> to <a href="vim9.txt.html#null" class="d">null</a>
      for later comparison (for an example, see <a href="vim9.txt.html#null-compare" class="l">null-compare</a>).

For <a href="insert.txt.html#a" class="d">a</a> specialized variable, like <span class="e">job</span>, null_&lt;type&gt; <a href="motion.txt.html#is" class="d">is</a> used to clear the
resources.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var mydate: list&lt;string&gt;
	def Date(channel: channel, msg: string): void
	    mydate-&gt;add(msg)
	enddef
	var myjob <a href="change.txt.html#%3D" class="d">=</a> job_start([&amp;shell, &amp;shellcmdflag, <span class="o">'date'</span>], <span class="s">{out_cb: Date}</span>)
	echo [myjob, myjob-&gt;job_status()]
	sleep 2
	echo <a href="motion.txt.html#%24" class="d">$</a>"The date and time <a href="motion.txt.html#is" class="d">is</a> <span class="s">{mydate-&gt;join('')}</span>"
	echo [myjob, myjob-&gt;job_status()]
	myjob <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_job" class="d">null_job</a>  <a href="pattern.txt.html#%23" class="d">#</a> Clear the variable; release the job's resources.
	echo myjob
<a href="change.txt.html#%3C" class="d">&lt;</a>
For <a href="insert.txt.html#a" class="d">a</a> container variable, resources may also be cleared by assigning an
empty container to the variable.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var perfect: list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> [1, 4]
	perfect-&gt;extend([9, 16, 25])
	perfect <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	echo perfect

Using an empty container, rather than null_&lt;type&gt;, to clear <a href="insert.txt.html#a" class="d">a</a> container
variable may avoid <a href="vim9.txt.html#null" class="d">null</a> complications <a href="motion.txt.html#-" class="d">-</a> see <a href="vim9.txt.html#null-anomalies" class="l">null-anomalies</a><a href="repeat.txt.html#." class="d">.</a>

The <a href="starting.txt.html#initialization" class="d">initialization</a> semantics of container <a href="eval.txt.html#variables" class="d">variables</a> and specialized <a href="eval.txt.html#variables" class="d">variables</a>
differ.  For containers:
  <a href="motion.txt.html#-" class="d">-</a> An uninitialized container defaults to empty but does not equal <span class="e">null</span>
    (except for <a href="insert.txt.html#a" class="d">a</a> uninitialized string).
  <a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#A" class="d">A</a> container initialized to [], (), {}, ""<a href="motion.txt.html#%2C" class="d">,</a> or 0z <a href="motion.txt.html#is" class="d">is</a> empty but does not
    equal <span class="e">null</span>.
  <a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#A" class="d">A</a> container initialized <a href="motion.txt.html#as" class="d">as</a> null_&lt;type&gt; defaults to empty and equals <span class="e">null</span>.

In the following example, the uninitialized <a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#%28" class="d">(</a>"lu"<a href="motion.txt.html#%29" class="d">)</a> and <a href="motion.txt.html#%5B%5D" class="d">[]</a> initialized
<a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#%28" class="d">(</a>"li"<a href="motion.txt.html#%29" class="d">)</a> are equivalent and indistinguishable whereas "ln" <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a>
container, which <a href="motion.txt.html#is" class="d">is</a> similar to, but not equivalent to, an empty container
(see <a href="vim9.txt.html#null-anomalies" class="l">null-anomalies</a>). &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> uninitialized: empty container, not <a href="vim9.txt.html#null" class="d">null</a>
	var lu: list&lt;any&gt;
	echo ['lu', <a href="motion.txt.html#%24" class="d">$</a>"empty={lu-&gt;empty()}"<a href="motion.txt.html#%2C" class="d">,</a> <a href="motion.txt.html#%24" class="d">$</a>"null={lu <a href="change.txt.html#%3D%3D" class="d">==</a> null}"<a href="index.txt.html#%5D" class="d">]</a>
	<a href="pattern.txt.html#%23" class="d">#</a> initialized: empty container, not <a href="vim9.txt.html#null" class="d">null</a>
	var li: list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	echo ['li', <a href="motion.txt.html#%24" class="d">$</a>"empty={li-&gt;empty()}"<a href="motion.txt.html#%2C" class="d">,</a> <a href="motion.txt.html#%24" class="d">$</a>"null={li <a href="change.txt.html#%3D%3D" class="d">==</a> null}"<a href="index.txt.html#%5D" class="d">]</a>
	<a href="pattern.txt.html#%23" class="d">#</a> initialized: empty container, <a href="vim9.txt.html#null" class="d">null</a>
	var ln: list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_list" class="d">null_list</a>
	echo ['ln', <a href="motion.txt.html#%24" class="d">$</a>"empty={ln-&gt;empty()}"<a href="motion.txt.html#%2C" class="d">,</a> <a href="motion.txt.html#%24" class="d">$</a>"null={ln <a href="change.txt.html#%3D%3D" class="d">==</a> null}"<a href="index.txt.html#%5D" class="d">]</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
Specialized <a href="eval.txt.html#variables" class="d">variables</a> default to equaling null.  These <a href="channel.txt.html#job" class="d">job</a> initializations
are equivalent and indistinguishable: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var j1: <a href="channel.txt.html#job" class="d">job</a>
	var j2: <a href="channel.txt.html#job" class="d">job</a> <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_job" class="d">null_job</a>
	var j3 <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_job" class="d">null_job</a>
	echo (j1 <a href="change.txt.html#%3D%3D" class="d">==</a> j2) <a href="change.txt.html#%3D%3D" class="d">==</a> (j2 <a href="change.txt.html#%3D%3D" class="d">==</a> j3)  <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a> (equivalent, indistinguishable)
<a href="change.txt.html#%3C" class="d">&lt;</a>
When <a href="insert.txt.html#a" class="d">a</a> list, tuple, or <a href="eval.txt.html#dict" class="d">dict</a> <a href="motion.txt.html#is" class="d">is</a> declared, if the item type <a href="motion.txt.html#is" class="d">is</a> not specified
<a href="motion.txt.html#it" class="d">it</a> cannot be inferred.  Consequently, the item type defaults to "any"<a href="cmdline.txt.html#%3A" class="d">:</a> &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var [t1, t2] <a href="change.txt.html#%3D" class="d">=</a> [(), null_tuple]
	echo $'t1 <a href="motion.txt.html#is" class="d">is</a> <span class="s">{t1-&gt;typename()}</span> and t2 <a href="motion.txt.html#is" class="d">is</a> <span class="s">{t2-&gt;typename()}</span> too'
<a href="change.txt.html#%3C" class="d">&lt;</a>
<a href="eval.txt.html#Tuples" class="d">Tuples</a> and <a href="eval.txt.html#functions" class="d">functions</a> (or partials) may be declared in <a href="various.txt.html#various" class="d">various</a> ways.
See <a href="vim9.txt.html#tuple-type" class="l">tuple-type</a><a href="motion.txt.html#%2C" class="d">,</a> <a href="vim9.txt.html#variadic-tuple" class="l">variadic-tuple</a><a href="motion.txt.html#%2C" class="d">,</a> and <a href="vim9.txt.html#vim9-func-declaration" class="l">vim9-func-declaration</a><a href="repeat.txt.html#." class="d">.</a>

						<span id="null-compare" class="t">null-compare</span>
For familiar <a href="vim9.txt.html#null" class="d">null</a> compare semantics, where an empty container <a href="motion.txt.html#is" class="d">is</a> not equal to
<a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a> container, <a href="diff.txt.html#do" class="d">do</a> not use null_&lt;type&gt; in <a href="insert.txt.html#a" class="d">a</a> comparison.  That <a href="motion.txt.html#is" class="d">is</a> because,
in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, although null_&lt;type&gt; <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="e">null</span>, comparing an:

  <a href="motion.txt.html#-" class="d">-</a> empty container to <span class="e">null</span> <a href="motion.txt.html#is" class="d">is</a> <span class="e">false</span>, but
  <a href="motion.txt.html#-" class="d">-</a> empty container to null_&lt;type&gt; <a href="motion.txt.html#is" class="d">is</a> <span class="e">true</span>.

So, compare against <span class="e">null</span>, not null_&lt;type&gt;.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var bonds: dict&lt;list&lt;string&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> <span class="s">{g: ['007', '008'], o: ['007', '009']}</span>
	def Search(query: string): list&lt;string&gt;
	    return query <a href="change.txt.html#%3D%3D" class="d">==</a> "\r" <a href="pattern.txt.html#%3F" class="d">?</a> <a href="vim9.txt.html#null_list" class="d">null_list</a> <a href="cmdline.txt.html#%3A" class="d">:</a> bonds-&gt;get(query, [])
	enddef
	echo "Goldfinger (g) or Octopussy (o)?: "
	const C: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> <a href="builtin.txt.html#getcharstr%28%29" class="d">getcharstr()</a>
	var result: list&lt;string&gt; <a href="change.txt.html#%3D" class="d">=</a> C-&gt;Search()
	if result <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>  <a href="pattern.txt.html#%23" class="d">#</a> &lt;&lt;&lt; DO NOT USE <a href="vim9.txt.html#null_list" class="d">null_list</a> HERE!
	    echo "Error: Nothing was entered"
	else
	    echo result-&gt;empty() <a href="pattern.txt.html#%3F" class="d">?</a> <a href="motion.txt.html#%24" class="d">$</a>"No matches for '{C}'" <a href="cmdline.txt.html#%3A" class="d">:</a> <a href="motion.txt.html#%24" class="d">$</a>"<span class="s">{result}</span>"
	endif
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">NOTE:</span> Using "result <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_list" class="d">null_list</a>" instead of "result <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>" would
		fail to distinguish the error (nothing entered) and the valid
		(nothing matched) result because <a href="motion.txt.html#%5B%5D" class="d">[]</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_list" class="d">null_list</a> whereas
		<a href="motion.txt.html#%5B%5D" class="d">[]</a> != null.

Conceptually, think of the null_&lt;type&gt; construct <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> hybrid/bridge between
the general <span class="e">null</span> and typed <span class="e">empty</span> containers, having properties of both.
In the following <a href="motion.txt.html#section" class="d">section</a> there are details about comparison results.

					<span id="null-details" class="t">null-details</span> <span id="null-anomalies" class="t">null-anomalies</span>
This <a href="motion.txt.html#section" class="d">section</a> describes issues about using <a href="vim9.txt.html#null" class="d">null</a> and null_&lt;type&gt;; included below
are the enumerated results of <a href="vim9.txt.html#null" class="d">null</a> comparisons.  In some cases, if familiar
with <a href="vim9.txt.html#vim9" class="d">vim9</a> <a href="vim9.txt.html#null" class="d">null</a> semantics, the programmer may choose to use null_&lt;type&gt; in
comparisons and/or other situations.

Elsewhere in the documentation <a href="motion.txt.html#it" class="d">it</a> says, "often <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#null" class="d">null</a> value <a href="motion.txt.html#is" class="d">is</a> handled the
same <a href="motion.txt.html#as" class="d">as</a> an empty value, but not always"<a href="repeat.txt.html#." class="d">.</a>  For example, you cannot add to <a href="insert.txt.html#a" class="d">a</a>
<a href="vim9.txt.html#null" class="d">null</a> container: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var le: list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	le-&gt;add('Okay')		<a href="pattern.txt.html#%23" class="d">#</a> le <a href="motion.txt.html#is" class="d">is</a> now ['Okay']
	var ln <a href="change.txt.html#%3D" class="d">=</a> <a href="vim9.txt.html#null_list" class="d">null_list</a>
	ln-&gt;add("<a href="vim9.txt.html#E1130" class="d">E1130</a>"<a href="motion.txt.html#%29" class="d">)</a>	<a href="pattern.txt.html#%23" class="d">#</a> E1130: Cannot add to <a href="vim9.txt.html#null" class="d">null</a> <a href="eval.txt.html#list" class="d">list</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
As explained in <a href="vim9.txt.html#null-compare" class="l">null-compare</a><a href="motion.txt.html#%2C" class="d">,</a> there <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> non-transitive relationship among
<span class="e">null</span>, null_&lt;type&gt; containers, and <span class="e">empty</span>.  To recap, for example: &gt;vim9

	vim9cmd echo (null_dict <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="s">{}, null_dict == null, {}</span> != null)
<a href="change.txt.html#%3C" class="d">&lt;</a>
The exception <a href="motion.txt.html#is" class="d">is</a> an uninitialized string.  It <a href="motion.txt.html#is" class="d">is</a> equal to <span class="e">null</span> (and <a href="motion.txt.html#is" class="d">is</a> the
same instance <a href="motion.txt.html#as" class="d">as</a> <span class="e">null_string</span>).  The <a href="options.txt.html#%27is%27" class="o">'is'</a> <a href="motion.txt.html#operator" class="d">operator</a> <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#expr-is" class="l">expr-is</a><a href="motion.txt.html#%29" class="d">)</a> may be used to
determine whether <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#is" class="d">is</a> uninitialized: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var s: <a href="eval.txt.html#string" class="d">string</a>
	echo <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_string" class="d">null_string</a>		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
	echo <a href="change.txt.html#s" class="d">s</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#null_string" class="d">null_string</a>		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a> (the same instance)
	echo <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>			<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a> (unexpected, perhaps)
	echo <a href="change.txt.html#s" class="d">s</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#null" class="d">null</a>			<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a> (not the same instance)
<a href="change.txt.html#%3C" class="d">&lt;</a>
However, don't <a href="diff.txt.html#do" class="d">do</a> the same for the other containers because, when evaluated
against their applicable null_&lt;type&gt; with <a href="options.txt.html#%27is%27" class="o">'is'</a>, they return <span class="e">false</span>: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var d: dict&lt;any&gt;
	echo <a href="change.txt.html#d" class="d">d</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_dict" class="d">null_dict</a>		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
	echo <a href="change.txt.html#d" class="d">d</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#null_dict" class="d">null_dict</a>		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a> (not the same instance)
	echo <a href="change.txt.html#d" class="d">d</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>			<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a> (as expected)
	echo <a href="change.txt.html#d" class="d">d</a> <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#null" class="d">null</a>			<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a> (not the same instance)
<a href="change.txt.html#%3C" class="d">&lt;</a>
The key distinction here <a href="motion.txt.html#is" class="d">is</a> an uninitialized <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#is" class="d">is</a> implemented <a href="motion.txt.html#as" class="d">as</a>
<span class="e">null_string</span>, while an uninitialized list, dict, tuple, or <a href="eval.txt.html#blob" class="d">blob</a> <a href="motion.txt.html#is" class="d">is</a>
implemented <a href="motion.txt.html#as" class="d">as</a> an empty container ([], {}, (), and 0z respectively).
So, those uninitialized types are equal to, but not the same instance as,
their null_&lt;type&gt; counterparts, <a href="motion.txt.html#as" class="d">as</a> this example shows: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt;
	echo <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null_tuple		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
	echo <a href="motion.txt.html#t" class="d">t</a> <a href="motion.txt.html#is" class="d">is</a> null_tuple		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a>

However, <a href="insert.txt.html#a" class="d">a</a> variable initialized to the null_&lt;type&gt; <a href="motion.txt.html#is" class="d">is</a> equal not only to the
null_&lt;type&gt;, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> also equal to null.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> null_tuple
	echo <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null_tuple		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
	echo <a href="motion.txt.html#t" class="d">t</a> <a href="motion.txt.html#is" class="d">is</a> null_tuple		<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
	echo <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>			<a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
An uninitialized container variable <a href="motion.txt.html#is" class="d">is</a> not equal to null, except for an
uninitialized string, which <a href="motion.txt.html#is" class="d">is</a> explained in an example, above.  So, these
all echo <span class="e">true</span>: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var <a href="eval.txt.html#b%3A" class="d">b:</a> <a href="eval.txt.html#blob" class="d">blob</a>		| echo <a href="motion.txt.html#b" class="d">b</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var d: dict&lt;any&gt;	| echo <a href="change.txt.html#d" class="d">d</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;any&gt;	| echo <a href="motion.txt.html#l" class="d">l</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt;	| echo <a href="motion.txt.html#t" class="d">t</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var s: <a href="eval.txt.html#string" class="d">string</a>		| echo <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>

An uninitialized specialized variable <a href="motion.txt.html#is" class="d">is</a> equal to <a href="vim9.txt.html#null" class="d">null</a> so these all echo <span class="e">true</span>: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var c: <a href="channel.txt.html#channel" class="d">channel</a>		| echo <a href="change.txt.html#c" class="d">c</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>
	var F: func		| echo <a href="motion.txt.html#F" class="d">F</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>
	var j: <a href="channel.txt.html#job" class="d">job</a>		| echo <a href="motion.txt.html#j" class="d">j</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>
	<a href="vim9class.txt.html#class" class="d">class</a> <a href="vim9class.txt.html#Class" class="d">Class</a>
	endclass
	var nc: <a href="vim9class.txt.html#Class" class="d">Class</a>		| echo nc <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>
	<a href="vim9class.txt.html#enum" class="d">enum</a> Enum
	endenum
	var ne: Enum		| echo ne <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null" class="d">null</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
	  <span class="n">Note:</span> the specialized variables, like job, default to <a href="vim9.txt.html#null" class="d">null</a> and
		no specialized variable has <a href="insert.txt.html#a" class="d">a</a> corresponding empty value.

<a href="insert.txt.html#A" class="d">A</a> container variable initialized to empty equals null_&lt;type&gt;, so these are all
<span class="e">true</span>: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var s: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> ""     | echo <a href="change.txt.html#s" class="d">s</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_string" class="d">null_string</a>
	var <a href="eval.txt.html#b%3A" class="d">b:</a> <a href="eval.txt.html#blob" class="d">blob</a> <a href="change.txt.html#%3D" class="d">=</a> 0z       | echo <a href="motion.txt.html#b" class="d">b</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_blob" class="d">null_blob</a>
	var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>  | echo <a href="motion.txt.html#l" class="d">l</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_list" class="d">null_list</a>
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> () | echo <a href="motion.txt.html#t" class="d">t</a> <a href="change.txt.html#%3D%3D" class="d">==</a> null_tuple
	var d: dict&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="intro.txt.html#%7B%7D" class="d">{}</a>  | echo <a href="change.txt.html#d" class="d">d</a> <a href="change.txt.html#%3D%3D" class="d">==</a> <a href="vim9.txt.html#null_dict" class="d">null_dict</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
However, <a href="insert.txt.html#a" class="d">a</a> container variable initialized to empty does not equal null, so
these are all <span class="e">true</span>: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	var s: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> ""     | echo <a href="change.txt.html#s" class="d">s</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var <a href="eval.txt.html#b%3A" class="d">b:</a> <a href="eval.txt.html#blob" class="d">blob</a> <a href="change.txt.html#%3D" class="d">=</a> 0z       | echo <a href="motion.txt.html#b" class="d">b</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var <a href="eval.txt.html#l%3A" class="d">l:</a> list&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>  | echo <a href="motion.txt.html#l" class="d">l</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var <a href="eval.txt.html#t%3A" class="d">t:</a> tuple&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> () | echo <a href="motion.txt.html#t" class="d">t</a> != <a href="vim9.txt.html#null" class="d">null</a>
	var d: dict&lt;any&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="intro.txt.html#%7B%7D" class="d">{}</a>  | echo <a href="change.txt.html#d" class="d">d</a> != <a href="vim9.txt.html#null" class="d">null</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">==============================================================================</span>

						<span id="generic-functions" class="t">generic-functions</span>
5. Generic <a href="eval.txt.html#functions" class="d">functions</a>

<a href="insert.txt.html#A" class="d">A</a> generic function allows using the same function with different type
arguments, while retaining type checking for arguments and the return value.
This provides type safety and code reusability.


<span class="h">Declaration</span>
						<span id="generic-function-declaration" class="t">generic-function-declaration</span>
						<span id="E1553" class="t">E1553</span> <span id="E1554" class="t">E1554</span>
The type <a href="eval.txt.html#variables" class="d">variables</a> for <a href="insert.txt.html#a" class="d">a</a> generic function are declared <a href="motion.txt.html#as" class="d">as</a> its type parameters
within angle brackets <a href="motion.txt.html#%28" class="d">(</a>"<a href="change.txt.html#%3C" class="d">&lt;</a>" and "<a href="change.txt.html#%3E" class="d">&gt;</a>"), directly after the function name.
Multiple type parameters are separated by commas: 
<span class="e"></span>
<span class="e">	def[!] {funcname}&lt;{type} [, {types}]&gt;([arguments])[: {return-type}]</span>
<span class="e">	    {function body}</span>
<span class="e">	enddef</span>
						<span id="generic-function-example" class="t">generic-function-example</span>
These type parameters may then be used, like any other type, within the
function signature and its body.  The following example combines two lists
into <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> of tuples: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def Zip&lt;T, U&gt;(first: list&lt;T&gt;, second: list&lt;U&gt;): list&lt;tuple&lt;T, U&gt;&gt;
	    const LEN: number <a href="change.txt.html#%3D" class="d">=</a> ([first-&gt;len(), second-&gt;len()])-&gt;min()
	    final result: list&lt;tuple&lt;T, U&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	    for <a href="insert.txt.html#i" class="d">i</a> in range(LEN)
	        result-&gt;add((first[i], second[i]))
	    endfor
	    return result
	enddef
	var n: list&lt;number&gt; <a href="change.txt.html#%3D" class="d">=</a> [61, 62, 63]
	var s: list&lt;string&gt; <a href="change.txt.html#%3D" class="d">=</a> ['a', 'b', 'c']
	echo <a href="motion.txt.html#%24" class="d">$</a>"Zip example #1: <span class="s">{Zip&lt;number, string&gt;(n, s)}</span>"
	echo <a href="motion.txt.html#%24" class="d">$</a>"Zip example #2: <span class="s">{Zip&lt;string, number&gt;(s, n)}</span>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="type-variable-naming" class="t">type-variable-naming</span> <span id="E1552" class="t">E1552</span>
						<span id="type-parameter-naming" class="t">type-parameter-naming</span>
As in the preceding example, the convention <a href="motion.txt.html#is" class="d">is</a> to use <a href="insert.txt.html#a" class="d">a</a> single capital <a href="print.txt.html#letter" class="d">letter</a>
for <a href="insert.txt.html#a" class="d">a</a> name (e.g., T, U, A, etc.).  Although they may comprise more than one
letter, names <a href="vim_faq.txt.html#must" class="d">must</a> start with <a href="insert.txt.html#a" class="d">a</a> capital letter.  In this example, "Ok" <a href="motion.txt.html#is" class="d">is</a>
valid whereas "<a href="pattern.txt.html#n" class="d">n</a>" <a href="motion.txt.html#is" class="d">is</a> not: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def MyFail&lt;Ok, n&gt;(): void
	enddef
	<a href="pattern.txt.html#%23" class="d">#</a> E1552: Type variable name <a href="vim_faq.txt.html#must" class="d">must</a> start with an <a href="change.txt.html#uppercase" class="d">uppercase</a> letter: n...
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="E1558" class="t">E1558</span> <span id="E1560" class="t">E1560</span>
<a href="insert.txt.html#A" class="d">A</a> function <a href="vim_faq.txt.html#must" class="d">must</a> be declared and used either <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> generic function or <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a>
regular function, but not both.  The following <a href="vim9.txt.html#Vim9" class="d">Vim9</a> scripts demonstrate these
errors: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	My1558&lt;number&gt;()
	<a href="pattern.txt.html#%23" class="d">#</a> E1558: Unknown generic function: My1558
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1560(): void
	enddef
	My1560&lt;string&gt;()
	<a href="pattern.txt.html#%23" class="d">#</a> E1560: Not <a href="insert.txt.html#a" class="d">a</a> generic function: My1560
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="E1561" class="t">E1561</span>
Type parameter names <a href="vim_faq.txt.html#must" class="d">must</a> not clash with other identifiers: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1561&lt;D, E, D&gt;(): <a href="change.txt.html#D" class="d">D</a>
	enddef
	<a href="pattern.txt.html#%23" class="d">#</a> E1561: Duplicate type variable name: <a href="change.txt.html#D" class="d">D</a>

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="vim9class.txt.html#enum" class="d">enum</a> <a href="motion.txt.html#E" class="d">E</a>
	  Yes, No
	endenum
	def My1041&lt;E&gt;(): <a href="motion.txt.html#E" class="d">E</a>
	enddef
	<a href="pattern.txt.html#%23" class="d">#</a> E0141: Redefining <a href="usr_41.txt.html#script" class="d">script</a> item "<a href="motion.txt.html#E" class="d">E</a>"
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">Calling a generic function</span>
						<span id="generic-function-call" class="t">generic-function-call</span>
To call <a href="insert.txt.html#a" class="d">a</a> generic function, specify the concrete types in "<a href="change.txt.html#%3C" class="d">&lt;</a>" and "<a href="change.txt.html#%3E" class="d">&gt;</a>"
between the function name and the argument list: 
<span class="e"></span>
<span class="e">	MyFunc&lt;number, string, list&lt;number&gt;&gt;()</span>

	<span class="n">NOTE:</span> There are several working examples in this section, which may
	      be sourced, including <a href="vim9.txt.html#generic-function-example" class="l">generic-function-example</a><a href="repeat.txt.html#." class="d">.</a>

					<span id="E1555" class="t">E1555</span> <span id="E1556" class="t">E1556</span> <span id="E1557" class="t">E1557</span> <span id="E1559" class="t">E1559</span>
The number of passed type arguments to the function <a href="vim_faq.txt.html#must" class="d">must</a> match the number
of its declared type parameters.  An empty type <a href="eval.txt.html#list" class="d">list</a> <a href="motion.txt.html#is" class="d">is</a> not allowed.
Examples: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1555&lt;&gt;(): void
	enddef
	<a href="pattern.txt.html#%23" class="d">#</a> E1555: Empty type <a href="eval.txt.html#list" class="d">list</a> specified for generic function <a href="userfunc.txt.html#..." class="d">...</a>
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1556&lt;T&gt;(): void
	enddef
	My1556&lt;bool, bool&gt;()
	<a href="pattern.txt.html#%23" class="d">#</a> E1556: Too many types specified for generic function <a href="userfunc.txt.html#..." class="d">...</a>
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1557&lt;T, U&gt;(): void
	enddef
	My1557&lt;bool&gt;()
	<a href="pattern.txt.html#%23" class="d">#</a> E1557: Not enough types specified for generic function <a href="userfunc.txt.html#..." class="d">...</a>
<a href="change.txt.html#%3C" class="d">&lt;</a> &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def My1559&lt;T&gt;(): <a href="motion.txt.html#T" class="d">T</a>
	enddef
	My1559()
	<a href="pattern.txt.html#%23" class="d">#</a> Vim(eval):E1559: Type arguments missing for generic function <a href="userfunc.txt.html#..." class="d">...</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>
Any <a href="vim9.txt.html#Vim9" class="d">Vim9</a> type <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#vim9-types" class="l">vim9-types</a><a href="motion.txt.html#%29" class="d">)</a> can be used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> concrete type in <a href="insert.txt.html#a" class="d">a</a> generic
function.

Spaces are not allowed:
<a href="motion.txt.html#-" class="d">-</a> Between the function name and "<a href="change.txt.html#%3C" class="d">&lt;</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#E1068" class="l">E1068</a><a href="motion.txt.html#%29" class="d">)</a>
<a href="motion.txt.html#-" class="d">-</a> Between "<a href="change.txt.html#%3E" class="d">&gt;</a>" and the opening "<a href="motion.txt.html#%28" class="d">(</a>" <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#E1068" class="l">E1068</a>), or
<a href="motion.txt.html#-" class="d">-</a> Within the "<a href="change.txt.html#%3C" class="d">&lt;</a>" and "<a href="change.txt.html#%3E" class="d">&gt;</a>"<a href="motion.txt.html#%2C" class="d">,</a> except where required after the comma separating
  the types <a href="motion.txt.html#%28" class="d">(</a><a href="vim9.txt.html#E1202" class="l">E1202</a>).

<a href="insert.txt.html#A" class="d">A</a> generic function can be exported and imported like <a href="insert.txt.html#a" class="d">a</a> regular function.
See <a href="vim9.txt.html#%3Aexport" class="l">:export</a> and <a href="vim9.txt.html#%3Aimport" class="l">:import</a><a href="repeat.txt.html#." class="d">.</a>

<a href="insert.txt.html#A" class="d">A</a> generic function can be defined inside another regular or generic function.
Example: &gt;vim9
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def Outer(): void
	  <a href="pattern.txt.html#%23" class="d">#</a> Returns either the first item of <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#list" class="d">list</a> or <a href="insert.txt.html#a" class="d">a</a> default value
	  def FirstOrDefault&lt;T, U&gt;(lst: list&lt;T&gt;, default: U): any
	    return lst-&gt;len() <a href="change.txt.html#%3E" class="d">&gt;</a> <a href="motion.txt.html#0" class="d">0</a> <a href="pattern.txt.html#%3F" class="d">?</a> lst[0] <a href="cmdline.txt.html#%3A" class="d">:</a> default
	  enddef
	  echo FirstOrDefault&lt;string, bool&gt;(['B', 'C'], false)	<a href="pattern.txt.html#%23" class="d">#</a> echos <a href="motion.txt.html#B" class="d">B</a>
	  echo FirstOrDefault&lt;number, number&gt;([], 42)		<a href="pattern.txt.html#%23" class="d">#</a> echos <a href="usr_42.txt.html#42" class="d">42</a>
	enddef
	Outer()
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">Using a type variable as a type argument </span>

<a href="insert.txt.html#A" class="d">A</a> type variable may also be passed <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> type argument.  For example: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> <a href="motion.txt.html#T" class="d">T</a> <a href="motion.txt.html#is" class="d">is</a> declared <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> type parameter
	<a href="pattern.txt.html#%23" class="d">#</a> It <a href="motion.txt.html#is" class="d">is</a> used for the <span class="o">'value'</span> parameter and the return type
	def Id&lt;T&gt;(value: T): <a href="motion.txt.html#T" class="d">T</a>
	    return value
	enddef
	<a href="pattern.txt.html#%23" class="d">#</a> <a href="undo.txt.html#U" class="d">U</a> <a href="motion.txt.html#is" class="d">is</a> declared <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> type parameter
	<a href="pattern.txt.html#%23" class="d">#</a> It <a href="motion.txt.html#is" class="d">is</a> used for the <span class="o">'value'</span> parameter and the return type
	def CallId&lt;U&gt;(value: U): <a href="undo.txt.html#U" class="d">U</a>
	    <a href="pattern.txt.html#%23" class="d">#</a> <a href="undo.txt.html#U" class="d">U</a> <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> type variable passed/used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> type argument
	    return Id&lt;U&gt;(value)
	enddef
	echo CallId&lt;string&gt;('I am') .. <a href="motion.txt.html#%27" class="d">'</a> <a href="motion.txt.html#%27" class="d">'</a> .. CallId&lt;number&gt;(42)

This <a href="motion.txt.html#is" class="d">is</a> useful for complex data structures like dictionaries of lists or,
<a href="motion.txt.html#as" class="d">as</a> in the following example, lists of dictionaries: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	def Flatten&lt;T&gt;(x: list&lt;list&lt;T&gt;&gt;): list&lt;T&gt;
	    final result: list&lt;T&gt; <a href="change.txt.html#%3D" class="d">=</a> <a href="motion.txt.html#%5B%5D" class="d">[]</a>
	    for inner in <a href="change.txt.html#x" class="d">x</a>
	        result-&gt;extend(inner)
	    endfor
	    return result
	enddef
	const ENGLISH: list&lt;dict&lt;string&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> [{1: <span class="o">'one'</span>}, <span class="s">{2: 'two'}</span>]
	const MANDARIN: list&lt;dict&lt;string&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> [{1: <a href="motion.txt.html#%27" class="d">'</a>壹'}, <span class="s">{2: '贰'}</span>]
	const ARABIC_N: list&lt;dict&lt;number&gt;&gt; <a href="change.txt.html#%3D" class="d">=</a> [{1: 1}, <span class="s">{2: 2}</span>]
	echo Flatten&lt;dict&lt;string&gt;&gt;([ENGLISH, MANDARIN])
	echo Flatten&lt;dict&lt;any&gt;&gt;([ENGLISH, ARABIC_N])
<a href="change.txt.html#%3C" class="d">&lt;</a>
In "Flatten&lt;T&gt;"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="motion.txt.html#T" class="d">T</a>" <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> declared type parameter.  Everywhere else in
the function, "<a href="motion.txt.html#T" class="d">T</a>" <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> type variable referencing that type parameter.


<span class="h">Generic class method</span>

<a href="insert.txt.html#A" class="d">A</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="vim9class.txt.html#class" class="d">class</a> <a href="eval.txt.html#method" class="d">method</a> can be <a href="insert.txt.html#a" class="d">a</a> generic function: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="vim9class.txt.html#class" class="d">class</a> Config
	    var settings: dict&lt;any&gt;
	    def Get&lt;T&gt;(key: string): <a href="motion.txt.html#T" class="d">T</a>
	        return this.settings[key]
	    enddef
	endclass
	var c: Config <a href="change.txt.html#%3D" class="d">=</a> Config.new({timeout: 30, debug: true})
	echo c.Get&lt;number&gt;('timeout')
	echo c.Get&lt;bool&gt;('debug')
<a href="change.txt.html#%3C" class="d">&lt;</a>
						<span id="E1432" class="t">E1432</span> <span id="E1433" class="t">E1433</span> <span id="E1434" class="t">E1434</span>
<a href="insert.txt.html#A" class="d">A</a> generic <a href="vim9class.txt.html#class" class="d">class</a> <a href="eval.txt.html#method" class="d">method</a> in <a href="insert.txt.html#a" class="d">a</a> base <a href="vim9class.txt.html#class" class="d">class</a> can be overridden by <a href="insert.txt.html#a" class="d">a</a> generic <a href="eval.txt.html#method" class="d">method</a>
in <a href="insert.txt.html#a" class="d">a</a> child class.  The number of type <a href="eval.txt.html#variables" class="d">variables</a> <a href="vim_faq.txt.html#must" class="d">must</a> match between both
methods.  <a href="insert.txt.html#A" class="d">A</a> concrete <a href="vim9class.txt.html#class" class="d">class</a> <a href="eval.txt.html#method" class="d">method</a> cannot be overridden by <a href="insert.txt.html#a" class="d">a</a> generic method,
and vice versa.


<span class="h">Generic function reference</span>

<a href="insert.txt.html#A" class="d">A</a> function <a href="intro.txt.html#reference" class="d">reference</a> <a href="motion.txt.html#%28" class="d">(</a><a href="eval.txt.html#Funcref" class="l">Funcref</a><a href="motion.txt.html#%29" class="d">)</a> can be <a href="insert.txt.html#a" class="d">a</a> generic function.  This allows for
creating factories of <a href="eval.txt.html#functions" class="d">functions</a> that operate on specific types: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> Match <a href="insert.txt.html#a" class="d">a</a> specified character in <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> or the decimal value of the
	<a href="pattern.txt.html#%23" class="d">#</a> character in <a href="insert.txt.html#a" class="d">a</a> list.  <span class="n">Note:</span> <a href="motion.txt.html#%27" class="d">'</a>*<a href="motion.txt.html#%27" class="d">'</a> <a href="motion.txt.html#is" class="d">is</a> decimal <a href="usr_42.txt.html#42" class="d">42</a> (U+002A)
	var c: <a href="eval.txt.html#string" class="d">string</a> <a href="change.txt.html#%3D" class="d">=</a> "*"
	var char_dec: tuple&lt;string, string&gt; <a href="change.txt.html#%3D" class="d">=</a> (c, c-&gt;char2nr()-&gt;string())
	def Matcher&lt;T&gt;(pattern: string): func(T): bool
	    return (value: T): bool =&gt; match(value, pattern) &gt;= <a href="motion.txt.html#0" class="d">0</a>
	enddef
	var StringMatch <a href="change.txt.html#%3D" class="d">=</a> Matcher&lt;string&gt;(char_dec[0])
	echo "*<a href="motion.txt.html#%2B" class="d">+</a>"-&gt;StringMatch()			    <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a> (has *<a href="motion.txt.html#%29" class="d">)</a>
	echo ",-"-&gt;StringMatch()			    <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a>
	var ListMatch <a href="change.txt.html#%3D" class="d">=</a> Matcher&lt;list&lt;number&gt;&gt;(char_dec[1])
	echo [42, 43]-&gt;ListMatch()			    <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#true" class="d">true</a> (has 42)
	echo [44, 45]-&gt;ListMatch()			    <a href="pattern.txt.html#%23" class="d">#</a> <a href="vim9.txt.html#false" class="d">false</a>
<a href="change.txt.html#%3C" class="d">&lt;</a>

<span class="h">Compiling and Disassembling Generic functions</span>

The <a href="vim9.txt.html#%3Adefcompile" class="l">:defcompile</a> command can be used to compile <a href="insert.txt.html#a" class="d">a</a> generic function with <a href="insert.txt.html#a" class="d">a</a>
specific <a href="eval.txt.html#list" class="d">list</a> of concrete types: 
<span class="e"></span>
<span class="e">	defcompile MyFunc&lt;number, list&lt;number&gt;, dict&lt;string&gt;&gt;</span>

The <a href="vim9.txt.html#%3Adisassemble" class="l">:disassemble</a> command can be used to <a href="eval.txt.html#list" class="d">list</a> the instructions generated for
<a href="insert.txt.html#a" class="d">a</a> generic function: 
<span class="e"></span>
<span class="e">	disassemble MyFunc&lt;string, dict&lt;string&gt;&gt;</span>
<span class="e">	disassemble MyFunc&lt;number, list&lt;blob&gt;&gt;</span>


<span class="h">Limitations and Future Work</span>

Currently, Vim does not support:
   <a href="motion.txt.html#-" class="d">-</a> Type inference for type variables: All types <a href="vim_faq.txt.html#must" class="d">must</a> be explicitly specified
     when calling <a href="insert.txt.html#a" class="d">a</a> generic function.
   <a href="motion.txt.html#-" class="d">-</a> Type constraints: It's not possible to restrict <a href="insert.txt.html#a" class="d">a</a> type variable to <a href="insert.txt.html#a" class="d">a</a>
     specific <a href="vim9class.txt.html#class" class="d">class</a> or <a href="vim9class.txt.html#interface" class="d">interface</a> (e.g., `T <a href="vim9class.txt.html#extends" class="d">extends</a> SomeInterface`).
   <a href="motion.txt.html#-" class="d">-</a> Default type arguments: Providing <a href="insert.txt.html#a" class="d">a</a> default type for <a href="insert.txt.html#a" class="d">a</a> type parameter
     when not explicitly specified.

<span class="h">==============================================================================</span>

<span id="_namespace--import-and-exp">6. Namespace, Import and Export</span>
					<span id="vim9script" class="t">vim9script</span> <span id="vim9-export" class="t">vim9-export</span> <span id="vim9-import" class="t">vim9-import</span>

<a href="insert.txt.html#A" class="d">A</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> can be written to be imported.  This means that some items are
intentionally exported, made available to other scripts.  When the exporting
<a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> imported in another script, these exported items can then be used in
that script.  All the other items remain <a href="map.txt.html#script-local" class="d">script-local</a> in the exporting <a href="usr_41.txt.html#script" class="d">script</a>
and cannot be accessed by the importing script.

This mechanism exists for <a href="editing.txt.html#writing" class="d">writing</a> <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> that can be sourced (imported) by
other scripts, while making sure these other scripts only have access to what
you want them to.  This also avoids using the global namespace, which has <a href="insert.txt.html#a" class="d">a</a>
risk of name collisions.  For example when you have two plugins with similar
functionality.

You can cheat by using the global namespace explicitly.  That should be done
only for things that really are global.


<span class="h">Namespace </span>
							<span id="vim9-namespace" class="t">vim9-namespace</span>
To recognize <a href="insert.txt.html#a" class="d">a</a> file that can be imported the <span class="e">vim9script</span> statement <a href="vim_faq.txt.html#must" class="d">must</a>
appear <a href="motion.txt.html#as" class="d">as</a> the first statement in the file (see <a href="vim9.txt.html#vim9-mix" class="l">vim9-mix</a> for an exception).
It tells Vim to interpret the <a href="usr_41.txt.html#script" class="d">script</a> in its own namespace, instead of the
global namespace.  If <a href="insert.txt.html#a" class="d">a</a> file starts with: 
<span class="e">	vim9script</span>
<span class="e">	var myvar = 'yes'</span>
Then "myvar" will only exist in this file.  While without <span class="e">vim9script</span> <a href="motion.txt.html#it" class="d">it</a> would
be available <a href="motion.txt.html#as" class="d">as</a> <span class="e">g:myvar</span> from any other <a href="usr_41.txt.html#script" class="d">script</a> and function.
							<span id="E1101" class="t">E1101</span>
The <a href="eval.txt.html#variables" class="d">variables</a> <a href="motion.txt.html#at" class="d">at</a> the file level are very much like the <a href="map.txt.html#script-local" class="d">script-local</a> "s:"
<a href="eval.txt.html#variables" class="d">variables</a> in legacy Vim script, but the "s:" <a href="motion.txt.html#is" class="d">is</a> omitted.  And they cannot be
deleted.

In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> the global "<a href="eval.txt.html#g%3A" class="d">g:</a>" namespace can still be used <a href="motion.txt.html#as" class="d">as</a> before.  And the
"<a href="eval.txt.html#w%3A" class="d">w:</a>"<a href="motion.txt.html#%2C" class="d">,</a> "<a href="eval.txt.html#b%3A" class="d">b:</a>" and "<a href="eval.txt.html#t%3A" class="d">t:</a>" namespaces.  These have in common that <a href="eval.txt.html#variables" class="d">variables</a> are not
declared, have no specific type and they can be deleted.  <span id="E1304" class="t">E1304</span>

<a href="insert.txt.html#A" class="d">A</a> side effect of <span class="e">:vim9script</span> <a href="motion.txt.html#is" class="d">is</a> that the <a href="options.txt.html#%27cpoptions%27" class="o">'cpoptions'</a> option <a href="motion.txt.html#is" class="d">is</a> set to the
Vim default value, like with: 
<span class="e">	:set cpo&amp;vim</span>
One of the effects <a href="motion.txt.html#is" class="d">is</a> that <a href="repeat.txt.html#line-continuation" class="l">line-continuation</a> <a href="motion.txt.html#is" class="d">is</a> always enabled.
The original value of <a href="options.txt.html#%27cpoptions%27" class="o">'cpoptions'</a> <a href="motion.txt.html#is" class="d">is</a> restored <a href="motion.txt.html#at" class="d">at</a> the <a href="intro.txt.html#end" class="d">end</a> of the script, while
flags added or removed in the <a href="usr_41.txt.html#script" class="d">script</a> are also added to or removed from the
original value to get the same effect.  The order of flags may change.
In the <a href="starting.txt.html#vimrc" class="l">vimrc</a> file sourced on <a href="starting.txt.html#startup" class="d">startup</a> this does not happen.

							<span id="vim9-mix" class="t">vim9-mix</span>
There <a href="motion.txt.html#is" class="d">is</a> one way to use both legacy and <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> in one <a href="usr_41.txt.html#script" class="d">script</a> file: &gt;vim9

	" _legacy Vim script_ comments here
	if !has('vim9script')
	   " _legacy Vim script_ comments/commands here
	   finish
	endif
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> _Vim9 script_ commands/commands from here onwards
	echowindow <a href="motion.txt.html#%24" class="d">$</a>"has('vim9script') <a href="change.txt.html#%3D%3D" class="d">==</a> <span class="s">{has('vim9script')}</span>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
This allows for <a href="editing.txt.html#writing" class="d">writing</a> <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> that takes advantage of the <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a>
<a href="syntax.txt.html#syntax" class="d">syntax</a> if possible, and prevents the <a href="vim9.txt.html#vim9script" class="d">vim9script</a> command from throwing an
error if used in <a href="insert.txt.html#a" class="d">a</a> version of Vim without 'vim9script'.

<span class="n">Note</span> that <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> changed before Vim 9 so that scripts using the current
<a href="syntax.txt.html#syntax" class="d">syntax</a> (such <a href="motion.txt.html#as" class="d">as</a> "import from" instead of "import"<a href="motion.txt.html#%29" class="d">)</a> might throw errors.
To prevent these, <a href="insert.txt.html#a" class="d">a</a> safer check may be <a href="eval.txt.html#v%3Aversion" class="l">v:version</a> &gt;= 900 instead (because
"has('vim9script')" will return <span class="e">v:true</span> back to Vim 8.2 with patch 3965).
Sometimes <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> prudent to cut off even later.  <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script's feature set
continues to grow so, for example, if tuples are used (introduced in Vim 9.1
patch 1232), <a href="insert.txt.html#a" class="d">a</a> better condition is: &gt;vim9

	if !has('patch-9.1.1232')
	  echowindow <a href="motion.txt.html#%24" class="d">$</a>"Fail: Vim does not have patch 9.1.1232"
	  finish
	endif
	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	echowindow <a href="motion.txt.html#%24" class="d">$</a>"Pass: version <span class="s">{v:versionlong}</span>.  Continuing <a href="userfunc.txt.html#..." class="d">...</a>"
<a href="change.txt.html#%3C" class="d">&lt;</a>
Whichever vim-mix condition <a href="motion.txt.html#is" class="d">is</a> used, <a href="motion.txt.html#it" class="d">it</a> only works in one of two ways:
    1. The "if" statement evaluates to false, the commands up to <span class="e">endif</span> are
       skipped and <span class="e">vim9script</span> <a href="motion.txt.html#is" class="d">is</a> then the first command actually executed.
    2. The "if" statement evaluates to true, the commands up to <span class="e">endif</span> are
       executed and <span class="e">finish</span> bails out before reaching <span class="e">vim9script</span>.


<span class="h">Export </span>
							<span id="%3Aexport" class="t">:export</span> <span id="%3Aexp" class="t">:exp</span>
Exporting an item can be written as: 
<span class="e">	export const EXPORTED_CONST = 1234</span>
<span class="e">	export var someValue = ...</span>
<span class="e">	export final someValue = ...</span>
<span class="e">	export const someValue = ...</span>
<span class="e">	export def MyFunc() ...</span>
<span class="e">	export class MyClass ...</span>
<span class="e">	export interface MyClass ...</span>
<span class="e">	export enum MyEnum ...</span>
							<span id="E1043" class="t">E1043</span> <span id="E1044" class="t">E1044</span>
As this suggests, only constants, variables, <span class="e">:def</span> functions, classes,
interfaces and enums can be exported.

							<span id="E1042" class="t">E1042</span>
<span class="e">:export</span> can only be used in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level.


<span class="h">Import </span>
				<span id="%3Aimport" class="t">:import</span> <span id="%3Aimp" class="t">:imp</span> <span id="E1094" class="t">E1094</span> <span id="E1047" class="t">E1047</span> <span id="E1262" class="t">E1262</span>
				<span id="E1048" class="t">E1048</span> <span id="E1049" class="t">E1049</span> <span id="E1053" class="t">E1053</span> <span id="E1071" class="t">E1071</span> <span id="E1088" class="t">E1088</span> <span id="E1236" class="t">E1236</span>
The exported items can be imported in another script.  The import <a href="syntax.txt.html#syntax" class="d">syntax</a> has
two forms.  The simple form: 
<span class="e">	import {filename}</span>

Where <span class="s">{filename}</span> <a href="motion.txt.html#is" class="d">is</a> an <a href="eval.txt.html#expression" class="d">expression</a> that <a href="vim_faq.txt.html#must" class="d">must</a> evaluate to <a href="insert.txt.html#a" class="d">a</a> string.  In this
form the filename should <a href="intro.txt.html#end" class="d">end</a> in ".vim" and the portion before ".vim" will
become the <a href="usr_41.txt.html#script" class="d">script</a> local name of the namespace.  For example: 
<span class="e">	import "myscript.vim"</span>

This makes each exported item in "myscript.vim" available <a href="motion.txt.html#as" class="d">as</a> "myscript.item"<a href="repeat.txt.html#." class="d">.</a>
						<span id="%3Aimport-as" class="t">:import-as</span> <span id="E1257" class="t">E1257</span> <span id="E1261" class="t">E1261</span>
In <a href="change.txt.html#case" class="d">case</a> the name <a href="motion.txt.html#is" class="d">is</a> long or ambiguous, this form can be used to specify
another name: 
<span class="e">	import {longfilename} as {name}</span>

In this form <span class="s">{name}</span> becomes <a href="insert.txt.html#a" class="d">a</a> specific <a href="usr_41.txt.html#script" class="d">script</a> local name for the imported
namespace.  Therefore <span class="s">{name}</span> <a href="vim_faq.txt.html#must" class="d">must</a> consist of letters, digits and '_', like
<a href="eval.txt.html#internal-variables" class="l">internal-variables</a><a href="repeat.txt.html#." class="d">.</a>  The <span class="s">{longfilename}</span> <a href="eval.txt.html#expression" class="d">expression</a> <a href="vim_faq.txt.html#must" class="d">must</a> evaluate to any
filename.  For example: 
<span class="e">	import "thatscript.vim.v2" as that</span>
						<span id="E1060" class="t">E1060</span> <span id="E1258" class="t">E1258</span> <span id="E1259" class="t">E1259</span> <span id="E1260" class="t">E1260</span>
Then you can use "that.item"<a href="motion.txt.html#%2C" class="d">,</a> etc.  You are free to choose the name "that"<a href="repeat.txt.html#." class="d">.</a>
Use something that will be recognized <a href="motion.txt.html#as" class="d">as</a> referring to the imported script.
Avoid command names, command modifiers and builtin function names, because the
name will shadow them.  It's better not to start the name with <a href="insert.txt.html#a" class="d">a</a> capital
letter, since <a href="motion.txt.html#it" class="d">it</a> can then also shadow global user commands and functions.
Also, you cannot use the name for something else in the script, such <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a>
function or variable name.

In <a href="change.txt.html#case" class="d">case</a> the dot in the name <a href="motion.txt.html#is" class="d">is</a> undesired, <a href="insert.txt.html#a" class="d">a</a> local <a href="intro.txt.html#reference" class="d">reference</a> can be made for <a href="insert.txt.html#a" class="d">a</a>
function: 
<span class="e">	var LongFunc = that.LongFuncName</span>
<span class="e"></span>
This also works for constants: 
<span class="e">	const MAXLEN = that.MAX_LEN_OF_NAME</span>
<span class="e"></span>
This does not work for variables, since the value would be copied once and
when <a href="change.txt.html#changing" class="d">changing</a> the variable the copy will change, not the original variable.
You will need to use the full name, with the dot.

<span class="e">:import</span> can not be used in <a href="insert.txt.html#a" class="d">a</a> function.  Imported items are intended to exist
<a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level and only imported once.

The <a href="usr_41.txt.html#script" class="d">script</a> name after <span class="e">import</span> can be:
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#A" class="d">A</a> relative path, <a href="starting.txt.html#starting" class="d">starting</a> "<a href="repeat.txt.html#." class="d">.</a>" or ".."<a href="repeat.txt.html#." class="d">.</a>  This finds <a href="insert.txt.html#a" class="d">a</a> file relative to the
  location of the <a href="usr_41.txt.html#script" class="d">script</a> file itself.  This <a href="motion.txt.html#is" class="d">is</a> useful to split up <a href="insert.txt.html#a" class="d">a</a> large
  <a href="usr_05.txt.html#plugin" class="d">plugin</a> into several files.
<a href="motion.txt.html#-" class="d">-</a> An absolute path, <a href="starting.txt.html#starting" class="d">starting</a> with "<a href="pattern.txt.html#%2F" class="d">/</a>" on <a href="os_unix.txt.html#Unix" class="d">Unix</a> or "D:/" on MS-Windows.  This
  will rarely be used.
<a href="motion.txt.html#-" class="d">-</a> <a href="insert.txt.html#A" class="d">A</a> path not being relative or absolute.  This will be found in the
  "import" subdirectories of <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> entries.  The name will usually be
  longer and unique, to avoid loading the wrong file.
  <span class="n">Note</span> that "after/import" <a href="motion.txt.html#is" class="d">is</a> not used.

If the name does not <a href="intro.txt.html#end" class="d">end</a> in ".vim" then the use of "<a href="motion.txt.html#as" class="d">as</a> name" <a href="motion.txt.html#is" class="d">is</a> required.

Once <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> file has been imported, the result <a href="motion.txt.html#is" class="d">is</a> cached and used the
next time the same <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> imported.  It will not be read again.

It <a href="motion.txt.html#is" class="d">is</a> not allowed to import the same <a href="usr_41.txt.html#script" class="d">script</a> twice, also when using two
different "<a href="motion.txt.html#as" class="d">as</a>" names.

When using the imported name the dot and the item name <a href="vim_faq.txt.html#must" class="d">must</a> be in the same
line, there can be no line break: 
<span class="e">	echo that.</span>
<span class="e">		name   # Error!</span>
<span class="e">	echo that</span>
<span class="e">		.name  # Error!</span>
						<span id="import-map" class="t">import-map</span>
When you've imported <a href="insert.txt.html#a" class="d">a</a> function from one <a href="usr_41.txt.html#script" class="d">script</a> into <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> you can
refer to the imported function in <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#mapping" class="d">mapping</a> by prefixing <a href="motion.txt.html#it" class="d">it</a> with <a href="map.txt.html#%3CSID%3E" class="l">&lt;SID&gt;</a><a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	noremap &lt;silent&gt; ,a :call &lt;SID&gt;name.Function()&lt;CR&gt;</span>
<span class="e"></span>
When the <a href="map.txt.html#mapping" class="d">mapping</a> <a href="motion.txt.html#is" class="d">is</a> defined "<a href="map.txt.html#%3CSID%3E" class="s">&lt;SID&gt;</a>name." will be replaced with <a href="map.txt.html#%3CSNR%3E" class="s">&lt;SNR&gt;</a> and the
<a href="usr_41.txt.html#script" class="d">script</a> ID of the imported script.
An even simpler solution <a href="motion.txt.html#is" class="d">is</a> using <a href="map.txt.html#%3CScriptCmd%3E" class="l">&lt;ScriptCmd&gt;</a><a href="cmdline.txt.html#%3A" class="d">:</a> 
<span class="e">	noremap ,a &lt;ScriptCmd&gt;name.Function()&lt;CR&gt;</span>
<span class="e"></span>
<span class="n">Note</span> that this does not work for variables, only for functions.

					    <span id="import-legacy" class="t">import-legacy</span> <span id="legacy-import" class="t">legacy-import</span>
<span class="e">:import</span> can also be used in legacy Vim script.  The imported namespace still
becomes script-local, even when the "s:" prefix <a href="motion.txt.html#is" class="d">is</a> not given.  For example: 
<span class="e">	import "myfile.vim"</span>
<span class="e">	call s:myfile.MyFunc()</span>
<span class="e"></span>
And using the "<a href="motion.txt.html#as" class="d">as</a> name" form: 
<span class="e">	import "otherfile.vim9script" as that</span>
<span class="e">	call s:that.OtherFunc()</span>
<span class="e"></span>
However, the namespace cannot be resolved on its own: 
<span class="e">	import "that.vim"</span>
<span class="e">	echo s:that</span>
<span class="e">	" ERROR: E1060: Expected dot after name: s:that</span>

This also affects the use of <a href="map.txt.html#%3CSID%3E" class="l">&lt;SID&gt;</a> in the legacy <a href="map.txt.html#mapping" class="d">mapping</a> context.  Since
<a href="map.txt.html#%3CSID%3E" class="l">&lt;SID&gt;</a> <a href="motion.txt.html#is" class="d">is</a> only <a href="insert.txt.html#a" class="d">a</a> valid prefix for <a href="insert.txt.html#a" class="d">a</a> function and NOT for <a href="insert.txt.html#a" class="d">a</a> namespace, you
cannot use <a href="motion.txt.html#it" class="d">it</a> to scope <a href="insert.txt.html#a" class="d">a</a> function in <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> local namespace.  Instead of
prefixing the function with <a href="map.txt.html#%3CSID%3E" class="l">&lt;SID&gt;</a> you should use <a href="map.txt.html#%3CScriptCmd%3E" class="l">&lt;ScriptCmd&gt;</a><a href="repeat.txt.html#." class="d">.</a>  For example:

<span class="e">	noremap ,a &lt;ScriptCmd&gt;:call s:that.OtherFunc()&lt;CR&gt;</span>

							<span id="%3Aimport-cycle" class="t">:import-cycle</span>
The <span class="e">import</span> commands are executed when encountered.  If <a href="usr_41.txt.html#script" class="d">script</a> <a href="insert.txt.html#A" class="d">A</a> imports
<a href="usr_41.txt.html#script" class="d">script</a> B, and <a href="motion.txt.html#B" class="d">B</a> (directly or indirectly) imports A, this will be skipped over.
At this point items in <a href="insert.txt.html#A" class="d">A</a> after "import <a href="motion.txt.html#B" class="d">B</a>" will not have been processed and
defined yet.  Therefore cyclic imports can exist and not result in an error
directly, but may result in an error for items in <a href="insert.txt.html#A" class="d">A</a> after "import <a href="motion.txt.html#B" class="d">B</a>" not being
defined.  This does not apply to <a href="userfunc.txt.html#autoload" class="d">autoload</a> imports, see the next section.


<span class="h">Importing an autoload script </span>
					<span id="vim9-autoload" class="t">vim9-autoload</span> <span id="import-autoload" class="t">import-autoload</span>
For optimal <a href="starting.txt.html#startup" class="d">startup</a> speed, loading scripts should be postponed until they are
actually needed.  Using the <a href="userfunc.txt.html#autoload" class="d">autoload</a> mechanism <a href="motion.txt.html#is" class="d">is</a> recommended:
							<span id="E1264" class="t">E1264</span>
     1. In the plugin, define user commands, <a href="eval.txt.html#functions" class="d">functions</a> and/or mappings
        referring to items imported from an <a href="userfunc.txt.html#autoload" class="d">autoload</a> script. 
<span class="e"></span>
<span class="e">	import autoload 'for/search.vim'</span>
<span class="e">	command -nargs=1 SearchForStuff search.Stuff(&lt;f-args&gt;)</span>
<span class="e"></span>
        This goes in .../plugin/anyname.vim.  "anyname.vim" can be freely
        chosen.  The "SearchForStuff" command <a href="motion.txt.html#is" class="d">is</a> now available to the user.

        The "<a href="userfunc.txt.html#autoload" class="d">autoload</a>" argument to <span class="e">:import</span> means that the <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> not
        loaded until one of the items <a href="motion.txt.html#is" class="d">is</a> actually used.  The <a href="usr_41.txt.html#script" class="d">script</a> will be
        found under the "<a href="userfunc.txt.html#autoload" class="d">autoload</a>" directory in <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> instead of the
        "import" directory.  Alternatively, either <a href="insert.txt.html#a" class="d">a</a> relative or absolute
        name can be used <a href="motion.txt.html#-" class="d">-</a> see below.

     2. In the <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="change.txt.html#put" class="d">put</a> the bulk of the code. 
<span class="e"></span>
<span class="e">	vim9script</span>
<span class="e">	export def Stuff(arg: string): void</span>
<span class="e">	  ...</span>
<span class="e"></span>
       This goes in .../autoload/for/search.vim.

       Putting the "search.vim" <a href="usr_41.txt.html#script" class="d">script</a> under the "/autoload/for/" directory
       has the effect that "for#search#" will be prefixed to every exported
       item.  The prefix <a href="motion.txt.html#is" class="d">is</a> obtained from the file name, just <a href="motion.txt.html#as" class="d">as</a> you would
       add <a href="motion.txt.html#it" class="d">it</a> manually in <a href="insert.txt.html#a" class="d">a</a> legacy <a href="userfunc.txt.html#autoload" class="d">autoload</a> script.  Thus the exported
       function can be found with "for#search#Stuff"<a href="motion.txt.html#%2C" class="d">,</a> but you would normally
       use `import autoload` and not use the prefix (which has the side effect
       of loading the <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> when compiling <a href="insert.txt.html#a" class="d">a</a> function that
       encounters this name).

       You can split up the functionality and import other scripts from the
       <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#as" class="d">as</a> you like.  This way you can share code between
       plugins.

Searching for the <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> in all entries in <a href="options.txt.html#%27runtimepath%27" class="o">'runtimepath'</a> can be <a href="insert.txt.html#a" class="d">a</a> bit
slow.  If the <a href="usr_05.txt.html#plugin" class="d">plugin</a> knows where the <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> located, quite often <a href="insert.txt.html#a" class="d">a</a> relative
path can be used.  This avoids the search and should be quite <a href="insert.txt.html#a" class="d">a</a> bit faster.
Another advantage <a href="motion.txt.html#is" class="d">is</a> that the <a href="usr_41.txt.html#script" class="d">script</a> name does not need to be unique.  Also,
an absolute path <a href="motion.txt.html#is" class="d">is</a> possible.  Examples: 
<span class="e">	import autoload '../lib/implement.vim'</span>
<span class="e">	import autoload MyScriptsDir .. '/lib/implement.vim'</span>
<span class="e"></span>
For defining <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#mapping" class="d">mapping</a> that uses the imported <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> the special key
<a href="map.txt.html#%3CScriptCmd%3E" class="l">&lt;ScriptCmd&gt;</a> <a href="motion.txt.html#is" class="d">is</a> useful.  It allows for <a href="insert.txt.html#a" class="d">a</a> command in <a href="insert.txt.html#a" class="d">a</a> <a href="map.txt.html#mapping" class="d">mapping</a> to use the
<a href="usr_41.txt.html#script" class="d">script</a> context of where the <a href="map.txt.html#mapping" class="d">mapping</a> was defined.

When compiling <a href="insert.txt.html#a" class="d">a</a> <span class="e">:def</span> function and <a href="insert.txt.html#a" class="d">a</a> function in an <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a>
encountered, the <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> not loaded until the <span class="e">:def</span> function <a href="motion.txt.html#is" class="d">is</a> called.
This also means you get any <a href="message.txt.html#errors" class="d">errors</a> only <a href="motion.txt.html#at" class="d">at</a> runtime, since the argument and
return types are not known yet.  If you would use the name with '#' characters
then the <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> IS loaded.

Be careful to not refer to an item in an <a href="userfunc.txt.html#autoload" class="d">autoload</a> <a href="usr_41.txt.html#script" class="d">script</a> that does trigger
loading <a href="motion.txt.html#it" class="d">it</a> unintentionally.  For example, when setting an option that takes <a href="insert.txt.html#a" class="d">a</a>
function name, make sure to use <a href="insert.txt.html#a" class="d">a</a> string, not <a href="insert.txt.html#a" class="d">a</a> function reference: 
<span class="e">	import autoload 'qftf.vim'</span>
<span class="e">	&amp;quickfixtextfunc = 'qftf.Func'  # autoload script NOT loaded</span>
<span class="e">	&amp;quickfixtextfunc = qftf.Func    # autoload script IS loaded</span>
On the other hand, <a href="motion.txt.html#it" class="d">it</a> can be useful to load the <a href="usr_41.txt.html#script" class="d">script</a> early, <a href="motion.txt.html#at" class="d">at</a> <a href="insert.txt.html#a" class="d">a</a> time when
any <a href="message.txt.html#errors" class="d">errors</a> should be given.

For <a href="testing.txt.html#testing" class="d">testing</a> the <a href="testing.txt.html#test_override%28%29" class="l">test_override()</a> function can be used to have the
`import autoload` load the <a href="usr_41.txt.html#script" class="d">script</a> right away, so that the items and types can
be checked without waiting for them to be actually used: 
<span class="e">	test_override('autoload', 1)</span>
Reset <a href="motion.txt.html#it" class="d">it</a> later with: 
<span class="e">	test_override('autoload', 0)</span>
Or: 
<span class="e">	test_override('ALL', 0)</span>
<span class="e"></span>
<span class="e"></span>
<span class="h">==============================================================================</span>

7. Classes and interfaces				<span id="vim9-classes" class="t">vim9-classes</span>

In legacy Vim script, <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#Dictionary" class="d">Dictionary</a> could be used <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> kind-of <a href="vim9class.txt.html#object" class="d">object</a> by adding
members that are functions.  However, this <a href="motion.txt.html#is" class="d">is</a> quite inefficient and requires
the writer to <a href="diff.txt.html#do" class="d">do</a> the work of making sure all the <a href="index.txt.html#objects" class="d">objects</a> have the right
members.  See <a href="eval.txt.html#Dictionary-function" class="l">Dictionary-function</a><a href="repeat.txt.html#." class="d">.</a>

In <a href="vim9.txt.html#Vim9" class="l">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> you can have classes, objects, interfaces, and enums like
in most popular object-oriented programming languages.  Since this <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> lot
of functionality, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> located in <a href="insert.txt.html#a" class="d">a</a> separate <a href="helphelp.txt.html#help" class="d">help</a> file: <a href="vim9class.txt.html#vim9class.txt" class="l">vim9class.txt</a><a href="repeat.txt.html#." class="d">.</a>


<span class="h">==============================================================================</span>

8. Rationale						<span id="vim9-rationale" class="t">vim9-rationale</span>

<span class="h">The :def command </span>

Plugin writers have asked for much faster Vim script.  Investigations have
shown that keeping the existing semantics of function calls make this close to
impossible, because of the overhead involved with calling <a href="insert.txt.html#a" class="d">a</a> function, setting
up the local function scope and executing lines.  There are many details that
need to be handled, such <a href="motion.txt.html#as" class="d">as</a> error <a href="message.txt.html#messages" class="d">messages</a> and exceptions.  The need to create
<a href="insert.txt.html#a" class="d">a</a> dictionary for a: and <a href="eval.txt.html#l%3A" class="d">l:</a> scopes, the <a href="userfunc.txt.html#a%3A000" class="d">a:000</a> <a href="eval.txt.html#list" class="d">list</a> and several others add too
much overhead that cannot be avoided.

Therefore the <span class="e">:def</span> <a href="eval.txt.html#method" class="d">method</a> to define <a href="insert.txt.html#a" class="d">a</a> new-style function had to be added,
which allows for <a href="insert.txt.html#a" class="d">a</a> function with different semantics.  Most things still work
<a href="motion.txt.html#as" class="d">as</a> before, but some parts <a href="diff.txt.html#do" class="d">do</a> not.  <a href="insert.txt.html#A" class="d">A</a> new way to define <a href="insert.txt.html#a" class="d">a</a> function was
considered the best way to separate the legacy style code from <a href="vim9.txt.html#Vim9" class="d">Vim9</a> style
code.

Using "def" to define <a href="insert.txt.html#a" class="d">a</a> function comes from Python.  Other languages use
"function" which clashes with legacy Vim script.


<span class="h">Type checking </span>

When compiling lines of Vim commands into instructions <a href="motion.txt.html#as" class="d">as</a> much <a href="motion.txt.html#as" class="d">as</a> possible
should be done <a href="motion.txt.html#at" class="d">at</a> compile time.  Postponing <a href="motion.txt.html#it" class="d">it</a> to runtime makes the execution
slower and means mistakes are found only later.  For example, when
encountering the "<a href="motion.txt.html#%2B" class="d">+</a>" character and compiling this into <a href="insert.txt.html#a" class="d">a</a> generic add
instruction, <a href="motion.txt.html#at" class="d">at</a> runtime the instruction would have to inspect the type of the
arguments and decide what kind of addition to do.  And when the type <a href="motion.txt.html#is" class="d">is</a>
dictionary throw an error.  If the types are known to be numbers then an "add
number" instruction can be used, which <a href="motion.txt.html#is" class="d">is</a> faster.  The error can be given <a href="motion.txt.html#at" class="d">at</a>
compile time, no error handling <a href="motion.txt.html#is" class="d">is</a> needed <a href="motion.txt.html#at" class="d">at</a> runtime, since adding two numbers
almost never fails.

    <span class="n">NOTE:</span> As <a href="insert.txt.html#a" class="d">a</a> tangential point, the exception <a href="motion.txt.html#is" class="d">is</a> integer overflow, where the
    result exceeds the maximum integer value.  For example, adding to <a href="insert.txt.html#a" class="d">a</a> 64-bit
    signed integer where the result <a href="motion.txt.html#is" class="d">is</a> greater than 2^63: &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	echo 9223372036854775807 <a href="motion.txt.html#%2B" class="d">+</a> 1     <a href="pattern.txt.html#%23" class="d">#</a> -9223372036854775808
	echo 2-&gt;pow(63)-&gt;float2nr() <a href="motion.txt.html#%2B" class="d">+</a> 1  <a href="pattern.txt.html#%23" class="d">#</a> -9223372036854775808
<a href="change.txt.html#%3C" class="d">&lt;</a>
The <a href="syntax.txt.html#syntax" class="d">syntax</a> for types, using <span class="s">&lt;type&gt;</span> for compound types, <a href="motion.txt.html#is" class="d">is</a> similar to Java.
It <a href="motion.txt.html#is" class="d">is</a> <a href="starting.txt.html#easy" class="d">easy</a> to understand and widely used.  The type names are what were used
in Vim before, with some additions such <a href="motion.txt.html#as" class="d">as</a> "void" and "bool"<a href="repeat.txt.html#." class="d">.</a>


<span class="h">Removing clutter and weirdness </span>

Once decided that <span class="e">:def</span> <a href="eval.txt.html#functions" class="d">functions</a> have different <a href="syntax.txt.html#syntax" class="d">syntax</a> than legacy functions,
we are free to add improvements to make the code more familiar for users who
know popular programming languages.  In other words: remove weird things that
only Vim does.

We can also remove clutter, mainly things that were done to make Vim <a href="usr_41.txt.html#script" class="d">script</a>
backwards compatible with the good old <a href="intro.txt.html#Vi" class="d">Vi</a> commands.

Examples:
<a href="motion.txt.html#-" class="d">-</a> Drop <span class="e">:call</span> for calling <a href="insert.txt.html#a" class="d">a</a> function and <span class="e">:eval</span> for evaluating an
  expression.
<a href="motion.txt.html#-" class="d">-</a> Drop using <a href="insert.txt.html#a" class="d">a</a> leading <a href="intro.txt.html#backslash" class="d">backslash</a> for line continuation, automatically figure
  out where an <a href="eval.txt.html#expression" class="d">expression</a> ends.

However, this does require that some things need to change:
<a href="motion.txt.html#-" class="d">-</a> Comments start with <a href="pattern.txt.html#%23" class="d">#</a> instead of "<a href="motion.txt.html#%2C" class="d">,</a> to avoid confusing them with strings.
  This <a href="motion.txt.html#is" class="d">is</a> good anyway, <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#is" class="d">is</a> also used by several popular languages.
<a href="motion.txt.html#-" class="d">-</a> <a href="intro.txt.html#Ex" class="d">Ex</a> command ranges need to be prefixed with <a href="insert.txt.html#a" class="d">a</a> colon, to avoid confusion with
  expressions (single <a href="change.txt.html#quote" class="d">quote</a> can be <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> or <a href="insert.txt.html#a" class="d">a</a> mark, "<a href="pattern.txt.html#%2F" class="d">/</a>" can be divide or <a href="insert.txt.html#a" class="d">a</a>
  search command, etc.).

Goal <a href="motion.txt.html#is" class="d">is</a> to limit the differences.  <a href="insert.txt.html#A" class="d">A</a> good criteria <a href="motion.txt.html#is" class="d">is</a> that when the old <a href="syntax.txt.html#syntax" class="d">syntax</a>
<a href="motion.txt.html#is" class="d">is</a> accidentally used you are very likely to get an error message.


<span class="h">Syntax and semantics from popular languages </span>

Script writers have complained that the Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="syntax.txt.html#syntax" class="d">syntax</a> <a href="motion.txt.html#is" class="d">is</a> unexpectedly
different from what they are used to.  To reduce this complaint popular
languages are used <a href="motion.txt.html#as" class="d">as</a> an example.  At the same time, we <a href="diff.txt.html#do" class="d">do</a> not want to <a href="editing.txt.html#abandon" class="d">abandon</a>
the well-known parts of legacy Vim script.

For many things TypeScript <a href="motion.txt.html#is" class="d">is</a> followed.  It's <a href="insert.txt.html#a" class="d">a</a> recent language that <a href="motion.txt.html#is" class="d">is</a>
gaining popularity and has similarities with Vim script.  It also has <a href="insert.txt.html#a" class="d">a</a>
mix of static typing (a variable always has <a href="insert.txt.html#a" class="d">a</a> known value type) and dynamic
typing (a variable can have different types, this changes <a href="motion.txt.html#at" class="d">at</a> runtime).  Since
legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> dynamically typed and <a href="insert.txt.html#a" class="d">a</a> lot of existing functionality
(esp. builtin functions) depends on that, while static typing allows for much
faster execution, we need to have this mix in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script.

There <a href="motion.txt.html#is" class="d">is</a> no intention to completely match TypeScript <a href="syntax.txt.html#syntax" class="d">syntax</a> and semantics.  We
just want to take those parts that we can use for Vim and we expect Vim users
will be happy with.  TypeScript <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> complex language with its own history,
advantages and disadvantages.  To get an idea of the disadvantages read the
book: "JavaScript: The Good Parts"<a href="repeat.txt.html#." class="d">.</a>  Or find the article "TypeScript: the good
parts" and read the "Things to avoid" section.

People familiar with other languages (Java, Python, etc.) will also find
things in TypeScript that they <a href="diff.txt.html#do" class="d">do</a> not like or <a href="diff.txt.html#do" class="d">do</a> not understand.  We'll try to
avoid those things.

Specific items from TypeScript we avoid:
<a href="motion.txt.html#-" class="d">-</a> Overloading "<a href="motion.txt.html#%2B" class="d">+</a>"<a href="motion.txt.html#%2C" class="d">,</a> using <a href="motion.txt.html#it" class="d">it</a> both for addition and <a href="eval.txt.html#string" class="d">string</a> concatenation.  This
  goes against legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> and often leads to mistakes.  For that reason
  we will keep using ".." for <a href="eval.txt.html#string" class="d">string</a> concatenation.  <a href="if_lua.txt.html#Lua" class="d">Lua</a> also uses ".." this
  way.  And <a href="motion.txt.html#it" class="d">it</a> allows for conversion to <a href="eval.txt.html#string" class="d">string</a> for more values.
<a href="motion.txt.html#-" class="d">-</a> TypeScript can use an <a href="eval.txt.html#expression" class="d">expression</a> like "99 || <span class="o">'yes'</span>" in <a href="insert.txt.html#a" class="d">a</a> condition, but
  cannot assign the value to <a href="insert.txt.html#a" class="d">a</a> boolean.  That <a href="motion.txt.html#is" class="d">is</a> inconsistent and can be
  annoying.  Vim recognizes an <a href="eval.txt.html#expression" class="d">expression</a> with &amp;&amp; or || and allows using the
  result <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> bool.  The <a href="eval.txt.html#falsy-operator" class="l">falsy-operator</a> was added for the mechanism to use <a href="insert.txt.html#a" class="d">a</a>
  default value.
<a href="motion.txt.html#-" class="d">-</a> TypeScript considers an empty <a href="eval.txt.html#string" class="d">string</a> <a href="motion.txt.html#as" class="d">as</a> Falsy, but an empty <a href="eval.txt.html#list" class="d">list</a> or <a href="eval.txt.html#dict" class="d">dict</a> <a href="motion.txt.html#as" class="d">as</a>
  Truthy.  That <a href="motion.txt.html#is" class="d">is</a> inconsistent.  In Vim an empty <a href="eval.txt.html#list" class="d">list</a> and <a href="eval.txt.html#dict" class="d">dict</a> are also
  Falsy.
<a href="motion.txt.html#-" class="d">-</a> TypeScript has <a href="various.txt.html#various" class="d">various</a> "Readonly" types, which have limited usefulness,
  since <a href="insert.txt.html#a" class="d">a</a> type cast can remove the immutable nature.  Vim locks the value,
  which <a href="motion.txt.html#is" class="d">is</a> more flexible, but <a href="motion.txt.html#is" class="d">is</a> only checked <a href="motion.txt.html#at" class="d">at</a> runtime.
<a href="motion.txt.html#-" class="d">-</a> TypeScript has <a href="insert.txt.html#a" class="d">a</a> complicated "import" statement that does not match how the
  Vim import mechanism works.  <a href="insert.txt.html#A" class="d">A</a> much simpler mechanism <a href="motion.txt.html#is" class="d">is</a> used instead, which
  matches that the imported <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> only sourced once.


<span class="h">Declarations </span>

Legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> uses <span class="e">:let</span> for every assignment, while in <a href="vim9.txt.html#Vim9" class="d">Vim9</a> declarations
are used.  That <a href="motion.txt.html#is" class="d">is</a> different, thus it's good to use <a href="insert.txt.html#a" class="d">a</a> different command:
<span class="e">:var</span>.  This <a href="motion.txt.html#is" class="d">is</a> used in many languages.  The semantics might be slightly
different, but it's easily recognized <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> declaration.

Using <span class="e">:const</span>  for constants <a href="motion.txt.html#is" class="d">is</a> common, but the semantics varies.  Some
languages only make the variable immutable, others also make the value
immutable.  Since "final" <a href="motion.txt.html#is" class="d">is</a> well known from Java for only making the variable
immutable we decided to use that.  And then <span class="e">:const</span> can be used for making
both immutable.  This was also used in legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> and the meaning <a href="motion.txt.html#is" class="d">is</a>
almost the same.

What we <a href="intro.txt.html#end" class="d">end</a> up with <a href="motion.txt.html#is" class="d">is</a> very similar to Dart: 
<span class="e">	:var name	# mutable variable and value</span>
<span class="e">	:final name	# immutable variable, mutable value</span>
<span class="e">	:const name	# immutable variable and value</span>
<span class="e"></span>
Since legacy and <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> will be mixed and global <a href="eval.txt.html#variables" class="d">variables</a> will be
shared, optional type checking <a href="motion.txt.html#is" class="d">is</a> desirable.  Also, type inference will avoid
the need for specifying the type in many cases.  The TypeScript <a href="syntax.txt.html#syntax" class="d">syntax</a> fits
best for adding types to declarations: 
<span class="e">	var name: string	  # string type is specified</span>
<span class="e">	...</span>
<span class="e">	name = 'John'</span>
<span class="e">	const greeting = 'hello'  # string type is inferred</span>
<span class="e"></span>
This <a href="motion.txt.html#is" class="d">is</a> how we <a href="change.txt.html#put" class="d">put</a> types in <a href="insert.txt.html#a" class="d">a</a> declaration: 
<span class="e">	var mylist: list&lt;string&gt;</span>
<span class="e">	final mylist: list&lt;string&gt; = ['foo']</span>
<span class="e">	def Func(arg1: number, arg2: string): bool</span>
<span class="e"></span>
Two alternatives were considered:
    1. Put the type before the name, like Dart: 
<span class="e">	var list&lt;string&gt; mylist</span>
<span class="e">	final list&lt;string&gt; mylist = ['foo']</span>
<span class="e">	def Func(number arg1, string arg2) bool</span>
    2. Put the type after the variable name, but <a href="diff.txt.html#do" class="d">do</a> not use <a href="insert.txt.html#a" class="d">a</a> colon, like Go: 
<span class="e">	var mylist list&lt;string&gt;</span>
<span class="e">	final mylist list&lt;string&gt; = ['foo']</span>
<span class="e">	def Func(arg1 number, arg2 string) bool</span>
<span class="e"></span>
The first <a href="motion.txt.html#is" class="d">is</a> more familiar for anyone used to <a href="change.txt.html#C" class="d">C</a> or Java.  The second one
doesn't really have an advantage over the first, so let's <a href="editing.txt.html#discard" class="d">discard</a> the second.

Since we use type inference the type can be left out when <a href="motion.txt.html#it" class="d">it</a> can be inferred
from the value.  This means that after <span class="e">var</span> we don't know if <a href="insert.txt.html#a" class="d">a</a> type or <a href="insert.txt.html#a" class="d">a</a> name
follows.  That makes parsing harder, not only for Vim but also for humans.
Also, <a href="motion.txt.html#it" class="d">it</a> will not be allowed to use <a href="insert.txt.html#a" class="d">a</a> variable name that could be <a href="insert.txt.html#a" class="d">a</a> type name,
using `var <a href="eval.txt.html#string" class="d">string</a> string` <a href="motion.txt.html#is" class="d">is</a> too confusing.

The chosen syntax, using <a href="insert.txt.html#a" class="d">a</a> colon to separate the name from the type, adds
punctuation, but <a href="motion.txt.html#it" class="d">it</a> actually makes <a href="motion.txt.html#it" class="d">it</a> easier to recognize the parts of <a href="insert.txt.html#a" class="d">a</a>
declaration.


<span class="h">Expressions </span>

Expression evaluation was already close to what other languages are doing.
Some details are unexpected and can be improved.  For example <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#boolean" class="d">boolean</a>
condition would accept <a href="insert.txt.html#a" class="d">a</a> string, convert <a href="motion.txt.html#it" class="d">it</a> to <a href="insert.txt.html#a" class="d">a</a> number and check if the
number <a href="motion.txt.html#is" class="d">is</a> non-zero.  This <a href="motion.txt.html#is" class="d">is</a> unexpected and often leads to mistakes, since
text not <a href="starting.txt.html#starting" class="d">starting</a> with <a href="insert.txt.html#a" class="d">a</a> number would be converted to zero, which <a href="motion.txt.html#is" class="d">is</a>
considered false.  Thus using <a href="insert.txt.html#a" class="d">a</a> <a href="eval.txt.html#string" class="d">string</a> for <a href="insert.txt.html#a" class="d">a</a> condition would often not give an
error and be considered false.  That <a href="motion.txt.html#is" class="d">is</a> confusing.

In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> type checking <a href="motion.txt.html#is" class="d">is</a> stricter to avoid mistakes.  Where <a href="insert.txt.html#a" class="d">a</a> condition <a href="motion.txt.html#is" class="d">is</a>
used, e.g. with the <span class="e">:if</span> command and the <span class="e">||</span> operator, only boolean-like
values are accepted:
	true:  <span class="e">true</span>, <span class="e">v:true</span>, <span class="e">1</span>, <a href="motion.txt.html#%600" class="d">`0</a> <a href="change.txt.html#%3C" class="d">&lt;</a> 9`
	false: <span class="e">false</span>, <span class="e">v:false</span>, <span class="e">0</span>, <a href="motion.txt.html#%600" class="d">`0</a> <a href="change.txt.html#%3E" class="d">&gt;</a> 9`
<span class="n">Note</span> that the number zero <a href="motion.txt.html#is" class="d">is</a> <a href="vim9.txt.html#false" class="d">false</a> and the number one <a href="motion.txt.html#is" class="d">is</a> true.  This <a href="motion.txt.html#is" class="d">is</a> more
permissive than most other languages.  It was done because many builtin
<a href="eval.txt.html#functions" class="d">functions</a> return these values, and <a href="change.txt.html#changing" class="d">changing</a> that causes more problems than <a href="motion.txt.html#it" class="d">it</a>
solves.  After using this for <a href="insert.txt.html#a" class="d">a</a> while <a href="motion.txt.html#it" class="d">it</a> turned out to work well.

If you have any type of value and want to use <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#as" class="d">as</a> <a href="insert.txt.html#a" class="d">a</a> boolean, use the <span class="e">!!</span>
<a href="motion.txt.html#operator" class="d">operator</a> (see <a href="eval.txt.html#expr-%21" class="l">expr-!</a>): &gt;vim9

	<a href="vim9.txt.html#vim9script" class="d">vim9script</a>
	<a href="pattern.txt.html#%23" class="d">#</a> The following are all true:
	echo [!!'text', !![1], !!{'x': 1}, !!1, !!1.1]
	<a href="pattern.txt.html#%23" class="d">#</a> And these are all false:
	echo [!!'', !![], !!{}, !!0, !!0.0]
<a href="change.txt.html#%3C" class="d">&lt;</a>
From <a href="insert.txt.html#a" class="d">a</a> language like JavaScript we have this handy construct: 
<span class="e">	GetName() || 'unknown'</span>
However, this conflicts with only allowing <a href="insert.txt.html#a" class="d">a</a> <a href="options.txt.html#boolean" class="d">boolean</a> for <a href="insert.txt.html#a" class="d">a</a> condition.
Therefore the "<a href="eval.txt.html#%3F%3F" class="d">??</a>" <a href="motion.txt.html#operator" class="d">operator</a> was added: 
<span class="e">	GetName() ?? 'unknown'</span>
Here you can explicitly express your intention to use the value as-is and not
result in <a href="insert.txt.html#a" class="d">a</a> boolean.  This <a href="motion.txt.html#is" class="d">is</a> called the <a href="eval.txt.html#falsy-operator" class="l">falsy-operator</a><a href="repeat.txt.html#." class="d">.</a>


<span class="h">Import and Export </span>

<a href="insert.txt.html#A" class="d">A</a> problem of legacy Vim <a href="usr_41.txt.html#script" class="d">script</a> <a href="motion.txt.html#is" class="d">is</a> that by default all <a href="eval.txt.html#functions" class="d">functions</a> and <a href="eval.txt.html#variables" class="d">variables</a>
are global.  It <a href="motion.txt.html#is" class="d">is</a> possible to make them script-local, but then they are not
available in other scripts.  This defies the concept of <a href="insert.txt.html#a" class="d">a</a> package that only
exports selected items and keeps the rest local.

In <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> <a href="insert.txt.html#a" class="d">a</a> mechanism very similar to the JavaScript import and export
mechanism <a href="motion.txt.html#is" class="d">is</a> supported.  It <a href="motion.txt.html#is" class="d">is</a> <a href="insert.txt.html#a" class="d">a</a> variant to the existing <span class="e">:source</span> command
that works like one would expect:
<a href="motion.txt.html#-" class="d">-</a> Instead of making everything global by default, everything <a href="motion.txt.html#is" class="d">is</a> script-local,
  some of these are exported.
<a href="motion.txt.html#-" class="d">-</a> When importing <a href="insert.txt.html#a" class="d">a</a> <a href="usr_41.txt.html#script" class="d">script</a> the symbols that are imported are explicitly listed,
  avoiding name conflicts and failures if functionality <a href="motion.txt.html#is" class="d">is</a> added later.
<a href="motion.txt.html#-" class="d">-</a> The mechanism allows for <a href="editing.txt.html#writing" class="d">writing</a> <a href="insert.txt.html#a" class="d">a</a> big, long <a href="usr_41.txt.html#script" class="d">script</a> with <a href="insert.txt.html#a" class="d">a</a> very clear API:
  the exported functions, <a href="eval.txt.html#variables" class="d">variables</a> and classes.
<a href="motion.txt.html#-" class="d">-</a> By using relative paths loading can be much faster for an import inside of <a href="insert.txt.html#a" class="d">a</a>
  package, no need to search many directories.
<a href="motion.txt.html#-" class="d">-</a> Once an import has been used, its items are cached and loading <a href="motion.txt.html#it" class="d">it</a> again <a href="motion.txt.html#is" class="d">is</a>
  not needed.
<a href="motion.txt.html#-" class="d">-</a> The Vim-specific use of "s:" to make things <a href="map.txt.html#script-local" class="d">script-local</a> can be dropped.

When sourcing <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> (from either <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> or legacy Vim script),
only the items defined globally can be used, not the exported items.
Alternatives considered:
<a href="motion.txt.html#-" class="d">-</a> All the exported items become available <a href="motion.txt.html#as" class="d">as</a> <a href="map.txt.html#script-local" class="d">script-local</a> items.  This makes
  <a href="motion.txt.html#it" class="d">it</a> uncontrollable what items get defined and likely soon leads to trouble.
<a href="motion.txt.html#-" class="d">-</a> Use the exported items and make them global.  Disadvantage <a href="motion.txt.html#is" class="d">is</a> that it's then
  not possible to avoid name clashes in the global namespace.
<a href="motion.txt.html#-" class="d">-</a> Completely disallow sourcing <a href="insert.txt.html#a" class="d">a</a> <a href="vim9.txt.html#Vim9" class="d">Vim9</a> script, require using <span class="e">:import</span>.  That
  makes <a href="motion.txt.html#it" class="d">it</a> difficult to use scripts for testing, or sourcing them from the
  command line to try them out.
<span class="n">Note</span> that you CAN also use <span class="e">:import</span> in legacy Vim script, see above.


<span class="h">Compiling functions early </span>

Functions are compiled when called or when <span class="e">:defcompile</span> <a href="motion.txt.html#is" class="d">is</a> used.  Why not
compile them early, so that <a href="syntax.txt.html#syntax" class="d">syntax</a> and type <a href="message.txt.html#errors" class="d">errors</a> are reported early?

The <a href="eval.txt.html#functions" class="d">functions</a> can't be compiled right away when encountered, because there may
be forward references to <a href="eval.txt.html#functions" class="d">functions</a> defined later.  Consider defining <a href="eval.txt.html#functions" class="d">functions</a>
A, <a href="motion.txt.html#B" class="d">B</a> and C, where <a href="insert.txt.html#A" class="d">A</a> calls B, <a href="motion.txt.html#B" class="d">B</a> calls C, and <a href="change.txt.html#C" class="d">C</a> calls <a href="insert.txt.html#A" class="d">A</a> again.  It's impossible
to reorder the <a href="eval.txt.html#functions" class="d">functions</a> to avoid forward references.

An alternative would be to first scan through the file to locate items and
figure out their type, so that forward references are found, and only then
execute the <a href="usr_41.txt.html#script" class="d">script</a> and compile the functions.  This means the <a href="usr_41.txt.html#script" class="d">script</a> has to be
parsed twice, which <a href="motion.txt.html#is" class="d">is</a> slower, and some conditions <a href="motion.txt.html#at" class="d">at</a> the <a href="usr_41.txt.html#script" class="d">script</a> level, such
<a href="motion.txt.html#as" class="d">as</a> checking if <a href="insert.txt.html#a" class="d">a</a> feature <a href="motion.txt.html#is" class="d">is</a> supported, are hard to use.  An attempt was made
to see if <a href="motion.txt.html#it" class="d">it</a> works, but <a href="motion.txt.html#it" class="d">it</a> turned out to be impossible to make work well.

It would be possible to compile all the <a href="eval.txt.html#functions" class="d">functions</a> <a href="motion.txt.html#at" class="d">at</a> the <a href="intro.txt.html#end" class="d">end</a> of the script.
The drawback <a href="motion.txt.html#is" class="d">is</a> that if <a href="insert.txt.html#a" class="d">a</a> function never gets called, the overhead of
compiling <a href="motion.txt.html#it" class="d">it</a> counts anyway.  Since <a href="starting.txt.html#startup" class="d">startup</a> speed <a href="motion.txt.html#is" class="d">is</a> very important, in most
cases it's better to <a href="diff.txt.html#do" class="d">do</a> <a href="motion.txt.html#it" class="d">it</a> later and accept that <a href="syntax.txt.html#syntax" class="d">syntax</a> and type <a href="message.txt.html#errors" class="d">errors</a> are
only reported then.  In <a href="change.txt.html#case" class="d">case</a> these <a href="message.txt.html#errors" class="d">errors</a> should be found early, e.g. when
testing, <a href="insert.txt.html#a" class="d">a</a> <span class="e">:defcompile</span> command <a href="motion.txt.html#at" class="d">at</a> the <a href="intro.txt.html#end" class="d">end</a> of the <a href="usr_41.txt.html#script" class="d">script</a> will <a href="helphelp.txt.html#help" class="d">help</a> out.


<span class="h">Why not use an existing embedded language? </span>

Vim supports interfaces to Perl, Python, Lua, <a href="if_tcl.txt.html#Tcl" class="d">Tcl</a> and <a href="insert.txt.html#a" class="d">a</a> few others.  But
these interfaces have never become widely used, for <a href="various.txt.html#various" class="d">various</a> reasons.  When
<a href="vim9.txt.html#Vim9" class="d">Vim9</a> was designed <a href="insert.txt.html#a" class="d">a</a> decision was made to make these interfaces lower priority
and concentrate on Vim script.

Still, <a href="usr_05.txt.html#plugin" class="d">plugin</a> writers may find other languages more familiar, want to use
existing libraries or see <a href="insert.txt.html#a" class="d">a</a> performance benefit.  We encourage <a href="usr_05.txt.html#plugin" class="d">plugin</a> authors
to write code in any language and run <a href="motion.txt.html#it" class="d">it</a> <a href="motion.txt.html#as" class="d">as</a> an external process, using jobs
and channels.  We can try to make this easier somehow.

Using an external tool also has disadvantages.  An alternative <a href="motion.txt.html#is" class="d">is</a> to convert
the tool into Vim script.  For that to be possible without too much
translation, and keeping the code fast <a href="motion.txt.html#at" class="d">at</a> the same time, the constructs of the
tool need to be supported.  Since <a href="vim9.txt.html#Vim9" class="d">Vim9</a> <a href="usr_41.txt.html#script" class="d">script</a> now includes support for
classes, objects, interfaces, and enums, that <a href="motion.txt.html#is" class="d">is</a> increasingly feasible.



 vim:tw=78:ts=8:noet:ft=help:norl:


</pre>
</div>
</main>
<p>Quick links:
<a href="index.html">help overview</a> &middot;
<a href="quickref.txt.html">quick reference</a> &middot;
<a href="usr_toc.txt.html">user manual toc</a> &middot;
<a href="index.html#reference_toc">reference manual toc</a>
&middot; <a href="vim_faq.txt.html">faq</a>
</p>
<footer>This site is maintained by Carlo Teubner (<i>(my first name) at cteubner dot net</i>).</footer>
</body>
</html>